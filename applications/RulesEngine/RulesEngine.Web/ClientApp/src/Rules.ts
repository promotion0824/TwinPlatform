//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v10.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * Get rule execution status
     * @return Success
     */
    list_rule_executions(  cancelToken?: CancelToken | undefined): Promise<RuleExecutionDto[]> {
        let url_ = this.baseUrl + "/api/Admin/list-rule-executions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList_rule_executions(_response);
        });
    }

    protected processList_rule_executions(response: AxiosResponse): Promise<RuleExecutionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleExecutionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleExecutionDto[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Refresh the twins and models cache
     * @param force (optional) 
     * @return Success
     */
    refresh_Cache(force: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/refresh-cache?";
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh_Cache(_response);
        });
    }

    protected processRefresh_Cache(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Rebuild the search index
     * @param force (optional) 
     * @param recreateIndex (optional) 
     * @return Success
     */
    rebuild_Search_Index(force: boolean | undefined, recreateIndex: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/rebuild-search-index?";
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        if (recreateIndex === null)
            throw new Error("The parameter 'recreateIndex' cannot be null.");
        else if (recreateIndex !== undefined)
            url_ += "recreateIndex=" + encodeURIComponent("" + recreateIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRebuild_Search_Index(_response);
        });
    }

    protected processRebuild_Search_Index(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Run diagnostics
     * @return Success
     */
    run_Diagnostics(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/run-diagnostics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRun_Diagnostics(_response);
        });
    }

    protected processRun_Diagnostics(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Rebuild rule instances for a willow environment, optionally rebuild a single rule
     * @param ruleId (optional) 
     * @param force (optional) 
     * @return Success
     */
    rebuild_Rules(ruleId: string | undefined, force: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/rebuild-rules?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRebuild_Rules(_response);
        });
    }

    protected processRebuild_Rules(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Rebuild calculated point rule instances for a willow environment
     * @return Success
     */
    rebuild_Calculated_Points(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/rebuild-calculated-points";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRebuild_Calculated_Points(_response);
        });
    }

    protected processRebuild_Calculated_Points(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Execute a range of datetime against live data running rules to create insights
     * @param daysAgo (optional) How many days back to go
     * @return Success
     */
    execute_rules(daysAgo: number | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/execute-rules?";
        if (daysAgo === null)
            throw new Error("The parameter 'daysAgo' cannot be null.");
        else if (daysAgo !== undefined)
            url_ += "daysAgo=" + encodeURIComponent("" + daysAgo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute_rules(_response);
        });
    }

    protected processExecute_rules(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Execute a range of datetime against live data running a single rule
     * @param ruleId (optional) The rule id to execute
     * @param daysAgo (optional) How many days back to go
     * @param deleteInsights (optional) Delete insights first before execution
     * @return Success
     */
    execute_single_rule(ruleId: string | undefined, daysAgo: number | undefined, deleteInsights: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Admin/execute-single-rule?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        if (daysAgo === null)
            throw new Error("The parameter 'daysAgo' cannot be null.");
        else if (daysAgo !== undefined)
            url_ += "daysAgo=" + encodeURIComponent("" + daysAgo) + "&";
        if (deleteInsights === null)
            throw new Error("The parameter 'deleteInsights' cannot be null.");
        else if (deleteInsights !== undefined)
            url_ += "deleteInsights=" + encodeURIComponent("" + deleteInsights) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute_single_rule(_response);
        });
    }

    protected processExecute_single_rule(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get recent progress
     * @return Success
     */
    getProgress(  cancelToken?: CancelToken | undefined): Promise<AdminProgressDto> {
        let url_ = this.baseUrl + "/api/Admin/get-progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProgress(_response);
        });
    }

    protected processGetProgress(response: AxiosResponse): Promise<AdminProgressDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminProgressDto.fromJS(resultData200);
            return Promise.resolve<AdminProgressDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdminProgressDto>(null as any);
    }

    /**
     * Gets processor logs ordered by timestamp descending
     * @param progressId (optional) ProgressId id filter
     * @param limit (optional) How many records to return
     * @param ascending (optional) Whether logs must start at earliest
     * @param level (optional) Which level to filter on
     * @param hoursBack (optional) How many hours back filter on
     * @return Success
     */
    getLogs(progressId: string | undefined, limit: number | undefined, ascending: boolean | undefined, level: string | undefined, hoursBack: number | undefined , cancelToken?: CancelToken | undefined): Promise<LogEntryDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Admin/get-logs?";
        if (progressId === null)
            throw new Error("The parameter 'progressId' cannot be null.");
        else if (progressId !== undefined)
            url_ += "progressId=" + encodeURIComponent("" + progressId) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "ascending=" + encodeURIComponent("" + ascending) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "level=" + encodeURIComponent("" + level) + "&";
        if (hoursBack === null)
            throw new Error("The parameter 'hoursBack' cannot be null.");
        else if (hoursBack !== undefined)
            url_ += "hoursBack=" + encodeURIComponent("" + hoursBack) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLogs(_response);
        });
    }

    protected processGetLogs(response: AxiosResponse): Promise<LogEntryDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LogEntryDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<LogEntryDtoBatchDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LogEntryDtoBatchDto>(null as any);
    }

    /**
     * Cancels a the specified job
     * @param body (optional) 
     * @return Success
     */
    cancelJob(body: ProgressDto | undefined , cancelToken?: CancelToken | undefined): Promise<ProgressDto> {
        let url_ = this.baseUrl + "/api/Admin/cancel-job";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelJob(_response);
        });
    }

    protected processCancelJob(response: AxiosResponse): Promise<ProgressDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgressDto.fromJS(resultData200);
            return Promise.resolve<ProgressDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProgressDto>(null as any);
    }

    /**
     * Process ADT twins for enabled instances for the rule
     * @param ruleId (optional) 
     * @return Success
     */
    processCalcPoints(ruleId: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/processCalcPoints?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcessCalcPoints(_response);
        });
    }

    protected processProcessCalcPoints(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a rule instance by id
     * @param id (optional) 
     * @return Success
     */
    getCalculatedPoint(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<CalculatedPointDto> {
        let url_ = this.baseUrl + "/api/CalculatedPoint/CalculatedPoint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCalculatedPoint(_response);
        });
    }

    protected processGetCalculatedPoint(response: AxiosResponse): Promise<CalculatedPointDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CalculatedPointDto.fromJS(resultData200);
            return Promise.resolve<CalculatedPointDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get calculated point after a given starting point
     * @param body (optional) 
     * @return Success
     */
    getCalculatedPointsAfter(id: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<CalculatedPointDtoBatchDto> {
        let url_ = this.baseUrl + "/api/CalculatedPoint/calculatedPointsafter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCalculatedPointsAfter(_response);
        });
    }

    protected processGetCalculatedPointsAfter(response: AxiosResponse): Promise<CalculatedPointDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CalculatedPointDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<CalculatedPointDtoBatchDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CalculatedPointDtoBatchDto>(null as any);
    }

    /**
     * Exports calculated point after a given starting point
     * @param id (optional) 
     * @param body (optional) 
     */
    exportCalculatedPointsAfter(id: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/CalculatedPoint/exportCalculatedPointsafter?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCalculatedPointsAfter(_response);
        });
    }

    protected processExportCalculatedPointsAfter(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get all commands after a given point
     * @param body (optional) 
     * @return Success
     */
    getCommandsAfter(ruleId: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<CommandDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Command/commandafter/{ruleId}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommandsAfter(_response);
        });
    }

    protected processGetCommandsAfter(response: AxiosResponse): Promise<CommandDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<CommandDtoBatchDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommandDtoBatchDto>(null as any);
    }

    /**
     * Get the commands that have been created for a specific equipment item
     * @param equipmentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    commandsForEquipment(equipmentId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<CommandDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Command/CommandsForEquipment?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommandsForEquipment(_response);
        });
    }

    protected processCommandsForEquipment(response: AxiosResponse): Promise<CommandDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<CommandDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the commands that have been created for a specific equipment item
     * @param equipmentId (optional) 
     * @param body (optional) 
     */
    exportCommandsForEquipment(equipmentId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Command/ExportCommandsForEquipment?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCommandsForEquipment(_response);
        });
    }

    protected processExportCommandsForEquipment(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get the commands that have been created for a specific erule instance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    commandsForRuleInstance(ruleInstanceId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<CommandDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Command/CommandsForRuleInstance?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommandsForRuleInstance(_response);
        });
    }

    protected processCommandsForRuleInstance(response: AxiosResponse): Promise<CommandDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<CommandDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the commands that have been created for a specific rule instance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     */
    exportCommandsForRuleInstance(ruleInstanceId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Command/ExportCommandsForRuleInstance?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCommandsForRuleInstance(_response);
        });
    }

    protected processExportCommandsForRuleInstance(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get a single Command
     * @param id (optional) 
     * @return Success
     */
    getCommand(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<CommandDto> {
        let url_ = this.baseUrl + "/api/Command/command?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommand(_response);
        });
    }

    protected processGetCommand(response: AxiosResponse): Promise<CommandDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommandDto.fromJS(resultData200);
            return Promise.resolve<CommandDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports all commands after a given point
     * @param body (optional) 
     */
    exportCommandsAfter(ruleId: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Command/exportcommandafter/{ruleId}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCommandsAfter(_response);
        });
    }

    protected processExportCommandsAfter(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Post and enable/disable a command to sync Command and Control
     * @param commandId (optional) 
     * @param body (optional) 
     * @return Success
     */
    postToCommand(commandId: string | undefined, body: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Command/post-to-command?";
        if (commandId === null)
            throw new Error("The parameter 'commandId' cannot be null.");
        else if (commandId !== undefined)
            url_ += "commandId=" + encodeURIComponent("" + commandId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostToCommand(_response);
        });
    }

    protected processPostToCommand(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets application environment information including ADB2C redirect and Willow Environment name and id
     * @return Success
     */
    getEnvironmentInfo(  cancelToken?: CancelToken | undefined): Promise<EnvironmentDto> {
        let url_ = this.baseUrl + "/api/environment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnvironmentInfo(_response);
        });
    }

    protected processGetEnvironmentInfo(response: AxiosResponse): Promise<EnvironmentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnvironmentDto.fromJS(resultData200);
            return Promise.resolve<EnvironmentDto>(result200);

        } else {
            const _responseText = response.data;
            return throwException("Error", status, _responseText, _headers);

        }
    }

    /**
     * Gets application environment information as a javascript script file
     * @return Success
     */
    getEnvironmentScript(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/environmentscript";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnvironmentScript(_response);
        });
    }

    protected processGetEnvironmentScript(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            return throwException("Error", status, _responseText, _headers);

        }
    }

    /**
     * Download debug info for rule instance in a ZIP file
     * @param id (optional) 
     * @param token (optional) 
     * @param downloadTelemetry (optional) 
     */
    downloadDebugInfo(id: string | undefined, token: string | undefined, downloadTelemetry: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/File/download-debug-info?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (downloadTelemetry === null)
            throw new Error("The parameter 'downloadTelemetry' cannot be null.");
        else if (downloadTelemetry !== undefined)
            url_ += "downloadTelemetry=" + encodeURIComponent("" + downloadTelemetry) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/zip"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadDebugInfo(_response);
        });
    }

    protected processDownloadDebugInfo(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Download all rules in a ZIP file
     * @param token (optional) 
     * @return Success
     */
    downloadRulesZip(token: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/File/download?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadRulesZip(_response);
        });
    }

    protected processDownloadRulesZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Download all globals in a ZIP file
     * @param token (optional) 
     * @return Success
     */
    downloadGlobalsZip(token: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/File/downloadGlobals?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadGlobalsZip(_response);
        });
    }

    protected processDownloadGlobalsZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Download all globals in a ZIP file
     * @param token (optional) 
     * @return Success
     */
    downloadMLModelsZip(token: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/File/downloadMLModels?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMLModelsZip(_response);
        });
    }

    protected processDownloadMLModelsZip(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Download all insights in a ZIP file
     * @param token (optional) 
     * @return Success
     */
    downloadInsights(token: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/File/download-insights?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadInsights(_response);
        });
    }

    protected processDownloadInsights(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all globals
     * @param body (optional) 
     * @return Success
     */
    globals(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<GlobalVariableDtoBatchDto> {
        let url_ = this.baseUrl + "/api/GlobalVariable/Globals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobals(_response);
        });
    }

    protected processGlobals(response: AxiosResponse): Promise<GlobalVariableDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalVariableDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<GlobalVariableDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get rule or other global references for a global
     * @param id (optional) 
     * @return Success
     */
    getGlobalReferences(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleReferenceDto[]> {
        let url_ = this.baseUrl + "/api/GlobalVariable/GetGlobalReferences?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGlobalReferences(_response);
        });
    }

    protected processGetGlobalReferences(response: AxiosResponse): Promise<RuleReferenceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleReferenceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleReferenceDto[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports all rules
     * @param body (optional) 
     */
    exportGlobals(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/GlobalVariable/ExportGlobals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportGlobals(_response);
        });
    }

    protected processExportGlobals(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete a global variable
     * @return Success
     */
    deleteGlobalVariable(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/GlobalVariable/global-variable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteGlobalVariable(_response);
        });
    }

    protected processDeleteGlobalVariable(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get a global variable
     * @param id (optional) 
     * @return Success
     */
    getGlobalVariable(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<GlobalVariableDto> {
        let url_ = this.baseUrl + "/api/GlobalVariable/GlobalVariable?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGlobalVariable(_response);
        });
    }

    protected processGetGlobalVariable(response: AxiosResponse): Promise<GlobalVariableDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalVariableDto.fromJS(resultData200);
            return Promise.resolve<GlobalVariableDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Validate a global variable
     * @param body (optional) 
     * @return Success
     */
    validateGlobalVariable(body: GlobalVariableDto | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/GlobalVariable/ValidateGlobalVariable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateGlobalVariable(_response);
        });
    }

    protected processValidateGlobalVariable(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ValidationReponseDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Upsert a global variable
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    upsertGlobalVariable(id: string | undefined, body: GlobalVariableDto | undefined , cancelToken?: CancelToken | undefined): Promise<GlobalVariableDto> {
        let url_ = this.baseUrl + "/api/GlobalVariable/upsertGlobalVariable?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpsertGlobalVariable(_response);
        });
    }

    protected processUpsertGlobalVariable(response: AxiosResponse): Promise<GlobalVariableDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalVariableDto.fromJS(resultData200);
            return Promise.resolve<GlobalVariableDto>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = GlobalVariableDto.fromJS(resultData201);
            return Promise.resolve<GlobalVariableDto>(result201);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ValidationReponseDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the distinct tags
     * @return Success
     */
    globalVariableTags(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/GlobalVariable/GlobalVariableTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalVariableTags(_response);
        });
    }

    protected processGlobalVariableTags(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get the insights that have been created for a specific equipment item (or location)
     * @param equipmentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    insightsForEquipment(equipmentId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<InsightDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Insights/InsightsForEquipment?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsightsForEquipment(_response);
        });
    }

    protected processInsightsForEquipment(response: AxiosResponse): Promise<InsightDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsightDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<InsightDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get insight status history
     * @param id (optional) 
     * @return Success
     */
    insightStatusHistory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<InsightStatusDto[]> {
        let url_ = this.baseUrl + "/api/Insights/InsightStatusHistory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsightStatusHistory(_response);
        });
    }

    protected processInsightStatusHistory(response: AxiosResponse): Promise<InsightStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InsightStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InsightStatusDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the insights that have been created for a specific equipment item (or location)
     * @param equipmentId (optional) 
     * @param body (optional) 
     */
    exportInsightsForEquipment(equipmentId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Insights/ExportInsightsForEquipment?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportInsightsForEquipment(_response);
        });
    }

    protected processExportInsightsForEquipment(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get one Insight but with additional fields from the Rule (description, recommendation, ...)
     * @param id (optional) 
     * @return Success
     */
    getInsight(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<InsightDto> {
        let url_ = this.baseUrl + "/api/Insights/insight?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInsight(_response);
        });
    }

    protected processGetInsight(response: AxiosResponse): Promise<InsightDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsightDto.fromJS(resultData200);
            return Promise.resolve<InsightDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get all insights after a given point
     * @param body (optional) 
     * @return Success
     */
    getInsightsAfter(ruleId: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<InsightDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Insights/insightafter/{ruleId}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInsightsAfter(_response);
        });
    }

    protected processGetInsightsAfter(response: AxiosResponse): Promise<InsightDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsightDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<InsightDtoBatchDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsightDtoBatchDto>(null as any);
    }

    /**
     * Get insights for which another insight is dependant on
     * @return Success
     */
    getDependantInsights(insightId: string , cancelToken?: CancelToken | undefined): Promise<InsightDependencyDto[]> {
        let url_ = this.baseUrl + "/api/Insights/dependantinsights/{insightId}";
        if (insightId === undefined || insightId === null)
            throw new Error("The parameter 'insightId' must be defined.");
        url_ = url_.replace("{insightId}", encodeURIComponent("" + insightId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDependantInsights(_response);
        });
    }

    protected processGetDependantInsights(response: AxiosResponse): Promise<InsightDependencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InsightDependencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InsightDependencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsightDependencyDto[]>(null as any);
    }

    /**
     * Exports all insights after a given point
     * @param body (optional) 
     */
    exportInsightsAfter(ruleId: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Insights/exportinsightafter/{ruleId}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportInsightsAfter(_response);
        });
    }

    protected processExportInsightsAfter(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get the insights that have been created for a specific model
     * @param modelId (optional) 
     * @param body (optional) 
     * @return Success
     */
    insightsForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<InsightDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Insights/InsightsForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsightsForModel(_response);
        });
    }

    protected processInsightsForModel(response: AxiosResponse): Promise<InsightDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsightDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<InsightDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the insights that have been created for a specific model
     * @param modelId (optional) 
     * @param body (optional) 
     */
    exportInsightsForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Insights/ExportInsightsForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportInsightsForModel(_response);
        });
    }

    protected processExportInsightsForModel(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete an Insight
     * @param insightId (optional) 
     * @return Success
     */
    deleteInsight(insightId: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/delete-insight?";
        if (insightId === null)
            throw new Error("The parameter 'insightId' cannot be null.");
        else if (insightId !== undefined)
            url_ += "insightId=" + encodeURIComponent("" + insightId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteInsight(_response);
        });
    }

    protected processDeleteInsight(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete all insights for a given rule
     * @param ruleId (optional) 
     * @return Success
     */
    deleteInsightsForRule(ruleId: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/delete-insights-for-rule?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteInsightsForRule(_response);
        });
    }

    protected processDeleteInsightsForRule(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Disable all insights
     * @return Success
     */
    disableInsights(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/disable-insights";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisableInsights(_response);
        });
    }

    protected processDisableInsights(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete all insights which are flagged not to sync to Command but which have already been syncd to Command
     * @param removeCommandId (optional) 
     * @return Success
     */
    deleteNotSyncdInsightsFromCommand(removeCommandId: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/delete-not-syncd-insights-from-command?";
        if (removeCommandId === null)
            throw new Error("The parameter 'removeCommandId' cannot be null.");
        else if (removeCommandId !== undefined)
            url_ += "removeCommandId=" + encodeURIComponent("" + removeCommandId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteNotSyncdInsightsFromCommand(_response);
        });
    }

    protected processDeleteNotSyncdInsightsFromCommand(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete all insights from Rules Engine, optionally deleting from Command, Actors and/or TimeSeries
     * @param deleteFromCommand (optional) 
     * @param deleteActors (optional) 
     * @param deleteTimeseries (optional) 
     * @return Success
     */
    deleteAllInsights(deleteFromCommand: boolean | undefined, deleteActors: boolean | undefined, deleteTimeseries: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/delete-all-insights?";
        if (deleteFromCommand === null)
            throw new Error("The parameter 'deleteFromCommand' cannot be null.");
        else if (deleteFromCommand !== undefined)
            url_ += "deleteFromCommand=" + encodeURIComponent("" + deleteFromCommand) + "&";
        if (deleteActors === null)
            throw new Error("The parameter 'deleteActors' cannot be null.");
        else if (deleteActors !== undefined)
            url_ += "deleteActors=" + encodeURIComponent("" + deleteActors) + "&";
        if (deleteTimeseries === null)
            throw new Error("The parameter 'deleteTimeseries' cannot be null.");
        else if (deleteTimeseries !== undefined)
            url_ += "deleteTimeseries=" + encodeURIComponent("" + deleteTimeseries) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllInsights(_response);
        });
    }

    protected processDeleteAllInsights(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Reverse sync command insight Id back to rules engine insights
     * @return Success
     */
    reverseSyncInsightsFromCommand(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Insights/reverse-sync-insights-from-command";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReverseSyncInsightsFromCommand(_response);
        });
    }

    protected processReverseSyncInsightsFromCommand(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets insight summary info
     * @return Success
     */
    getInsightsSummary(  cancelToken?: CancelToken | undefined): Promise<InsightsSummaryDto> {
        let url_ = this.baseUrl + "/api/Insights/get-insights-summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInsightsSummary(_response);
        });
    }

    protected processGetInsightsSummary(response: AxiosResponse): Promise<InsightsSummaryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsightsSummaryDto.fromJS(resultData200);
            return Promise.resolve<InsightsSummaryDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Post an insight to command and keep posting future updates
     * @param insightId (optional) 
     * @param body (optional) 
     * @return Success
     */
    postInsightToCommand(insightId: string | undefined, body: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Insights/insight-to-command?";
        if (insightId === null)
            throw new Error("The parameter 'insightId' cannot be null.");
        else if (insightId !== undefined)
            url_ += "insightId=" + encodeURIComponent("" + insightId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostInsightToCommand(_response);
        });
    }

    protected processPostInsightToCommand(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get download token for insights
     * @return Success
     */
    getTokenForInsightsDownload(  cancelToken?: CancelToken | undefined): Promise<ShortLivedTokenDto> {
        let url_ = this.baseUrl + "/api/Insights/downloadtoken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTokenForInsightsDownload(_response);
        });
    }

    protected processGetTokenForInsightsDownload(response: AxiosResponse): Promise<ShortLivedTokenDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortLivedTokenDto.fromJS(resultData200);
            return Promise.resolve<ShortLivedTokenDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortLivedTokenDto>(null as any);
    }

    /**
     * Get all models
     * @param body (optional) 
     * @return Success
     */
    mLModels(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<MLModelDtoBatchDto> {
        let url_ = this.baseUrl + "/api/MLModel/MLModels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMLModels(_response);
        });
    }

    protected processMLModels(response: AxiosResponse): Promise<MLModelDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MLModelDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<MLModelDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get rule references for a model
     * @param id (optional) 
     * @return Success
     */
    getMLModelReferences(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleReferenceDto[]> {
        let url_ = this.baseUrl + "/api/MLModel/GetMLModelReferences?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMLModelReferences(_response);
        });
    }

    protected processGetMLModelReferences(response: AxiosResponse): Promise<RuleReferenceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleReferenceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleReferenceDto[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports all rules
     * @param body (optional) 
     */
    exportMLModels(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/MLModel/ExportMLModels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportMLModels(_response);
        });
    }

    protected processExportMLModels(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete a model variable
     * @return Success
     */
    deleteMLModel(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MLModel/model-variable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMLModel(_response);
        });
    }

    protected processDeleteMLModel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get a model variable
     * @param id (optional) 
     * @return Success
     */
    getMLModel(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<MLModelDto> {
        let url_ = this.baseUrl + "/api/MLModel/MLModel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMLModel(_response);
        });
    }

    protected processGetMLModel(response: AxiosResponse): Promise<MLModelDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MLModelDto.fromJS(resultData200);
            return Promise.resolve<MLModelDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a single model by model id
     * @param modelId (optional) 
     * @return Success
     */
    model(modelId: string | undefined , cancelToken?: CancelToken | undefined): Promise<ModelDto> {
        let url_ = this.baseUrl + "/api/Model/Model?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModel(_response);
        });
    }

    protected processModel(response: AxiosResponse): Promise<ModelDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModelDto.fromJS(resultData200);
            return Promise.resolve<ModelDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets all models used in the twin
     * @return Success
     */
    models(  cancelToken?: CancelToken | undefined): Promise<ModelDto[]> {
        let url_ = this.baseUrl + "/api/Model/Models";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModels(_response);
        });
    }

    protected processModels(response: AxiosResponse): Promise<ModelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModelDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ModelDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a graph of the ontology with inheritance relationships between models
     * @param modelId (optional) 
     * @param body (optional) 
     * @return Success
     */
    ontology(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<BatchDtoModelSimpleGraphDto> {
        let url_ = this.baseUrl + "/api/Model/Ontology?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOntology(_response);
        });
    }

    protected processOntology(response: AxiosResponse): Promise<BatchDtoModelSimpleGraphDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatchDtoModelSimpleGraphDto.fromJS(resultData200);
            return Promise.resolve<BatchDtoModelSimpleGraphDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the models
     * @param modelId (optional) 
     * @param body (optional) 
     */
    exportOntology(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Model/ExportOntology?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportOntology(_response);
        });
    }

    protected processExportOntology(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Gets the metagraph which can be used for autcomplete and other purposes
     * @return Success
     */
    modelsAutocomplete(  cancelToken?: CancelToken | undefined): Promise<ModelSimpleGraphDto> {
        let url_ = this.baseUrl + "/api/Model/ModelsAutocomplete";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModelsAutocomplete(_response);
        });
    }

    protected processModelsAutocomplete(response: AxiosResponse): Promise<ModelSimpleGraphDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModelSimpleGraphDto.fromJS(resultData200);
            return Promise.resolve<ModelSimpleGraphDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the system graph for a single model from the meta graph
     * @param modelId (optional) 
     * @return Success
     */
    modelSystemGraph(modelId: string | undefined , cancelToken?: CancelToken | undefined): Promise<ModelSimpleGraphDto> {
        let url_ = this.baseUrl + "/api/Model/ModelSystemGraph?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModelSystemGraph(_response);
        });
    }

    protected processModelSystemGraph(response: AxiosResponse): Promise<ModelSimpleGraphDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ModelSimpleGraphDto.fromJS(resultData200);
            return Promise.resolve<ModelSimpleGraphDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get all rules
     * @param body (optional) 
     * @return Success
     */
    rules(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Rule/Rules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRules(_response);
        });
    }

    protected processRules(response: AxiosResponse): Promise<RuleDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<RuleDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports all rules
     * @param body (optional) 
     */
    exportRules(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Rule/ExportRules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRules(_response);
        });
    }

    protected processExportRules(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get the rules that apply to a model
     * @param modelId (optional) 
     * @param body (optional) 
     * @return Success
     */
    rulesForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Rule/RulesForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRulesForModel(_response);
        });
    }

    protected processRulesForModel(response: AxiosResponse): Promise<RuleDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<RuleDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the rules that apply to a model
     * @param modelId (optional) 
     * @param body (optional) 
     */
    exportRulesForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Rule/ExportRulesForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRulesForModel(_response);
        });
    }

    protected processExportRulesForModel(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Gets the distinct catgory names currently in use for rules
     * @return Success
     */
    ruleCategories(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Rule/RuleCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRuleCategories(_response);
        });
    }

    protected processRuleCategories(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get a rule with associated metadata
     * @param id (optional) 
     * @return Success
     */
    getRule(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDto> {
        let url_ = this.baseUrl + "/api/Rule/Rule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRule(_response);
        });
    }

    protected processGetRule(response: AxiosResponse): Promise<RuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDto.fromJS(resultData200);
            return Promise.resolve<RuleDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete a rule
     * @param id (optional) 
     * @return Success
     */
    deleteRule(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDto> {
        let url_ = this.baseUrl + "/api/Rule/Rule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRule(_response);
        });
    }

    protected processDeleteRule(response: AxiosResponse): Promise<RuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDto.fromJS(resultData200);
            return Promise.resolve<RuleDto>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ValidationReponseDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a list of rules the provided rule can possibly depend on
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    getRuleDependencies(id: string | undefined, body: RuleDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDependencyListItemDto[]> {
        let url_ = this.baseUrl + "/api/Rule/GetRuleDependencies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleDependencies(_response);
        });
    }

    protected processGetRuleDependencies(response: AxiosResponse): Promise<RuleDependencyListItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleDependencyListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleDependencyListItemDto[]>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = RuleDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Upsert a rule to database and trigger instance re-generation
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    upsertRule(id: string | undefined, body: RuleDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDto> {
        let url_ = this.baseUrl + "/api/Rule/upsertrule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpsertRule(_response);
        });
    }

    protected processUpsertRule(response: AxiosResponse): Promise<RuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDto.fromJS(resultData200);
            return Promise.resolve<RuleDto>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ValidationReponseDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the names of all the available RuleTemplates
     * @return Success
     */
    getRuleTemplates(  cancelToken?: CancelToken | undefined): Promise<RuleTemplateDto[]> {
        let url_ = this.baseUrl + "/api/Rule/RuleTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleTemplates(_response);
        });
    }

    protected processGetRuleTemplates(response: AxiosResponse): Promise<RuleTemplateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleTemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleTemplateDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a list of predefined units
     * @return Success
     */
    getUnits(  cancelToken?: CancelToken | undefined): Promise<UnitDto[]> {
        let url_ = this.baseUrl + "/api/Rule/GetUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUnits(_response);
        });
    }

    protected processGetUnits(response: AxiosResponse): Promise<UnitDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UnitDto[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Creates a new rule from a template
     * @param templateId (optional) 
     * @return Success
     */
    createRule(templateId: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleDto> {
        let url_ = this.baseUrl + "/api/Rule/createRule?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRule(_response);
        });
    }

    protected processCreateRule(response: AxiosResponse): Promise<RuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleDto.fromJS(resultData200);
            return Promise.resolve<RuleDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Syncs working directory of rules with remote Git repository
     * @return Success
     */
    syncWithRemote(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rule/SyncWithRemote";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncWithRemote(_response);
        });
    }

    protected processSyncWithRemote(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Expands the rule if necessary and returns a count of rule instances
     * @param ruleId (optional) 
     * @return Success
     */
    getRuleMetadata(ruleId: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleMetadataDto> {
        let url_ = this.baseUrl + "/api/Rule/RuleMetadata?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleMetadata(_response);
        });
    }

    protected processGetRuleMetadata(response: AxiosResponse): Promise<RuleMetadataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleMetadataDto.fromJS(resultData200);
            return Promise.resolve<RuleMetadataDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the current execution state of a processing rule execution
     * @param ruleId (optional) 
     * @return Success
     */
    getRuleExecution(ruleId: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleExecutionDto> {
        let url_ = this.baseUrl + "/api/Rule/RuleExecution?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleExecution(_response);
        });
    }

    protected processGetRuleExecution(response: AxiosResponse): Promise<RuleExecutionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleExecutionDto.fromJS(resultData200);
            return Promise.resolve<RuleExecutionDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Enable posting insights and commands to command for the rule
     * @param ruleId (optional) 
     * @param body (optional) 
     * @return Success
     */
    enabledInsightToCommand(ruleId: string | undefined, body: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rule/enable-insight-to-command?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnabledInsightToCommand(_response);
        });
    }

    protected processEnabledInsightToCommand(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Validate rule
     * @param body (optional) 
     * @return Success
     */
    validateRule(body: RuleDto | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rule/validateRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateRule(_response);
        });
    }

    protected processValidateRule(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ValidationReponseDto.fromJS(resultData422);
            return throwException("Client Error", status, _responseText, _headers, result422);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Enable ADT twins for enabled instances for the rule
     * @param ruleId (optional) 
     * @param body (optional) 
     * @return Success
     */
    enableADTSync(ruleId: string | undefined, body: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rule/enableADTSync?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnableADTSync(_response);
        });
    }

    protected processEnableADTSync(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the distinct tags
     * @return Success
     */
    ruleTags(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Rule/RuleTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRuleTags(_response);
        });
    }

    protected processRuleTags(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a rule instance by id
     * @param id (optional) 
     * @return Success
     */
    getRuleInstance(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleInstanceDto> {
        let url_ = this.baseUrl + "/api/RuleInstance/ruleinstance?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleInstance(_response);
        });
    }

    protected processGetRuleInstance(response: AxiosResponse): Promise<RuleInstanceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleInstanceDto.fromJS(resultData200);
            return Promise.resolve<RuleInstanceDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets rule instances by modelId
     * @param modelId (optional) 
     * @param body (optional) 
     * @return Success
     */
    ruleInstancesForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleInstanceDtoBatchDto> {
        let url_ = this.baseUrl + "/api/RuleInstance/RuleInstancesForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRuleInstancesForModel(_response);
        });
    }

    protected processRuleInstancesForModel(response: AxiosResponse): Promise<RuleInstanceDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleInstanceDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<RuleInstanceDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports rule instances by modelId
     * @param modelId (optional) 
     * @param body (optional) 
     */
    exportRuleInstancesForModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/RuleInstance/ExportRuleInstancesForModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRuleInstancesForModel(_response);
        });
    }

    protected processExportRuleInstancesForModel(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Change the enabled or disabled state for a RuleInstance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    enableRuleInstance(ruleInstanceId: string | undefined, body: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/rule-instance-enable?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnableRuleInstance(_response);
        });
    }

    protected processEnableRuleInstance(response: AxiosResponse): Promise<boolean[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<boolean[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Change the review status of the rule instance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateRuleInstanceReviewStatus(ruleInstanceId: string | undefined, body: ReviewStatus | undefined , cancelToken?: CancelToken | undefined): Promise<boolean[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/rule-instance-review-status?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRuleInstanceReviewStatus(_response);
        });
    }

    protected processUpdateRuleInstanceReviewStatus(response: AxiosResponse): Promise<boolean[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<boolean[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Change the review status of the rule instance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateRuleInstanceTags(ruleInstanceId: string | undefined, body: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/rule-instance-tags?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRuleInstanceTags(_response);
        });
    }

    protected processUpdateRuleInstanceTags(response: AxiosResponse): Promise<boolean[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<boolean[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the distinct tags
     * @return Success
     */
    ruleInstanceTags(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/RuleInstanceTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRuleInstanceTags(_response);
        });
    }

    protected processRuleInstanceTags(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Add a review comment to the rule instance
     * @param ruleInstanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addRuleInstanceReviewComment(ruleInstanceId: string | undefined, body: string | undefined , cancelToken?: CancelToken | undefined): Promise<RuleCommentDto> {
        let url_ = this.baseUrl + "/api/RuleInstance/rule-instance-review-comment?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddRuleInstanceReviewComment(_response);
        });
    }

    protected processAddRuleInstanceReviewComment(response: AxiosResponse): Promise<RuleCommentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleCommentDto.fromJS(resultData200);
            return Promise.resolve<RuleCommentDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get rule instances after a given starting point, filtered to a given rule id
     * @param body (optional) 
     * @return Success
     */
    getInstancesAfter(id: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleInstanceDtoBatchDto> {
        let url_ = this.baseUrl + "/api/RuleInstance/instanceafter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstancesAfter(_response);
        });
    }

    protected processGetInstancesAfter(response: AxiosResponse): Promise<RuleInstanceDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleInstanceDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<RuleInstanceDtoBatchDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleInstanceDtoBatchDto>(null as any);
    }

    /**
     * Get a lite version of rule instances for a rule
     * @return Success
     */
    getRuleInstanceList(id: string , cancelToken?: CancelToken | undefined): Promise<RuleInstanceListItemDto[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/ruleinstancelist/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleInstanceList(_response);
        });
    }

    protected processGetRuleInstanceList(response: AxiosResponse): Promise<RuleInstanceListItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleInstanceListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RuleInstanceListItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleInstanceListItemDto[]>(null as any);
    }

    /**
     * Exports rule instances after a given starting point, filtered to a given rule id
     * @param body (optional) 
     */
    exportRuleInstancesAfter(id: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/RuleInstance/exportinstanceafter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRuleInstancesAfter(_response);
        });
    }

    protected processExportRuleInstancesAfter(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Download rule instances in a ZIP file
     * @param body (optional) 
     */
    downloadRuleInstances(id: string, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/RuleInstance/download-rule-instances/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/zip"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadRuleInstances(_response);
        });
    }

    protected processDownloadRuleInstances(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Change the enabled, reviewStatus and comment for one or more rule instances
     * @param body (optional) 
     * @return Success
     */
    updateRuleInstanceProperties(body: RuleInstancePropertiesDto | undefined , cancelToken?: CancelToken | undefined): Promise<boolean[]> {
        let url_ = this.baseUrl + "/api/RuleInstance/updateRuleInstanceProperties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRuleInstanceProperties(_response);
        });
    }

    protected processUpdateRuleInstanceProperties(response: AxiosResponse): Promise<boolean[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<boolean[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Upload one or more rules in a JSON file
     * @param saveRules (optional) 
     * @param saveGlobals (optional) 
     * @param saveMLModels (optional) 
     * @return Success
     */
    upload(saveRules: boolean | undefined, saveGlobals: boolean | undefined, saveMLModels: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<RuleUploadResultDto> {
        let url_ = this.baseUrl + "/api/RuleUpload/upload?";
        if (saveRules === null)
            throw new Error("The parameter 'saveRules' cannot be null.");
        else if (saveRules !== undefined)
            url_ += "saveRules=" + encodeURIComponent("" + saveRules) + "&";
        if (saveGlobals === null)
            throw new Error("The parameter 'saveGlobals' cannot be null.");
        else if (saveGlobals !== undefined)
            url_ += "saveGlobals=" + encodeURIComponent("" + saveGlobals) + "&";
        if (saveMLModels === null)
            throw new Error("The parameter 'saveMLModels' cannot be null.");
        else if (saveMLModels !== undefined)
            url_ += "saveMLModels=" + encodeURIComponent("" + saveMLModels) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<RuleUploadResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleUploadResultDto.fromJS(resultData200);
            return Promise.resolve<RuleUploadResultDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get download rules token
     * @return Success
     */
    getTokenForRulesDownload(  cancelToken?: CancelToken | undefined): Promise<ShortLivedTokenDto> {
        let url_ = this.baseUrl + "/api/RuleUpload/downloadtoken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTokenForRulesDownload(_response);
        });
    }

    protected processGetTokenForRulesDownload(response: AxiosResponse): Promise<ShortLivedTokenDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortLivedTokenDto.fromJS(resultData200);
            return Promise.resolve<ShortLivedTokenDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortLivedTokenDto>(null as any);
    }

    /**
     * Get search results for a query string
     * @param query (optional) 
     * @param offset (optional) 
     * @param take (optional) 
     * @return Success
     */
    search(query: string | undefined, offset: number | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<SearchResultDto> {
        let url_ = this.baseUrl + "/api/Search/Search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<SearchResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SearchResultDto.fromJS(resultData200);
            return Promise.resolve<SearchResultDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports search results
     * @param query (optional) 
     * @param take (optional) 
     */
    exportSearch(query: string | undefined, take: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Search/ExportSearch?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportSearch(_response);
        });
    }

    protected processExportSearch(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Simulates rule execution for a given ruleid and equipmentid
     * @param body (optional) 
     * @return Success
     */
    executeSimulationForRule(body: RuleSimulationRequest | undefined , cancelToken?: CancelToken | undefined): Promise<SimulationResultDto> {
        let url_ = this.baseUrl + "/api/Simulation/execute-simulation-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecuteSimulationForRule(_response);
        });
    }

    protected processExecuteSimulationForRule(response: AxiosResponse): Promise<SimulationResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SimulationResultDto.fromJS(resultData200);
            return Promise.resolve<SimulationResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimulationResultDto>(null as any);
    }

    /**
     * Get a summary of execution progress
     * @return Success
     */
    progress(  cancelToken?: CancelToken | undefined): Promise<ProgressSummaryDto> {
        let url_ = this.baseUrl + "/api/Summary/Progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProgress(_response);
        });
    }

    protected processProgress(response: AxiosResponse): Promise<ProgressSummaryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProgressSummaryDto.fromJS(resultData200);
            return Promise.resolve<ProgressSummaryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get a summary of twin counts
     * @return Success
     */
    summary(  cancelToken?: CancelToken | undefined): Promise<ADTSummaryDto[]> {
        let url_ = this.baseUrl + "/api/Summary/Summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummary(_response);
        });
    }

    protected processSummary(response: AxiosResponse): Promise<ADTSummaryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ADTSummaryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ADTSummaryDto[]>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Server Error", status, _responseText, _headers);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get a summary of the whole system
     * @return Success
     */
    systemSummary(  cancelToken?: CancelToken | undefined): Promise<SystemSummaryDto> {
        let url_ = this.baseUrl + "/api/Summary/SystemSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSystemSummary(_response);
        });
    }

    protected processSystemSummary(response: AxiosResponse): Promise<SystemSummaryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemSummaryDto.fromJS(resultData200);
            return Promise.resolve<SystemSummaryDto>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Server Error", status, _responseText, _headers);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets timeseries data for charts for a specific rule instance
     * @param ruleInstanceId (optional) Id of the rule instance
     * @return Success
     */
    getTimeSeriesData(ruleInstanceId: string | undefined , cancelToken?: CancelToken | undefined): Promise<TimeSeriesDataDto> {
        let url_ = this.baseUrl + "/api/Timeseries/GetTimeSeriesData?";
        if (ruleInstanceId === null)
            throw new Error("The parameter 'ruleInstanceId' cannot be null.");
        else if (ruleInstanceId !== undefined)
            url_ += "ruleInstanceId=" + encodeURIComponent("" + ruleInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeSeriesData(_response);
        });
    }

    protected processGetTimeSeriesData(response: AxiosResponse): Promise<TimeSeriesDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeSeriesDataDto.fromJS(resultData200);
            return Promise.resolve<TimeSeriesDataDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets timeseries data for charts for a specific capability twin
     * @param twinId (optional) TwinId
     * @param startTime (optional) An optional start time for the data else it defaults to 10 days back
     * @param endTime (optional) An optional end time for the data else it defaults current time
     * @param timeZone (optional) An optional timeZone for the data else it defaults to UTC
     * @param enableCompression (optional) enableCompression
     * @param optmizeCompression (optional) optmizeCompression
     * @return Success
     */
    getTimeSeriesDataForCapability(twinId: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, timeZone: string | undefined, enableCompression: boolean | undefined, optmizeCompression: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<TimeSeriesBufferDto> {
        let url_ = this.baseUrl + "/api/Timeseries/get-timeseriesdata-for-capability?";
        if (twinId === null)
            throw new Error("The parameter 'twinId' cannot be null.");
        else if (twinId !== undefined)
            url_ += "twinId=" + encodeURIComponent("" + twinId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString(true) : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString(true) : "") + "&";
        if (timeZone === null)
            throw new Error("The parameter 'timeZone' cannot be null.");
        else if (timeZone !== undefined)
            url_ += "timeZone=" + encodeURIComponent("" + timeZone) + "&";
        if (enableCompression === null)
            throw new Error("The parameter 'enableCompression' cannot be null.");
        else if (enableCompression !== undefined)
            url_ += "enableCompression=" + encodeURIComponent("" + enableCompression) + "&";
        if (optmizeCompression === null)
            throw new Error("The parameter 'optmizeCompression' cannot be null.");
        else if (optmizeCompression !== undefined)
            url_ += "optmizeCompression=" + encodeURIComponent("" + optmizeCompression) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeSeriesDataForCapability(_response);
        });
    }

    protected processGetTimeSeriesDataForCapability(response: AxiosResponse): Promise<TimeSeriesBufferDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeSeriesBufferDto.fromJS(resultData200);
            return Promise.resolve<TimeSeriesBufferDto>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            return throwException("No Content", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets timeseries summaries
     * @param body (optional) 
     * @return Success
     */
    getTimeSeriesSummaries(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<TimeSeriesDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Timeseries/get-timeseries-summaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeSeriesSummaries(_response);
        });
    }

    protected processGetTimeSeriesSummaries(response: AxiosResponse): Promise<TimeSeriesDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeSeriesDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<TimeSeriesDtoBatchDto>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports timeseries summaries
     * @param body (optional) 
     */
    exportTimeSeriesSummaries(body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Timeseries/export-timeseries-summaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTimeSeriesSummaries(_response);
        });
    }

    protected processExportTimeSeriesSummaries(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get twins by model
     * @param modelId (optional) The id of the model beginning dtmi:
     * @param body (optional) The filter/sorting detaiuls for the result
     * @return Success
     */
    twinsByModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<TwinDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Twin/TwinsByModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsByModel(_response);
        });
    }

    protected processTwinsByModel(response: AxiosResponse): Promise<TwinDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<TwinDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports the twins by model
     * @param modelId (optional) 
     * @param body (optional) 
     */
    exportTwinsByModel(modelId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Twin/ExportTwinsByModel?";
        if (modelId === null)
            throw new Error("The parameter 'modelId' cannot be null.");
        else if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTwinsByModel(_response);
        });
    }

    protected processExportTwinsByModel(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Gets subgraphs around each specified node in the list
     * @param body (optional) An array of ids to find, usually current, previous, previous to that
     * @return Success
     */
    twinsGraph(body: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<TwinGraphDto> {
        let url_ = this.baseUrl + "/api/Twin/TwinsGraph";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsGraph(_response);
        });
    }

    protected processTwinsGraph(response: AxiosResponse): Promise<TwinGraphDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinGraphDto.fromJS(resultData200);
            return Promise.resolve<TwinGraphDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a twin and related information (using the old cached twin approach)
     * @param equipmentId (optional) 
     * @return Success
     */
    equipmentWithRelationships(equipmentId: string | undefined , cancelToken?: CancelToken | undefined): Promise<EquipmentDto> {
        let url_ = this.baseUrl + "/api/Twin/EquipmentWithRelationships?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEquipmentWithRelationships(_response);
        });
    }

    protected processEquipmentWithRelationships(response: AxiosResponse): Promise<EquipmentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EquipmentDto.fromJS(resultData200);
            return Promise.resolve<EquipmentDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets rule instances for a twin
     * @param twinId (optional) 
     * @param body (optional) A filter for the result
     * @return Success
     */
    equipmentRuleInstances(twinId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleInstanceDtoBatchDto> {
        let url_ = this.baseUrl + "/api/Twin/EquipmentRuleInstances?";
        if (twinId === null)
            throw new Error("The parameter 'twinId' cannot be null.");
        else if (twinId !== undefined)
            url_ += "twinId=" + encodeURIComponent("" + twinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEquipmentRuleInstances(_response);
        });
    }

    protected processEquipmentRuleInstances(response: AxiosResponse): Promise<RuleInstanceDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleInstanceDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<RuleInstanceDtoBatchDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get the insights count per twin for a given graph
     * @param body (optional) 
     * @return Success
     */
    getInsightsCountForTwinGraph(body: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<TwinInsightsCountDto[]> {
        let url_ = this.baseUrl + "/api/Twin/GetInsightsCountForTwinGraph";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInsightsCountForTwinGraph(_response);
        });
    }

    protected processGetInsightsCountForTwinGraph(response: AxiosResponse): Promise<TwinInsightsCountDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TwinInsightsCountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TwinInsightsCountDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Exports rule instances for a twin
     * @param twinId (optional) 
     * @param body (optional) 
     */
    exportEquipmentRuleInstances(twinId: string | undefined, body: BatchRequestDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Twin/ExportEquipmentRuleInstances?";
        if (twinId === null)
            throw new Error("The parameter 'twinId' cannot be null.");
        else if (twinId !== undefined)
            url_ += "twinId=" + encodeURIComponent("" + twinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/csv"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportEquipmentRuleInstances(_response);
        });
    }

    protected processExportEquipmentRuleInstances(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Gets a user
     * @param id Id for the user
     * @return Success
     */
    getUserInfo(id: string , cancelToken?: CancelToken | undefined): Promise<AuthenticatedUserAndPolicyDecisionsDto> {
        let url_ = this.baseUrl + "/api/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: AxiosResponse): Promise<AuthenticatedUserAndPolicyDecisionsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticatedUserAndPolicyDecisionsDto.fromJS(resultData200);
            return Promise.resolve<AuthenticatedUserAndPolicyDecisionsDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else {
            const _responseText = response.data;
            return throwException("Error", status, _responseText, _headers);

        }
    }
}

export enum ADTActionRequired {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ADTActionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

/** Model summary */
export class ADTModelSummary implements IADTModelSummary {
    /** The full path property name */
    modelId?: string | undefined;
    /** Total Properties used in ADT */
    propertiesUsed?: { [key: string]: number; } | undefined;
    /** Total Properties declared in ADT */
    propertiesDelared?: { [key: string]: number; } | undefined;

    constructor(data?: IADTModelSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelId = _data["modelId"];
            if (_data["propertiesUsed"]) {
                this.propertiesUsed = {} as any;
                for (let key in _data["propertiesUsed"]) {
                    if (_data["propertiesUsed"].hasOwnProperty(key))
                        (<any>this.propertiesUsed)![key] = _data["propertiesUsed"][key];
                }
            }
            if (_data["propertiesDelared"]) {
                this.propertiesDelared = {} as any;
                for (let key in _data["propertiesDelared"]) {
                    if (_data["propertiesDelared"].hasOwnProperty(key))
                        (<any>this.propertiesDelared)![key] = _data["propertiesDelared"][key];
                }
            }
        }
    }

    static fromJS(data: any): ADTModelSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ADTModelSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        if (this.propertiesUsed) {
            data["propertiesUsed"] = {};
            for (let key in this.propertiesUsed) {
                if (this.propertiesUsed.hasOwnProperty(key))
                    (<any>data["propertiesUsed"])[key] = (<any>this.propertiesUsed)[key];
            }
        }
        if (this.propertiesDelared) {
            data["propertiesDelared"] = {};
            for (let key in this.propertiesDelared) {
                if (this.propertiesDelared.hasOwnProperty(key))
                    (<any>data["propertiesDelared"])[key] = (<any>this.propertiesDelared)[key];
            }
        }
        return data;
    }
}

/** Model summary */
export interface IADTModelSummary {
    /** The full path property name */
    modelId?: string | undefined;
    /** Total Properties used in ADT */
    propertiesUsed?: { [key: string]: number; } | undefined;
    /** Total Properties declared in ADT */
    propertiesDelared?: { [key: string]: number; } | undefined;
}

/** Information about the state of ADT */
export class ADTSummaryDto implements IADTSummaryDto {
    /** The Id for persistence */
    id?: string | undefined;
    /** When the record was created */
    asOfDate?: moment.Moment;
    /** The customer environment */
    customerEnvironmentId?: string | undefined;
    /** The ADT instance */
    adtInstanceId?: string | undefined;
    /** How many twins */
    countTwins?: number;
    /** How many twins with trend Ids */
    countCapabilities?: number;
    /** How many relationships */
    countRelationships?: number;
    /** Count of twins with no relationships */
    countTwinsNotInGraph?: number;
    /** Count of models */
    countModels?: number;
    /** Count of models in use in twin */
    countModelsInUse?: number;

    constructor(data?: IADTSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.asOfDate = _data["asOfDate"] ? moment.parseZone(_data["asOfDate"].toString()) : <any>undefined;
            this.customerEnvironmentId = _data["customerEnvironmentId"];
            this.adtInstanceId = _data["adtInstanceId"];
            this.countTwins = _data["countTwins"];
            this.countCapabilities = _data["countCapabilities"];
            this.countRelationships = _data["countRelationships"];
            this.countTwinsNotInGraph = _data["countTwinsNotInGraph"];
            this.countModels = _data["countModels"];
            this.countModelsInUse = _data["countModelsInUse"];
        }
    }

    static fromJS(data: any): ADTSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ADTSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["asOfDate"] = this.asOfDate ? this.asOfDate.toISOString(true) : <any>undefined;
        data["customerEnvironmentId"] = this.customerEnvironmentId;
        data["adtInstanceId"] = this.adtInstanceId;
        data["countTwins"] = this.countTwins;
        data["countCapabilities"] = this.countCapabilities;
        data["countRelationships"] = this.countRelationships;
        data["countTwinsNotInGraph"] = this.countTwinsNotInGraph;
        data["countModels"] = this.countModels;
        data["countModelsInUse"] = this.countModelsInUse;
        return data;
    }
}

/** Information about the state of ADT */
export interface IADTSummaryDto {
    /** The Id for persistence */
    id?: string | undefined;
    /** When the record was created */
    asOfDate?: moment.Moment;
    /** The customer environment */
    customerEnvironmentId?: string | undefined;
    /** The ADT instance */
    adtInstanceId?: string | undefined;
    /** How many twins */
    countTwins?: number;
    /** How many twins with trend Ids */
    countCapabilities?: number;
    /** How many relationships */
    countRelationships?: number;
    /** Count of twins with no relationships */
    countTwinsNotInGraph?: number;
    /** Count of models */
    countModels?: number;
    /** Count of models in use in twin */
    countModelsInUse?: number;
}

/** Progress records for the admin page */
export class AdminProgressDto implements IAdminProgressDto {
    /** When the progress Dto was created */
    readonly now?: moment.Moment;
    /** The progress records from the database */
    progresses?: ProgressDto[] | undefined;

    constructor(data?: IAdminProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).now = _data["now"] ? moment.parseZone(_data["now"].toString()) : <any>undefined;
            if (Array.isArray(_data["progresses"])) {
                this.progresses = [] as any;
                for (let item of _data["progresses"])
                    this.progresses!.push(ProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["now"] = this.now ? this.now.toISOString(true) : <any>undefined;
        if (Array.isArray(this.progresses)) {
            data["progresses"] = [];
            for (let item of this.progresses)
                data["progresses"].push(item.toJSON());
        }
        return data;
    }
}

/** Progress records for the admin page */
export interface IAdminProgressDto {
    /** When the progress Dto was created */
    now?: moment.Moment;
    /** The progress records from the database */
    progresses?: ProgressDto[] | undefined;
}

/** Audit Log entry for rule metadata */
export class AuditLogEntryDto implements IAuditLogEntryDto {
    /** Date of log entry */
    date?: moment.Moment;
    /** Message for log */
    message?: string | undefined;
    /** Which user the log is for */
    user?: string | undefined;

    constructor(data?: IAuditLogEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment.parseZone(_data["date"].toString()) : <any>undefined;
            this.message = _data["message"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): AuditLogEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString(true) : <any>undefined;
        data["message"] = this.message;
        data["user"] = this.user;
        return data;
    }
}

/** Audit Log entry for rule metadata */
export interface IAuditLogEntryDto {
    /** Date of log entry */
    date?: moment.Moment;
    /** Message for log */
    message?: string | undefined;
    /** Which user the log is for */
    user?: string | undefined;
}

/** An authenticated user, groups and the policy decisions */
export class AuthenticatedUserAndPolicyDecisionsDto implements IAuthenticatedUserAndPolicyDecisionsDto {
    user?: AuthenticatedUserDto;
    /** Policy decisions */
    policyDecisions?: { [key: string]: DecisionDto; } | undefined;

    constructor(data?: IAuthenticatedUserAndPolicyDecisionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? AuthenticatedUserDto.fromJS(_data["user"]) : <any>undefined;
            if (_data["policyDecisions"]) {
                this.policyDecisions = {} as any;
                for (let key in _data["policyDecisions"]) {
                    if (_data["policyDecisions"].hasOwnProperty(key))
                        (<any>this.policyDecisions)![key] = _data["policyDecisions"][key] ? DecisionDto.fromJS(_data["policyDecisions"][key]) : new DecisionDto();
                }
            }
        }
    }

    static fromJS(data: any): AuthenticatedUserAndPolicyDecisionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedUserAndPolicyDecisionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.policyDecisions) {
            data["policyDecisions"] = {};
            for (let key in this.policyDecisions) {
                if (this.policyDecisions.hasOwnProperty(key))
                    (<any>data["policyDecisions"])[key] = this.policyDecisions[key] ? this.policyDecisions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** An authenticated user, groups and the policy decisions */
export interface IAuthenticatedUserAndPolicyDecisionsDto {
    user?: AuthenticatedUserDto;
    /** Policy decisions */
    policyDecisions?: { [key: string]: DecisionDto; } | undefined;
}

/** Information about the logged in user */
export class AuthenticatedUserDto implements IAuthenticatedUserDto {
    /** Display name for this user */
    displayName?: string | undefined;
    /** User id */
    id?: string | undefined;
    /** Email */
    email?: string | undefined;

    constructor(data?: IAuthenticatedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.id = _data["id"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): AuthenticatedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["email"] = this.email;
        return data;
    }
}

/** Information about the logged in user */
export interface IAuthenticatedUserDto {
    /** Display name for this user */
    displayName?: string | undefined;
    /** User id */
    id?: string | undefined;
    /** Email */
    email?: string | undefined;
}

/** An axis */
export class AxisDto implements IAxisDto {
    /** Group key, all trends with same key share an axis (normally unit) */
    key?: string | undefined;
    /** Short name like y2 */
    shortName?: string | undefined;
    /** Long name like yaxis2 */
    longName?: string | undefined;
    /** Title */
    title?: string | undefined;

    constructor(data?: IAxisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.shortName = _data["shortName"];
            this.longName = _data["longName"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): AxisDto {
        data = typeof data === 'object' ? data : {};
        let result = new AxisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["shortName"] = this.shortName;
        data["longName"] = this.longName;
        data["title"] = this.title;
        return data;
    }
}

/** An axis */
export interface IAxisDto {
    /** Group key, all trends with same key share an axis (normally unit) */
    key?: string | undefined;
    /** Short name like y2 */
    shortName?: string | undefined;
    /** Long name like yaxis2 */
    longName?: string | undefined;
    /** Title */
    title?: string | undefined;
}

/** Simplified graph to hand back to UI standardised for filtering and sorting of Nodes */
export class BatchDtoModelSimpleGraphDto implements IBatchDtoModelSimpleGraphDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: ModelSimpleDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** Edges */
    relationships?: ModelSimpleRelationshipDto[] | undefined;

    constructor(data?: IBatchDtoModelSimpleGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModelSimpleDto.fromJS(item));
            }
            this.next = _data["next"];
            if (Array.isArray(_data["relationships"])) {
                this.relationships = [] as any;
                for (let item of _data["relationships"])
                    this.relationships!.push(ModelSimpleRelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BatchDtoModelSimpleGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchDtoModelSimpleGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        if (Array.isArray(this.relationships)) {
            data["relationships"] = [];
            for (let item of this.relationships)
                data["relationships"].push(item.toJSON());
        }
        return data;
    }
}

/** Simplified graph to hand back to UI standardised for filtering and sorting of Nodes */
export interface IBatchDtoModelSimpleGraphDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: ModelSimpleDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** Edges */
    relationships?: ModelSimpleRelationshipDto[] | undefined;
}

/** A batch request */
export class BatchRequestDto implements IBatchRequestDto {
    /** Specifications on how to sort the batch */
    sortSpecifications?: SortSpecificationDto[] | undefined;
    /** Specification on how to filter the batch */
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    /** The page number to return for the batch (one-based) */
    page?: number | undefined;
    /** The amount of items in the batch */
    pageSize?: number | undefined;

    constructor(data?: IBatchRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): BatchRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

/** A batch request */
export interface IBatchRequestDto {
    /** Specifications on how to sort the batch */
    sortSpecifications?: SortSpecificationDto[] | undefined;
    /** Specification on how to filter the batch */
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    /** The page number to return for the batch (one-based) */
    page?: number | undefined;
    /** The amount of items in the batch */
    pageSize?: number | undefined;
}

/** Dto for Willow.Rules.Model.CalculatedPoint and Willow.Rules.Model.RuleInstance */
export class CalculatedPointDto implements ICalculatedPointDto {
    /** Id of the calculated point, the calculated point instance and the instance metadata */
    readonly id?: string | undefined;
    /** Name of the calculated point */
    readonly name?: string | undefined;
    /** A description of the calculated point */
    readonly description?: string | undefined;
    /** The expression */
    readonly valueExpression?: string | undefined;
    /** The OUTPUT trend id */
    readonly trendId?: string | undefined;
    /** Did the expression parse and were the points found? */
    readonly valid?: boolean;
    /** The guids that trigger this instance */
    readonly pointEntityIds?: NamedPointDto[] | undefined;
    /** Rule parameter bound */
    readonly ruleParametersBound?: RuleParameterBoundDto[] | undefined;
    /** Actor output values */
    readonly outputValues?: OutputValueDto[] | undefined;
    /** Last time a time series value was received for this calculated point */
    readonly lastTriggered?: moment.Moment;
    /** Count of how many times this calculated point has been triggered */
    readonly triggerCount?: number;
    /** Unit of measure */
    readonly unit?: string | undefined;
    /** Model of the calculated point, usually a Sensor dervived class */
    readonly modelId?: string | undefined;
    /** The model ID the PrimaryModelId is related to */
    readonly isCapabilityOf?: string | undefined;
    /** Calculated Point Twin ID (Same as Id) */
    readonly externalId?: string | undefined;
    /** Rules Engine connectorId */
    readonly connectorId?: string | undefined;
    /** The rule the Calculated Point was created from */
    readonly ruleId?: string | undefined;
    /** Calculated = Min(TrendInterval of referenced capabilities) - guaranteed trend interval. */
    readonly trendInterval?: number;
    /** Timezone for the primary equipment in the rule instance */
    readonly timeZone?: string | undefined;
    /** The legacy site ID needed on created capabilities (Requirement in Command to be displayed on Time Series) */
    readonly siteId?: string | undefined;
    type?: UnitOutputType;
    source?: CalculatedPointSource;
    actionRequired?: ADTActionRequired;
    actionStatus?: ADTActionStatus;
    /** Last date syned with ADT */
    lastSyncDateUTC?: moment.Moment | undefined;
    /** Parent chain by locatedIn and isPartOf */
    twinLocations?: TwinLocation[] | undefined;

    constructor(data?: ICalculatedPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).description = _data["description"];
            (<any>this).valueExpression = _data["valueExpression"];
            (<any>this).trendId = _data["trendId"];
            (<any>this).valid = _data["valid"];
            if (Array.isArray(_data["pointEntityIds"])) {
                (<any>this).pointEntityIds = [] as any;
                for (let item of _data["pointEntityIds"])
                    (<any>this).pointEntityIds!.push(NamedPointDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleParametersBound"])) {
                (<any>this).ruleParametersBound = [] as any;
                for (let item of _data["ruleParametersBound"])
                    (<any>this).ruleParametersBound!.push(RuleParameterBoundDto.fromJS(item));
            }
            if (Array.isArray(_data["outputValues"])) {
                (<any>this).outputValues = [] as any;
                for (let item of _data["outputValues"])
                    (<any>this).outputValues!.push(OutputValueDto.fromJS(item));
            }
            (<any>this).lastTriggered = _data["lastTriggered"] ? moment.parseZone(_data["lastTriggered"].toString()) : <any>undefined;
            (<any>this).triggerCount = _data["triggerCount"];
            (<any>this).unit = _data["unit"];
            (<any>this).modelId = _data["modelId"];
            (<any>this).isCapabilityOf = _data["isCapabilityOf"];
            (<any>this).externalId = _data["externalId"];
            (<any>this).connectorId = _data["connectorId"];
            (<any>this).ruleId = _data["ruleId"];
            (<any>this).trendInterval = _data["trendInterval"];
            (<any>this).timeZone = _data["timeZone"];
            (<any>this).siteId = _data["siteId"];
            this.type = _data["type"];
            this.source = _data["source"];
            this.actionRequired = _data["actionRequired"];
            this.actionStatus = _data["actionStatus"];
            this.lastSyncDateUTC = _data["lastSyncDateUTC"] ? moment.parseZone(_data["lastSyncDateUTC"].toString()) : <any>undefined;
            if (Array.isArray(_data["twinLocations"])) {
                this.twinLocations = [] as any;
                for (let item of _data["twinLocations"])
                    this.twinLocations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalculatedPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatedPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["valueExpression"] = this.valueExpression;
        data["trendId"] = this.trendId;
        data["valid"] = this.valid;
        if (Array.isArray(this.pointEntityIds)) {
            data["pointEntityIds"] = [];
            for (let item of this.pointEntityIds)
                data["pointEntityIds"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleParametersBound)) {
            data["ruleParametersBound"] = [];
            for (let item of this.ruleParametersBound)
                data["ruleParametersBound"].push(item.toJSON());
        }
        if (Array.isArray(this.outputValues)) {
            data["outputValues"] = [];
            for (let item of this.outputValues)
                data["outputValues"].push(item.toJSON());
        }
        data["lastTriggered"] = this.lastTriggered ? this.lastTriggered.toISOString(true) : <any>undefined;
        data["triggerCount"] = this.triggerCount;
        data["unit"] = this.unit;
        data["modelId"] = this.modelId;
        data["isCapabilityOf"] = this.isCapabilityOf;
        data["externalId"] = this.externalId;
        data["connectorId"] = this.connectorId;
        data["ruleId"] = this.ruleId;
        data["trendInterval"] = this.trendInterval;
        data["timeZone"] = this.timeZone;
        data["siteId"] = this.siteId;
        data["type"] = this.type;
        data["source"] = this.source;
        data["actionRequired"] = this.actionRequired;
        data["actionStatus"] = this.actionStatus;
        data["lastSyncDateUTC"] = this.lastSyncDateUTC ? this.lastSyncDateUTC.toISOString(true) : <any>undefined;
        if (Array.isArray(this.twinLocations)) {
            data["twinLocations"] = [];
            for (let item of this.twinLocations)
                data["twinLocations"].push(item.toJSON());
        }
        return data;
    }
}

/** Dto for Willow.Rules.Model.CalculatedPoint and Willow.Rules.Model.RuleInstance */
export interface ICalculatedPointDto {
    /** Id of the calculated point, the calculated point instance and the instance metadata */
    id?: string | undefined;
    /** Name of the calculated point */
    name?: string | undefined;
    /** A description of the calculated point */
    description?: string | undefined;
    /** The expression */
    valueExpression?: string | undefined;
    /** The OUTPUT trend id */
    trendId?: string | undefined;
    /** Did the expression parse and were the points found? */
    valid?: boolean;
    /** The guids that trigger this instance */
    pointEntityIds?: NamedPointDto[] | undefined;
    /** Rule parameter bound */
    ruleParametersBound?: RuleParameterBoundDto[] | undefined;
    /** Actor output values */
    outputValues?: OutputValueDto[] | undefined;
    /** Last time a time series value was received for this calculated point */
    lastTriggered?: moment.Moment;
    /** Count of how many times this calculated point has been triggered */
    triggerCount?: number;
    /** Unit of measure */
    unit?: string | undefined;
    /** Model of the calculated point, usually a Sensor dervived class */
    modelId?: string | undefined;
    /** The model ID the PrimaryModelId is related to */
    isCapabilityOf?: string | undefined;
    /** Calculated Point Twin ID (Same as Id) */
    externalId?: string | undefined;
    /** Rules Engine connectorId */
    connectorId?: string | undefined;
    /** The rule the Calculated Point was created from */
    ruleId?: string | undefined;
    /** Calculated = Min(TrendInterval of referenced capabilities) - guaranteed trend interval. */
    trendInterval?: number;
    /** Timezone for the primary equipment in the rule instance */
    timeZone?: string | undefined;
    /** The legacy site ID needed on created capabilities (Requirement in Command to be displayed on Time Series) */
    siteId?: string | undefined;
    type?: UnitOutputType;
    source?: CalculatedPointSource;
    actionRequired?: ADTActionRequired;
    actionStatus?: ADTActionStatus;
    /** Last date syned with ADT */
    lastSyncDateUTC?: moment.Moment | undefined;
    /** Parent chain by locatedIn and isPartOf */
    twinLocations?: TwinLocation[] | undefined;
}

/** A batched result */
export class CalculatedPointDtoBatchDto implements ICalculatedPointDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: CalculatedPointDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: ICalculatedPointDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CalculatedPointDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): CalculatedPointDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalculatedPointDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface ICalculatedPointDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: CalculatedPointDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

export enum CalculatedPointSource {
    _0 = 0,
    _1 = 1,
}

/** Capability entity */
export class CapabilityDto implements ICapabilityDto {
    /** Id of the twin */
    id?: string | undefined;
    /** Name of the twin */
    name?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Relationship */
    relationship?: string | undefined;
    /** Substance */
    substance?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;
    /** Haystack tags */
    tags?: string | undefined;

    constructor(data?: ICapabilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
            this.relationship = _data["relationship"];
            this.substance = _data["substance"];
            this.unit = _data["unit"];
            this.tags = _data["tags"];
        }
    }

    static fromJS(data: any): CapabilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CapabilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        data["relationship"] = this.relationship;
        data["substance"] = this.substance;
        data["unit"] = this.unit;
        data["tags"] = this.tags;
        return data;
    }
}

/** Capability entity */
export interface ICapabilityDto {
    /** Id of the twin */
    id?: string | undefined;
    /** Name of the twin */
    name?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Relationship */
    relationship?: string | undefined;
    /** Substance */
    substance?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;
    /** Haystack tags */
    tags?: string | undefined;
}

/** Dto for Willow.Rules.Model.Command */
export class CommandDto implements ICommandDto {
    /** Unique Id of the command */
    readonly id?: string | undefined;
    /** The ID for the Command */
    commandId?: string | undefined;
    /** Name of the command */
    readonly commandName?: string | undefined;
    commandType?: CommandType;
    /** The timezone for the rule instance */
    timeZone?: string | undefined;
    /** The model id of the primary equipment item */
    primaryModelId?: string | undefined;
    /** The external id of the twin */
    externalId?: string | undefined;
    /** The connector id of the twin */
    connectorId?: string | undefined;
    /** The Twin Id for which the command is executed */
    twinId?: string | undefined;
    /** The Twin Name for which the command is executed */
    twinName?: string | undefined;
    /** The equipment name related to this Command */
    equipmentName?: string | undefined;
    /** The equipment id related to this Command */
    equipmentId?: string | undefined;
    /** Units of the value */
    readonly unit?: string | undefined;
    /** The rule that created this command */
    ruleId?: string | undefined;
    /** The rule instance id that created this command */
    ruleInstanceId?: string | undefined;
    /** The rule that created this command */
    ruleName?: string | undefined;
    /** Indicates whether the command is currently triggered */
    isTriggered?: boolean;
    /** The current value for the command */
    value?: number;
    /** The start time for the command */
    startTime?: moment.Moment | undefined;
    /** An optinal end time for the command */
    endTime?: moment.Moment | undefined;
    /** A UTC timestamp that audits the last sync date to command */
    lastSyncDate?: moment.Moment | undefined;
    /** Occurrences */
    occurrences?: CommandOccurrenceDto[] | undefined;
    /** Indicates whether the command is enabled to sync */
    enabled?: boolean;
    /** Indicates whether the command is currently valid */
    isValid?: boolean;
    /** Additional twin relationship information sent to command */
    relationships?: RuleTriggerBoundRelationshipDto[] | undefined;

    constructor(data?: ICommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.commandId = _data["commandId"];
            (<any>this).commandName = _data["commandName"];
            this.commandType = _data["commandType"];
            this.timeZone = _data["timeZone"];
            this.primaryModelId = _data["primaryModelId"];
            this.externalId = _data["externalId"];
            this.connectorId = _data["connectorId"];
            this.twinId = _data["twinId"];
            this.twinName = _data["twinName"];
            this.equipmentName = _data["equipmentName"];
            this.equipmentId = _data["equipmentId"];
            (<any>this).unit = _data["unit"];
            this.ruleId = _data["ruleId"];
            this.ruleInstanceId = _data["ruleInstanceId"];
            this.ruleName = _data["ruleName"];
            this.isTriggered = _data["isTriggered"];
            this.value = _data["value"];
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment.parseZone(_data["endTime"].toString()) : <any>undefined;
            this.lastSyncDate = _data["lastSyncDate"] ? moment.parseZone(_data["lastSyncDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["occurrences"])) {
                this.occurrences = [] as any;
                for (let item of _data["occurrences"])
                    this.occurrences!.push(CommandOccurrenceDto.fromJS(item));
            }
            this.enabled = _data["enabled"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["relationships"])) {
                this.relationships = [] as any;
                for (let item of _data["relationships"])
                    this.relationships!.push(RuleTriggerBoundRelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commandId"] = this.commandId;
        data["commandName"] = this.commandName;
        data["commandType"] = this.commandType;
        data["timeZone"] = this.timeZone;
        data["primaryModelId"] = this.primaryModelId;
        data["externalId"] = this.externalId;
        data["connectorId"] = this.connectorId;
        data["twinId"] = this.twinId;
        data["twinName"] = this.twinName;
        data["equipmentName"] = this.equipmentName;
        data["equipmentId"] = this.equipmentId;
        data["unit"] = this.unit;
        data["ruleId"] = this.ruleId;
        data["ruleInstanceId"] = this.ruleInstanceId;
        data["ruleName"] = this.ruleName;
        data["isTriggered"] = this.isTriggered;
        data["value"] = this.value;
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString(true) : <any>undefined;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString(true) : <any>undefined;
        if (Array.isArray(this.occurrences)) {
            data["occurrences"] = [];
            for (let item of this.occurrences)
                data["occurrences"].push(item.toJSON());
        }
        data["enabled"] = this.enabled;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.relationships)) {
            data["relationships"] = [];
            for (let item of this.relationships)
                data["relationships"].push(item.toJSON());
        }
        return data;
    }
}

/** Dto for Willow.Rules.Model.Command */
export interface ICommandDto {
    /** Unique Id of the command */
    id?: string | undefined;
    /** The ID for the Command */
    commandId?: string | undefined;
    /** Name of the command */
    commandName?: string | undefined;
    commandType?: CommandType;
    /** The timezone for the rule instance */
    timeZone?: string | undefined;
    /** The model id of the primary equipment item */
    primaryModelId?: string | undefined;
    /** The external id of the twin */
    externalId?: string | undefined;
    /** The connector id of the twin */
    connectorId?: string | undefined;
    /** The Twin Id for which the command is executed */
    twinId?: string | undefined;
    /** The Twin Name for which the command is executed */
    twinName?: string | undefined;
    /** The equipment name related to this Command */
    equipmentName?: string | undefined;
    /** The equipment id related to this Command */
    equipmentId?: string | undefined;
    /** Units of the value */
    unit?: string | undefined;
    /** The rule that created this command */
    ruleId?: string | undefined;
    /** The rule instance id that created this command */
    ruleInstanceId?: string | undefined;
    /** The rule that created this command */
    ruleName?: string | undefined;
    /** Indicates whether the command is currently triggered */
    isTriggered?: boolean;
    /** The current value for the command */
    value?: number;
    /** The start time for the command */
    startTime?: moment.Moment | undefined;
    /** An optinal end time for the command */
    endTime?: moment.Moment | undefined;
    /** A UTC timestamp that audits the last sync date to command */
    lastSyncDate?: moment.Moment | undefined;
    /** Occurrences */
    occurrences?: CommandOccurrenceDto[] | undefined;
    /** Indicates whether the command is enabled to sync */
    enabled?: boolean;
    /** Indicates whether the command is currently valid */
    isValid?: boolean;
    /** Additional twin relationship information sent to command */
    relationships?: RuleTriggerBoundRelationshipDto[] | undefined;
}

/** A batched result */
export class CommandDtoBatchDto implements ICommandDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: CommandDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: ICommandDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommandDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): CommandDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface ICommandDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: CommandDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

/** An occurrence of the same insight at a different time */
export class CommandOccurrenceDto implements ICommandOccurrenceDto {
    /** Is this an interval triggerred to send to command? */
    isTriggered?: boolean;
    /** The value to set the trigger wtih */
    value?: number;
    /** Start of the occurrence */
    started?: moment.Moment;
    /** The end of the occurrence */
    ended?: moment.Moment;
    /** Start time for the command */
    triggerStartTime?: moment.Moment;
    /** End time for the command */
    triggerEndTime?: moment.Moment | undefined;

    constructor(data?: ICommandOccurrenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTriggered = _data["isTriggered"];
            this.value = _data["value"];
            this.started = _data["started"] ? moment.parseZone(_data["started"].toString()) : <any>undefined;
            this.ended = _data["ended"] ? moment.parseZone(_data["ended"].toString()) : <any>undefined;
            this.triggerStartTime = _data["triggerStartTime"] ? moment.parseZone(_data["triggerStartTime"].toString()) : <any>undefined;
            this.triggerEndTime = _data["triggerEndTime"] ? moment.parseZone(_data["triggerEndTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CommandOccurrenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandOccurrenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTriggered"] = this.isTriggered;
        data["value"] = this.value;
        data["started"] = this.started ? this.started.toISOString(true) : <any>undefined;
        data["ended"] = this.ended ? this.ended.toISOString(true) : <any>undefined;
        data["triggerStartTime"] = this.triggerStartTime ? this.triggerStartTime.toISOString(true) : <any>undefined;
        data["triggerEndTime"] = this.triggerEndTime ? this.triggerEndTime.toISOString(true) : <any>undefined;
        return data;
    }
}

/** An occurrence of the same insight at a different time */
export interface ICommandOccurrenceDto {
    /** Is this an interval triggerred to send to command? */
    isTriggered?: boolean;
    /** The value to set the trigger wtih */
    value?: number;
    /** Start of the occurrence */
    started?: moment.Moment;
    /** The end of the occurrence */
    ended?: moment.Moment;
    /** Start time for the command */
    triggerStartTime?: moment.Moment;
    /** End time for the command */
    triggerEndTime?: moment.Moment | undefined;
}

export enum CommandType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CumulativeType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

/** A policy decision */
export class DecisionDto implements IDecisionDto {
    /** Success or fail */
    success?: boolean;
    /** The reason for a failure */
    reason?: string | undefined;

    constructor(data?: IDecisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): DecisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DecisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["reason"] = this.reason;
        return data;
    }
}

/** A policy decision */
export interface IDecisionDto {
    /** Success or fail */
    success?: boolean;
    /** The reason for a failure */
    reason?: string | undefined;
}

/** Environment for website */
export class EnvironmentDto implements IEnvironmentDto {
    /** Redirect url */
    readonly redirect?: string | undefined;
    /** Environment Id */
    readonly environmentId?: string | undefined;
    /** Environment name */
    readonly environmentName?: string | undefined;

    constructor(data?: IEnvironmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).redirect = _data["redirect"];
            (<any>this).environmentId = _data["environmentId"];
            (<any>this).environmentName = _data["environmentName"];
        }
    }

    static fromJS(data: any): EnvironmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirect"] = this.redirect;
        data["environmentId"] = this.environmentId;
        data["environmentName"] = this.environmentName;
        return data;
    }
}

/** Environment for website */
export interface IEnvironmentDto {
    /** Redirect url */
    redirect?: string | undefined;
    /** Environment Id */
    environmentId?: string | undefined;
    /** Environment name */
    environmentName?: string | undefined;
}

/** Equipment item and associated rule instances */
export class EquipmentDto implements IEquipmentDto {
    /** Id for the equipment, currently just the one */
    equipmentId?: string | undefined;
    /** ModelId for the equipment, currently just the one */
    modelId?: string | undefined;
    /** Name of the equipment */
    name?: string | undefined;
    /** Description of the equipment */
    description?: string | undefined;
    /** Related entities up */
    relatedEntities?: RelatedEntityDto[] | undefined;
    /** Related entities down */
    inverseRelatedEntities?: RelatedEntityDto[] | undefined;
    /** Capabilities */
    capabilities?: CapabilityDto[] | undefined;
    /** Tags */
    tags?: string | undefined;
    /** Unit of measure (for capabilities) */
    unit?: string | undefined;
    /** Interval that we expect this trend to follow (in seconds) */
    trendInterval?: number | undefined;
    /** Value Expression */
    valueExpression?: string | undefined;
    /** Legacy Guid (as string) siteId */
    siteId?: string | undefined;
    /** Legacy Guid equipment unique id */
    equipmentUniqueId?: string | undefined;
    /** External Id used in some time series values */
    externalId?: string | undefined;
    /** Connector Id used in some time series values */
    connectorId?: string | undefined;
    /** Trend Id used in some time series values */
    trendId?: string | undefined;
    /** Timezone */
    timezone?: string | undefined;
    /** Equipment is calculated point */
    isCalculatedPointTwin?: boolean;
    capabilityStatus?: TimeSeriesStatus;
    /** Additional properties */
    contents?: { [key: string]: any; } | undefined;
    /** The date and time the twin was last updated in cache */
    lastUpdatedOn?: moment.Moment | undefined;
    /** Model properties */
    properties?: ModelPropertyDto[] | undefined;
    /** Ascendant locations */
    locations?: TwinLocation[] | undefined;

    constructor(data?: IEquipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.modelId = _data["modelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["relatedEntities"])) {
                this.relatedEntities = [] as any;
                for (let item of _data["relatedEntities"])
                    this.relatedEntities!.push(RelatedEntityDto.fromJS(item));
            }
            if (Array.isArray(_data["inverseRelatedEntities"])) {
                this.inverseRelatedEntities = [] as any;
                for (let item of _data["inverseRelatedEntities"])
                    this.inverseRelatedEntities!.push(RelatedEntityDto.fromJS(item));
            }
            if (Array.isArray(_data["capabilities"])) {
                this.capabilities = [] as any;
                for (let item of _data["capabilities"])
                    this.capabilities!.push(CapabilityDto.fromJS(item));
            }
            this.tags = _data["tags"];
            this.unit = _data["unit"];
            this.trendInterval = _data["trendInterval"];
            this.valueExpression = _data["valueExpression"];
            this.siteId = _data["siteId"];
            this.equipmentUniqueId = _data["equipmentUniqueId"];
            this.externalId = _data["externalId"];
            this.connectorId = _data["connectorId"];
            this.trendId = _data["trendId"];
            this.timezone = _data["timezone"];
            this.isCalculatedPointTwin = _data["isCalculatedPointTwin"];
            this.capabilityStatus = _data["capabilityStatus"];
            if (_data["contents"]) {
                this.contents = {} as any;
                for (let key in _data["contents"]) {
                    if (_data["contents"].hasOwnProperty(key))
                        (<any>this.contents)![key] = _data["contents"][key];
                }
            }
            this.lastUpdatedOn = _data["lastUpdatedOn"] ? moment.parseZone(_data["lastUpdatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ModelPropertyDto.fromJS(item));
            }
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EquipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["modelId"] = this.modelId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.relatedEntities)) {
            data["relatedEntities"] = [];
            for (let item of this.relatedEntities)
                data["relatedEntities"].push(item.toJSON());
        }
        if (Array.isArray(this.inverseRelatedEntities)) {
            data["inverseRelatedEntities"] = [];
            for (let item of this.inverseRelatedEntities)
                data["inverseRelatedEntities"].push(item.toJSON());
        }
        if (Array.isArray(this.capabilities)) {
            data["capabilities"] = [];
            for (let item of this.capabilities)
                data["capabilities"].push(item.toJSON());
        }
        data["tags"] = this.tags;
        data["unit"] = this.unit;
        data["trendInterval"] = this.trendInterval;
        data["valueExpression"] = this.valueExpression;
        data["siteId"] = this.siteId;
        data["equipmentUniqueId"] = this.equipmentUniqueId;
        data["externalId"] = this.externalId;
        data["connectorId"] = this.connectorId;
        data["trendId"] = this.trendId;
        data["timezone"] = this.timezone;
        data["isCalculatedPointTwin"] = this.isCalculatedPointTwin;
        data["capabilityStatus"] = this.capabilityStatus;
        if (this.contents) {
            data["contents"] = {};
            for (let key in this.contents) {
                if (this.contents.hasOwnProperty(key))
                    (<any>data["contents"])[key] = (<any>this.contents)[key];
            }
        }
        data["lastUpdatedOn"] = this.lastUpdatedOn ? this.lastUpdatedOn.toISOString(true) : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data;
    }
}

/** Equipment item and associated rule instances */
export interface IEquipmentDto {
    /** Id for the equipment, currently just the one */
    equipmentId?: string | undefined;
    /** ModelId for the equipment, currently just the one */
    modelId?: string | undefined;
    /** Name of the equipment */
    name?: string | undefined;
    /** Description of the equipment */
    description?: string | undefined;
    /** Related entities up */
    relatedEntities?: RelatedEntityDto[] | undefined;
    /** Related entities down */
    inverseRelatedEntities?: RelatedEntityDto[] | undefined;
    /** Capabilities */
    capabilities?: CapabilityDto[] | undefined;
    /** Tags */
    tags?: string | undefined;
    /** Unit of measure (for capabilities) */
    unit?: string | undefined;
    /** Interval that we expect this trend to follow (in seconds) */
    trendInterval?: number | undefined;
    /** Value Expression */
    valueExpression?: string | undefined;
    /** Legacy Guid (as string) siteId */
    siteId?: string | undefined;
    /** Legacy Guid equipment unique id */
    equipmentUniqueId?: string | undefined;
    /** External Id used in some time series values */
    externalId?: string | undefined;
    /** Connector Id used in some time series values */
    connectorId?: string | undefined;
    /** Trend Id used in some time series values */
    trendId?: string | undefined;
    /** Timezone */
    timezone?: string | undefined;
    /** Equipment is calculated point */
    isCalculatedPointTwin?: boolean;
    capabilityStatus?: TimeSeriesStatus;
    /** Additional properties */
    contents?: { [key: string]: any; } | undefined;
    /** The date and time the twin was last updated in cache */
    lastUpdatedOn?: moment.Moment | undefined;
    /** Model properties */
    properties?: ModelPropertyDto[] | undefined;
    /** Ascendant locations */
    locations?: TwinLocation[] | undefined;
}

export class FilterSpecificationDto implements IFilterSpecificationDto {
    field!: string;
    operator!: string;
    logicalOperator?: string | undefined;
    value?: any | undefined;

    constructor(data?: IFilterSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.operator = _data["operator"];
            this.logicalOperator = _data["logicalOperator"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["logicalOperator"] = this.logicalOperator;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilterSpecificationDto {
    field: string;
    operator: string;
    logicalOperator?: string | undefined;
    value?: any | undefined;
}

/** A parameter for a function or macro */
export class FunctionParameterDto implements IFunctionParameterDto {
    /** Name for the parameter (in the UI) */
    name?: string | undefined;
    /** Description for the parameter */
    description?: string | undefined;
    /** An optional units for parameter */
    units?: string | undefined;

    constructor(data?: IFunctionParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): FunctionParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["units"] = this.units;
        return data;
    }
}

/** A parameter for a function or macro */
export interface IFunctionParameterDto {
    /** Name for the parameter (in the UI) */
    name?: string | undefined;
    /** Description for the parameter */
    description?: string | undefined;
    /** An optional units for parameter */
    units?: string | undefined;
}

/** Global variable Dto */
export class GlobalVariableDto implements IGlobalVariableDto {
    /** Primary key for Willow.Rules.Model.GlobalVariable table */
    id?: string | undefined;
    /** Name of variable */
    name?: string | undefined;
    /** Description for built-in variables */
    description?: string | undefined;
    /** Expresssion for the variable */
    expression?: RuleParameterDto[] | undefined;
    /** An optional units for the return value */
    units?: string | undefined;
    /** Is a built-in variable */
    isBuiltIn?: boolean;
    variableType?: GlobalVariableType;
    /** The parameters for macros and functions */
    parameters?: FunctionParameterDto[] | undefined;
    /** Tags */
    tags?: string[] | undefined;
    /** Json serialized version for export / import */
    json?: string | undefined;
    policies?: AuthenticatedUserAndPolicyDecisionsDto;

    constructor(data?: IGlobalVariableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["expression"])) {
                this.expression = [] as any;
                for (let item of _data["expression"])
                    this.expression!.push(RuleParameterDto.fromJS(item));
            }
            this.units = _data["units"];
            this.isBuiltIn = _data["isBuiltIn"];
            this.variableType = _data["variableType"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(FunctionParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.json = _data["json"];
            this.policies = _data["policies"] ? AuthenticatedUserAndPolicyDecisionsDto.fromJS(_data["policies"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GlobalVariableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalVariableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.expression)) {
            data["expression"] = [];
            for (let item of this.expression)
                data["expression"].push(item.toJSON());
        }
        data["units"] = this.units;
        data["isBuiltIn"] = this.isBuiltIn;
        data["variableType"] = this.variableType;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["json"] = this.json;
        data["policies"] = this.policies ? this.policies.toJSON() : <any>undefined;
        return data;
    }
}

/** Global variable Dto */
export interface IGlobalVariableDto {
    /** Primary key for Willow.Rules.Model.GlobalVariable table */
    id?: string | undefined;
    /** Name of variable */
    name?: string | undefined;
    /** Description for built-in variables */
    description?: string | undefined;
    /** Expresssion for the variable */
    expression?: RuleParameterDto[] | undefined;
    /** An optional units for the return value */
    units?: string | undefined;
    /** Is a built-in variable */
    isBuiltIn?: boolean;
    variableType?: GlobalVariableType;
    /** The parameters for macros and functions */
    parameters?: FunctionParameterDto[] | undefined;
    /** Tags */
    tags?: string[] | undefined;
    /** Json serialized version for export / import */
    json?: string | undefined;
    policies?: AuthenticatedUserAndPolicyDecisionsDto;
}

/** A batched result */
export class GlobalVariableDtoBatchDto implements IGlobalVariableDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: GlobalVariableDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: IGlobalVariableDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GlobalVariableDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): GlobalVariableDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalVariableDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface IGlobalVariableDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: GlobalVariableDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

export enum GlobalVariableType {
    _0 = 0,
    _1 = 1,
}

export class HealthCheckDto implements IHealthCheckDto {
    key?: string | undefined;
    status?: HealthStatus;
    description?: string | undefined;
    version?: string | undefined;
    entries?: { [key: string]: HealthCheckDto; } | undefined;
    readonly entriesWithPayload?: { [key: string]: any; } | undefined;

    constructor(data?: IHealthCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.version = _data["version"];
            if (_data["entries"]) {
                this.entries = {} as any;
                for (let key in _data["entries"]) {
                    if (_data["entries"].hasOwnProperty(key))
                        (<any>this.entries)![key] = _data["entries"][key] ? HealthCheckDto.fromJS(_data["entries"][key]) : new HealthCheckDto();
                }
            }
            if (_data["entriesWithPayload"]) {
                (<any>this).entriesWithPayload = {} as any;
                for (let key in _data["entriesWithPayload"]) {
                    if (_data["entriesWithPayload"].hasOwnProperty(key))
                        (<any>(<any>this).entriesWithPayload)![key] = _data["entriesWithPayload"][key];
                }
            }
        }
    }

    static fromJS(data: any): HealthCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["status"] = this.status;
        data["description"] = this.description;
        data["version"] = this.version;
        if (this.entries) {
            data["entries"] = {};
            for (let key in this.entries) {
                if (this.entries.hasOwnProperty(key))
                    (<any>data["entries"])[key] = this.entries[key] ? this.entries[key].toJSON() : <any>undefined;
            }
        }
        if (this.entriesWithPayload) {
            data["entriesWithPayload"] = {};
            for (let key in this.entriesWithPayload) {
                if (this.entriesWithPayload.hasOwnProperty(key))
                    (<any>data["entriesWithPayload"])[key] = (<any>this.entriesWithPayload)[key];
            }
        }
        return data;
    }
}

export interface IHealthCheckDto {
    key?: string | undefined;
    status?: HealthStatus;
    description?: string | undefined;
    version?: string | undefined;
    entries?: { [key: string]: HealthCheckDto; } | undefined;
    entriesWithPayload?: { [key: string]: any; } | undefined;
}

export enum HealthStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

/** A possible dependency that may exist for an insight */
export class InsightDependencyDto implements IInsightDependencyDto {
    /** The relationship to the referenced insight */
    relationship?: string | undefined;
    /** The referenced insight */
    insightId?: string | undefined;
    insight?: InsightDto;

    constructor(data?: IInsightDependencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relationship = _data["relationship"];
            this.insightId = _data["insightId"];
            this.insight = _data["insight"] ? InsightDto.fromJS(_data["insight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsightDependencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightDependencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationship"] = this.relationship;
        data["insightId"] = this.insightId;
        data["insight"] = this.insight ? this.insight.toJSON() : <any>undefined;
        return data;
    }
}

/** A possible dependency that may exist for an insight */
export interface IInsightDependencyDto {
    /** The relationship to the referenced insight */
    relationship?: string | undefined;
    /** The referenced insight */
    insightId?: string | undefined;
    insight?: InsightDto;
}

/** Dto for Willow.Rules.Model.Insight */
export class InsightDto implements IInsightDto {
    /** Id of the Insight */
    readonly id?: string | undefined;
    /** Last time the insight was updated (live data time, not 'now') */
    readonly lastUpdated?: moment.Moment;
    status?: InsightStatus;
    /** Number of invocations of the rule */
    readonly invocations?: number;
    /** Insight impact scores, e.g. cost, comfort, reliability, etc. */
    readonly impactScores?: InsightImpactDto[] | undefined;
    /** Datetime ranges for which the insight was triggered */
    readonly occurrences?: InsightOccurrenceDto[] | undefined;
    /** The capability references */
    readonly points?: NamedPointDto[] | undefined;
    /** Dependencies to other insights */
    dependencies?: InsightDependencyDto[] | undefined;
    /** Id of the rule that created the insight */
    readonly ruleId?: string | undefined;
    /** Id of the rule instance that created the insight */
    readonly ruleInstanceId?: string | undefined;
    /** The model of the primary equipment ID (anchor) for this rule */
    readonly primaryModelId?: string | undefined;
    /** The Id of the insight in Command after first posting it, for updates */
    readonly commandInsightId?: string | undefined;
    /** Name of the rule used */
    readonly ruleName?: string | undefined;
    /** Id of the template used */
    readonly ruleTemplate?: string | undefined;
    /** Text of the insight */
    readonly text?: string | undefined;
    /** The twin id */
    readonly equipmentId?: string | undefined;
    /** The twin name */
    readonly equipmentName?: string | undefined;
    /** The twin unique id (Guid) legacy */
    readonly equipmentUniqueId?: string | undefined;
    /** The legacy SiteId necessary for posting insights to Command */
    readonly siteId?: string | undefined;
    /** Category of the rule (e.g. Return Air)) */
    category?: string | undefined;
    /** Description of the rule, maybe use in a tool tip */
    description?: string | undefined;
    /** A link to the insight page in command */
    insightUrl?: string | undefined;
    /** Recommendations for fixing the fault */
    recommendations?: string | undefined;
    /** Locations that could be affected (search) */
    readonly locations?: TwinLocation[] | undefined;
    /** List of tags associated to the Rule that created the Insight (search) */
    readonly ruleTags?: string[] | undefined;
    /** Downstream devices that could be affected (search) */
    readonly feeds?: string[] | undefined;
    /** The insight is synchronized with Command */
    readonly commandEnabled?: boolean;
    /** The time zone of the equipment at the heart of this insight */
    readonly timeZone?: string | undefined;
    /** Upstream devices that could affect (search) */
    readonly fedBy?: string[] | undefined;
    /** Earliest faulted date */
    readonly earliestFaultedDate?: moment.Moment | undefined;
    /** Latest faulted date */
    readonly lastFaultedDate?: moment.Moment | undefined;
    /** Currently in faulted state */
    readonly isFaulty?: boolean;
    /** Currently in valid state */
    readonly isValid?: boolean;
    /** How many times has it faulted */
    readonly faultedCount?: number;
    /** Last updated date processed */
    lastUpdatedUTC?: moment.Moment;
    /** Last date syned with Command */
    lastSyncDateUTC?: moment.Moment | undefined;
    /** The next date which the Insight is allowed to sync to command */
    nextAllowedSyncDateUTC?: moment.Moment | undefined;

    constructor(data?: IInsightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).lastUpdated = _data["lastUpdated"] ? moment.parseZone(_data["lastUpdated"].toString()) : <any>undefined;
            this.status = _data["status"];
            (<any>this).invocations = _data["invocations"];
            if (Array.isArray(_data["impactScores"])) {
                (<any>this).impactScores = [] as any;
                for (let item of _data["impactScores"])
                    (<any>this).impactScores!.push(InsightImpactDto.fromJS(item));
            }
            if (Array.isArray(_data["occurrences"])) {
                (<any>this).occurrences = [] as any;
                for (let item of _data["occurrences"])
                    (<any>this).occurrences!.push(InsightOccurrenceDto.fromJS(item));
            }
            if (Array.isArray(_data["points"])) {
                (<any>this).points = [] as any;
                for (let item of _data["points"])
                    (<any>this).points!.push(NamedPointDto.fromJS(item));
            }
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(InsightDependencyDto.fromJS(item));
            }
            (<any>this).ruleId = _data["ruleId"];
            (<any>this).ruleInstanceId = _data["ruleInstanceId"];
            (<any>this).primaryModelId = _data["primaryModelId"];
            (<any>this).commandInsightId = _data["commandInsightId"];
            (<any>this).ruleName = _data["ruleName"];
            (<any>this).ruleTemplate = _data["ruleTemplate"];
            (<any>this).text = _data["text"];
            (<any>this).equipmentId = _data["equipmentId"];
            (<any>this).equipmentName = _data["equipmentName"];
            (<any>this).equipmentUniqueId = _data["equipmentUniqueId"];
            (<any>this).siteId = _data["siteId"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.insightUrl = _data["insightUrl"];
            this.recommendations = _data["recommendations"];
            if (Array.isArray(_data["locations"])) {
                (<any>this).locations = [] as any;
                for (let item of _data["locations"])
                    (<any>this).locations!.push(TwinLocation.fromJS(item));
            }
            if (Array.isArray(_data["ruleTags"])) {
                (<any>this).ruleTags = [] as any;
                for (let item of _data["ruleTags"])
                    (<any>this).ruleTags!.push(item);
            }
            if (Array.isArray(_data["feeds"])) {
                (<any>this).feeds = [] as any;
                for (let item of _data["feeds"])
                    (<any>this).feeds!.push(item);
            }
            (<any>this).commandEnabled = _data["commandEnabled"];
            (<any>this).timeZone = _data["timeZone"];
            if (Array.isArray(_data["fedBy"])) {
                (<any>this).fedBy = [] as any;
                for (let item of _data["fedBy"])
                    (<any>this).fedBy!.push(item);
            }
            (<any>this).earliestFaultedDate = _data["earliestFaultedDate"] ? moment.parseZone(_data["earliestFaultedDate"].toString()) : <any>undefined;
            (<any>this).lastFaultedDate = _data["lastFaultedDate"] ? moment.parseZone(_data["lastFaultedDate"].toString()) : <any>undefined;
            (<any>this).isFaulty = _data["isFaulty"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).faultedCount = _data["faultedCount"];
            this.lastUpdatedUTC = _data["lastUpdatedUTC"] ? moment.parseZone(_data["lastUpdatedUTC"].toString()) : <any>undefined;
            this.lastSyncDateUTC = _data["lastSyncDateUTC"] ? moment.parseZone(_data["lastSyncDateUTC"].toString()) : <any>undefined;
            this.nextAllowedSyncDateUTC = _data["nextAllowedSyncDateUTC"] ? moment.parseZone(_data["nextAllowedSyncDateUTC"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsightDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString(true) : <any>undefined;
        data["status"] = this.status;
        data["invocations"] = this.invocations;
        if (Array.isArray(this.impactScores)) {
            data["impactScores"] = [];
            for (let item of this.impactScores)
                data["impactScores"].push(item.toJSON());
        }
        if (Array.isArray(this.occurrences)) {
            data["occurrences"] = [];
            for (let item of this.occurrences)
                data["occurrences"].push(item.toJSON());
        }
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item.toJSON());
        }
        data["ruleId"] = this.ruleId;
        data["ruleInstanceId"] = this.ruleInstanceId;
        data["primaryModelId"] = this.primaryModelId;
        data["commandInsightId"] = this.commandInsightId;
        data["ruleName"] = this.ruleName;
        data["ruleTemplate"] = this.ruleTemplate;
        data["text"] = this.text;
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["equipmentUniqueId"] = this.equipmentUniqueId;
        data["siteId"] = this.siteId;
        data["category"] = this.category;
        data["description"] = this.description;
        data["insightUrl"] = this.insightUrl;
        data["recommendations"] = this.recommendations;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleTags)) {
            data["ruleTags"] = [];
            for (let item of this.ruleTags)
                data["ruleTags"].push(item);
        }
        if (Array.isArray(this.feeds)) {
            data["feeds"] = [];
            for (let item of this.feeds)
                data["feeds"].push(item);
        }
        data["commandEnabled"] = this.commandEnabled;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.fedBy)) {
            data["fedBy"] = [];
            for (let item of this.fedBy)
                data["fedBy"].push(item);
        }
        data["earliestFaultedDate"] = this.earliestFaultedDate ? this.earliestFaultedDate.toISOString(true) : <any>undefined;
        data["lastFaultedDate"] = this.lastFaultedDate ? this.lastFaultedDate.toISOString(true) : <any>undefined;
        data["isFaulty"] = this.isFaulty;
        data["isValid"] = this.isValid;
        data["faultedCount"] = this.faultedCount;
        data["lastUpdatedUTC"] = this.lastUpdatedUTC ? this.lastUpdatedUTC.toISOString(true) : <any>undefined;
        data["lastSyncDateUTC"] = this.lastSyncDateUTC ? this.lastSyncDateUTC.toISOString(true) : <any>undefined;
        data["nextAllowedSyncDateUTC"] = this.nextAllowedSyncDateUTC ? this.nextAllowedSyncDateUTC.toISOString(true) : <any>undefined;
        return data;
    }
}

/** Dto for Willow.Rules.Model.Insight */
export interface IInsightDto {
    /** Id of the Insight */
    id?: string | undefined;
    /** Last time the insight was updated (live data time, not 'now') */
    lastUpdated?: moment.Moment;
    status?: InsightStatus;
    /** Number of invocations of the rule */
    invocations?: number;
    /** Insight impact scores, e.g. cost, comfort, reliability, etc. */
    impactScores?: InsightImpactDto[] | undefined;
    /** Datetime ranges for which the insight was triggered */
    occurrences?: InsightOccurrenceDto[] | undefined;
    /** The capability references */
    points?: NamedPointDto[] | undefined;
    /** Dependencies to other insights */
    dependencies?: InsightDependencyDto[] | undefined;
    /** Id of the rule that created the insight */
    ruleId?: string | undefined;
    /** Id of the rule instance that created the insight */
    ruleInstanceId?: string | undefined;
    /** The model of the primary equipment ID (anchor) for this rule */
    primaryModelId?: string | undefined;
    /** The Id of the insight in Command after first posting it, for updates */
    commandInsightId?: string | undefined;
    /** Name of the rule used */
    ruleName?: string | undefined;
    /** Id of the template used */
    ruleTemplate?: string | undefined;
    /** Text of the insight */
    text?: string | undefined;
    /** The twin id */
    equipmentId?: string | undefined;
    /** The twin name */
    equipmentName?: string | undefined;
    /** The twin unique id (Guid) legacy */
    equipmentUniqueId?: string | undefined;
    /** The legacy SiteId necessary for posting insights to Command */
    siteId?: string | undefined;
    /** Category of the rule (e.g. Return Air)) */
    category?: string | undefined;
    /** Description of the rule, maybe use in a tool tip */
    description?: string | undefined;
    /** A link to the insight page in command */
    insightUrl?: string | undefined;
    /** Recommendations for fixing the fault */
    recommendations?: string | undefined;
    /** Locations that could be affected (search) */
    locations?: TwinLocation[] | undefined;
    /** List of tags associated to the Rule that created the Insight (search) */
    ruleTags?: string[] | undefined;
    /** Downstream devices that could be affected (search) */
    feeds?: string[] | undefined;
    /** The insight is synchronized with Command */
    commandEnabled?: boolean;
    /** The time zone of the equipment at the heart of this insight */
    timeZone?: string | undefined;
    /** Upstream devices that could affect (search) */
    fedBy?: string[] | undefined;
    /** Earliest faulted date */
    earliestFaultedDate?: moment.Moment | undefined;
    /** Latest faulted date */
    lastFaultedDate?: moment.Moment | undefined;
    /** Currently in faulted state */
    isFaulty?: boolean;
    /** Currently in valid state */
    isValid?: boolean;
    /** How many times has it faulted */
    faultedCount?: number;
    /** Last updated date processed */
    lastUpdatedUTC?: moment.Moment;
    /** Last date syned with Command */
    lastSyncDateUTC?: moment.Moment | undefined;
    /** The next date which the Insight is allowed to sync to command */
    nextAllowedSyncDateUTC?: moment.Moment | undefined;
}

/** Insight Batch Dto */
export class InsightDtoBatchDto implements IInsightDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: InsightDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** A unique list of impact score names and fields */
    impactScoreNames?: InsightImpactSummaryDto[] | undefined;

    constructor(data?: IInsightDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsightDto.fromJS(item));
            }
            this.next = _data["next"];
            if (Array.isArray(_data["impactScoreNames"])) {
                this.impactScoreNames = [] as any;
                for (let item of _data["impactScoreNames"])
                    this.impactScoreNames!.push(InsightImpactSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsightDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        if (Array.isArray(this.impactScoreNames)) {
            data["impactScoreNames"] = [];
            for (let item of this.impactScoreNames)
                data["impactScoreNames"].push(item.toJSON());
        }
        return data;
    }
}

/** Insight Batch Dto */
export interface IInsightDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: InsightDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** A unique list of impact score names and fields */
    impactScoreNames?: InsightImpactSummaryDto[] | undefined;
}

/** Dto for RulesEngine.Web.DTO.InsightImpactDto */
export class InsightImpactDto implements IInsightImpactDto {
    /** The name of the impact score */
    name?: string | undefined;
    /** The field id of the impact score */
    fieldId?: string | undefined;
    /** The ADX external id of the impact score */
    externalId?: string | undefined;
    /** The value of the impact score */
    score?: number;
    /** The unit of measure for the score */
    unit?: string | undefined;

    constructor(data?: IInsightImpactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fieldId = _data["fieldId"];
            this.externalId = _data["externalId"];
            this.score = _data["score"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): InsightImpactDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightImpactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fieldId"] = this.fieldId;
        data["externalId"] = this.externalId;
        data["score"] = this.score;
        data["unit"] = this.unit;
        return data;
    }
}

/** Dto for RulesEngine.Web.DTO.InsightImpactDto */
export interface IInsightImpactDto {
    /** The name of the impact score */
    name?: string | undefined;
    /** The field id of the impact score */
    fieldId?: string | undefined;
    /** The ADX external id of the impact score */
    externalId?: string | undefined;
    /** The value of the impact score */
    score?: number;
    /** The unit of measure for the score */
    unit?: string | undefined;
}

/** Dto for RulesEngine.Web.DTO.InsightImpactDto */
export class InsightImpactSummaryDto implements IInsightImpactSummaryDto {
    /** The name of the impact score */
    name?: string | undefined;
    /** The field id of the impact score */
    fieldId?: string | undefined;
    /** The units of measure used by all the impact scores having this id */
    units?: string[] | undefined;
    /** How many times this impact score id is used */
    count?: number;

    constructor(data?: IInsightImpactSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["units"])) {
                this.units = [] as any;
                for (let item of _data["units"])
                    this.units!.push(item);
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): InsightImpactSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightImpactSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item);
        }
        data["count"] = this.count;
        return data;
    }
}

/** Dto for RulesEngine.Web.DTO.InsightImpactDto */
export interface IInsightImpactSummaryDto {
    /** The name of the impact score */
    name?: string | undefined;
    /** The field id of the impact score */
    fieldId?: string | undefined;
    /** The units of measure used by all the impact scores having this id */
    units?: string[] | undefined;
    /** How many times this impact score id is used */
    count?: number;
}

/** Dto for an Willow.Rules.Model.InsightOccurrence */
export class InsightOccurrenceDto implements IInsightOccurrenceDto {
    /** Id of the Insight Occurrence */
    readonly id?: string | undefined;
    /** Whether the insight occurrence is faulted */
    readonly isFaulted?: boolean;
    /** Whether the range is valid (has enough data in it) */
    readonly isValid?: boolean;
    /** Start of interval */
    readonly started?: moment.Moment;
    /** Text description of the insight over the interval */
    readonly text?: string | undefined;
    /** End of interval */
    readonly ended?: moment.Moment;

    constructor(data?: IInsightOccurrenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).isFaulted = _data["isFaulted"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).started = _data["started"] ? moment.parseZone(_data["started"].toString()) : <any>undefined;
            (<any>this).text = _data["text"];
            (<any>this).ended = _data["ended"] ? moment.parseZone(_data["ended"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsightOccurrenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightOccurrenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isFaulted"] = this.isFaulted;
        data["isValid"] = this.isValid;
        data["started"] = this.started ? this.started.toISOString(true) : <any>undefined;
        data["text"] = this.text;
        data["ended"] = this.ended ? this.ended.toISOString(true) : <any>undefined;
        return data;
    }
}

/** Dto for an Willow.Rules.Model.InsightOccurrence */
export interface IInsightOccurrenceDto {
    /** Id of the Insight Occurrence */
    id?: string | undefined;
    /** Whether the insight occurrence is faulted */
    isFaulted?: boolean;
    /** Whether the range is valid (has enough data in it) */
    isValid?: boolean;
    /** Start of interval */
    started?: moment.Moment;
    /** Text description of the insight over the interval */
    text?: string | undefined;
    /** End of interval */
    ended?: moment.Moment;
}

export enum InsightStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

/** Dto for RulesEngine.Web.DTO.InsightStatusDto */
export class InsightStatusDto implements IInsightStatusDto {
    /** The time of the change */
    timestamp?: moment.Moment;
    status?: InsightStatus;

    constructor(data?: IInsightStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? moment.parseZone(_data["timestamp"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InsightStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString(true) : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

/** Dto for RulesEngine.Web.DTO.InsightStatusDto */
export interface IInsightStatusDto {
    /** The time of the change */
    timestamp?: moment.Moment;
    status?: InsightStatus;
}

/** Contains summary info on insights */
export class InsightsSummaryDto implements IInsightsSummaryDto {
    /** Insights marked not to sync but already pushed to Command */
    totalNotSynced?: number;
    /** Insights linked to a command insight */
    totalLinked?: number;
    /** Total insights */
    total?: number;
    /** Total insights enabled to sync */
    totalEnabled?: number;
    /** Faulted */
    totalFaulted?: number;
    /** Invalid */
    totalInvalid?: number;
    /** Not faulted */
    totalValidNotFaulted?: number;
    /** Insights by model type */
    insightsByModel?: { [key: string]: number; } | undefined;

    constructor(data?: IInsightsSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNotSynced = _data["totalNotSynced"];
            this.totalLinked = _data["totalLinked"];
            this.total = _data["total"];
            this.totalEnabled = _data["totalEnabled"];
            this.totalFaulted = _data["totalFaulted"];
            this.totalInvalid = _data["totalInvalid"];
            this.totalValidNotFaulted = _data["totalValidNotFaulted"];
            if (_data["insightsByModel"]) {
                this.insightsByModel = {} as any;
                for (let key in _data["insightsByModel"]) {
                    if (_data["insightsByModel"].hasOwnProperty(key))
                        (<any>this.insightsByModel)![key] = _data["insightsByModel"][key];
                }
            }
        }
    }

    static fromJS(data: any): InsightsSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsightsSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNotSynced"] = this.totalNotSynced;
        data["totalLinked"] = this.totalLinked;
        data["total"] = this.total;
        data["totalEnabled"] = this.totalEnabled;
        data["totalFaulted"] = this.totalFaulted;
        data["totalInvalid"] = this.totalInvalid;
        data["totalValidNotFaulted"] = this.totalValidNotFaulted;
        if (this.insightsByModel) {
            data["insightsByModel"] = {};
            for (let key in this.insightsByModel) {
                if (this.insightsByModel.hasOwnProperty(key))
                    (<any>data["insightsByModel"])[key] = (<any>this.insightsByModel)[key];
            }
        }
        return data;
    }
}

/** Contains summary info on insights */
export interface IInsightsSummaryDto {
    /** Insights marked not to sync but already pushed to Command */
    totalNotSynced?: number;
    /** Insights linked to a command insight */
    totalLinked?: number;
    /** Total insights */
    total?: number;
    /** Total insights enabled to sync */
    totalEnabled?: number;
    /** Faulted */
    totalFaulted?: number;
    /** Invalid */
    totalInvalid?: number;
    /** Not faulted */
    totalValidNotFaulted?: number;
    /** Insights by model type */
    insightsByModel?: { [key: string]: number; } | undefined;
}

/** Represents a log entry */
export class LogEntryDto implements ILogEntryDto {
    /** The log message */
    message?: string | undefined;
    /** The log level */
    level?: string | undefined;
    /** When log occured */
    timeStamp?: moment.Moment;
    /** Any exception stack trace */
    exception?: string | undefined;
    /** Structured json properties */
    logEvent?: string | undefined;
    /** Correlation Id id for logs */
    correlationId?: string | undefined;
    /** Progress Id for logs */
    progressId?: string | undefined;

    constructor(data?: ILogEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.level = _data["level"];
            this.timeStamp = _data["timeStamp"] ? moment.parseZone(_data["timeStamp"].toString()) : <any>undefined;
            this.exception = _data["exception"];
            this.logEvent = _data["logEvent"];
            this.correlationId = _data["correlationId"];
            this.progressId = _data["progressId"];
        }
    }

    static fromJS(data: any): LogEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["level"] = this.level;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString(true) : <any>undefined;
        data["exception"] = this.exception;
        data["logEvent"] = this.logEvent;
        data["correlationId"] = this.correlationId;
        data["progressId"] = this.progressId;
        return data;
    }
}

/** Represents a log entry */
export interface ILogEntryDto {
    /** The log message */
    message?: string | undefined;
    /** The log level */
    level?: string | undefined;
    /** When log occured */
    timeStamp?: moment.Moment;
    /** Any exception stack trace */
    exception?: string | undefined;
    /** Structured json properties */
    logEvent?: string | undefined;
    /** Correlation Id id for logs */
    correlationId?: string | undefined;
    /** Progress Id for logs */
    progressId?: string | undefined;
}

/** A batched result */
export class LogEntryDtoBatchDto implements ILogEntryDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: LogEntryDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: ILogEntryDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LogEntryDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): LogEntryDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogEntryDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface ILogEntryDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: LogEntryDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

/** A container object for ml model binary */
export class MLModelDto implements IMLModelDto {
    /** The id for the model */
    id?: string | undefined;
    /** The name of the model */
    modelName?: string | undefined;
    /** The description of the model */
    description?: string | undefined;
    /** The version of the model */
    modelVersion?: string | undefined;
    /** The full name of the model */
    fullName?: string | undefined;
    /** Input params for model */
    inputParams?: MLModelParam[] | undefined;
    /** Output params for model */
    outputParams?: MLModelParam[] | undefined;
    /** Model load errors if any */
    error?: string | undefined;

    constructor(data?: IMLModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.modelName = _data["modelName"];
            this.description = _data["description"];
            this.modelVersion = _data["modelVersion"];
            this.fullName = _data["fullName"];
            if (Array.isArray(_data["inputParams"])) {
                this.inputParams = [] as any;
                for (let item of _data["inputParams"])
                    this.inputParams!.push(MLModelParam.fromJS(item));
            }
            if (Array.isArray(_data["outputParams"])) {
                this.outputParams = [] as any;
                for (let item of _data["outputParams"])
                    this.outputParams!.push(MLModelParam.fromJS(item));
            }
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): MLModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new MLModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modelName"] = this.modelName;
        data["description"] = this.description;
        data["modelVersion"] = this.modelVersion;
        data["fullName"] = this.fullName;
        if (Array.isArray(this.inputParams)) {
            data["inputParams"] = [];
            for (let item of this.inputParams)
                data["inputParams"].push(item.toJSON());
        }
        if (Array.isArray(this.outputParams)) {
            data["outputParams"] = [];
            for (let item of this.outputParams)
                data["outputParams"].push(item.toJSON());
        }
        data["error"] = this.error;
        return data;
    }
}

/** A container object for ml model binary */
export interface IMLModelDto {
    /** The id for the model */
    id?: string | undefined;
    /** The name of the model */
    modelName?: string | undefined;
    /** The description of the model */
    description?: string | undefined;
    /** The version of the model */
    modelVersion?: string | undefined;
    /** The full name of the model */
    fullName?: string | undefined;
    /** Input params for model */
    inputParams?: MLModelParam[] | undefined;
    /** Output params for model */
    outputParams?: MLModelParam[] | undefined;
    /** Model load errors if any */
    error?: string | undefined;
}

/** A batched result */
export class MLModelDtoBatchDto implements IMLModelDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: MLModelDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: IMLModelDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MLModelDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): MLModelDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new MLModelDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface IMLModelDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: MLModelDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

export class MLModelParam implements IMLModelParam {
    name?: string | undefined;
    unit?: string | undefined;
    size?: number;
    description?: string | undefined;

    constructor(data?: IMLModelParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.size = _data["size"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MLModelParam {
        data = typeof data === 'object' ? data : {};
        let result = new MLModelParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["size"] = this.size;
        data["description"] = this.description;
        return data;
    }
}

export interface IMLModelParam {
    name?: string | undefined;
    unit?: string | undefined;
    size?: number;
    description?: string | undefined;
}

/** A copy of DigitalTwinsModelData */
export class ModelDto implements IModelDto {
    /** A language dictionary that contains the localized display names as specified
in the model definition. */
    languageDisplayNames?: { [key: string]: string; } | undefined;
    /** A language dictionary that contains the localized descriptions as specified in
the model definition. */
    languageDescriptions?: { [key: string]: string; } | undefined;
    /** Model ids that this id inherits from */
    inheritedModelIds?: string[] | undefined;
    /** The id of the model as specified in the model definition. */
    id?: string | undefined;
    /** Indicates if the model is decommissioned. Decommissioned models cannot be referenced by newly created digital twins. */
    decommissioned?: boolean | undefined;
    /** Model properties */
    properties?: ModelPropertyDto[] | undefined;

    constructor(data?: IModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["languageDisplayNames"]) {
                this.languageDisplayNames = {} as any;
                for (let key in _data["languageDisplayNames"]) {
                    if (_data["languageDisplayNames"].hasOwnProperty(key))
                        (<any>this.languageDisplayNames)![key] = _data["languageDisplayNames"][key];
                }
            }
            if (_data["languageDescriptions"]) {
                this.languageDescriptions = {} as any;
                for (let key in _data["languageDescriptions"]) {
                    if (_data["languageDescriptions"].hasOwnProperty(key))
                        (<any>this.languageDescriptions)![key] = _data["languageDescriptions"][key];
                }
            }
            if (Array.isArray(_data["inheritedModelIds"])) {
                this.inheritedModelIds = [] as any;
                for (let item of _data["inheritedModelIds"])
                    this.inheritedModelIds!.push(item);
            }
            this.id = _data["id"];
            this.decommissioned = _data["decommissioned"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ModelPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.languageDisplayNames) {
            data["languageDisplayNames"] = {};
            for (let key in this.languageDisplayNames) {
                if (this.languageDisplayNames.hasOwnProperty(key))
                    (<any>data["languageDisplayNames"])[key] = (<any>this.languageDisplayNames)[key];
            }
        }
        if (this.languageDescriptions) {
            data["languageDescriptions"] = {};
            for (let key in this.languageDescriptions) {
                if (this.languageDescriptions.hasOwnProperty(key))
                    (<any>data["languageDescriptions"])[key] = (<any>this.languageDescriptions)[key];
            }
        }
        if (Array.isArray(this.inheritedModelIds)) {
            data["inheritedModelIds"] = [];
            for (let item of this.inheritedModelIds)
                data["inheritedModelIds"].push(item);
        }
        data["id"] = this.id;
        data["decommissioned"] = this.decommissioned;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

/** A copy of DigitalTwinsModelData */
export interface IModelDto {
    /** A language dictionary that contains the localized display names as specified
in the model definition. */
    languageDisplayNames?: { [key: string]: string; } | undefined;
    /** A language dictionary that contains the localized descriptions as specified in
the model definition. */
    languageDescriptions?: { [key: string]: string; } | undefined;
    /** Model ids that this id inherits from */
    inheritedModelIds?: string[] | undefined;
    /** The id of the model as specified in the model definition. */
    id?: string | undefined;
    /** Indicates if the model is decommissioned. Decommissioned models cannot be referenced by newly created digital twins. */
    decommissioned?: boolean | undefined;
    /** Model properties */
    properties?: ModelPropertyDto[] | undefined;
}

/** A model property */
export class ModelPropertyDto implements IModelPropertyDto {
    /** From which model id */
    modelId?: string | undefined;
    /** Name of property */
    propertyName?: string | undefined;
    /** Name of property */
    propertyKey?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;

    constructor(data?: IModelPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelId = _data["modelId"];
            this.propertyName = _data["propertyName"];
            this.propertyKey = _data["propertyKey"];
            this.propertyType = _data["propertyType"];
        }
    }

    static fromJS(data: any): ModelPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["propertyName"] = this.propertyName;
        data["propertyKey"] = this.propertyKey;
        data["propertyType"] = this.propertyType;
        return data;
    }
}

/** A model property */
export interface IModelPropertyDto {
    /** From which model id */
    modelId?: string | undefined;
    /** Name of property */
    propertyName?: string | undefined;
    /** Name of property */
    propertyKey?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
}

export class ModelSimpleDto implements IModelSimpleDto {
    id?: number;
    modelId?: string | undefined;
    label?: string | undefined;
    languageDisplayNames?: { [key: string]: string; } | undefined;
    languageDescriptions?: { [key: string]: string; } | undefined;
    units?: string[] | undefined;
    decommissioned?: boolean;
    count?: number;
    countInherited?: number;
    readonly total?: number;
    isCapability?: boolean;

    constructor(data?: IModelSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.modelId = _data["modelId"];
            this.label = _data["label"];
            if (_data["languageDisplayNames"]) {
                this.languageDisplayNames = {} as any;
                for (let key in _data["languageDisplayNames"]) {
                    if (_data["languageDisplayNames"].hasOwnProperty(key))
                        (<any>this.languageDisplayNames)![key] = _data["languageDisplayNames"][key];
                }
            }
            if (_data["languageDescriptions"]) {
                this.languageDescriptions = {} as any;
                for (let key in _data["languageDescriptions"]) {
                    if (_data["languageDescriptions"].hasOwnProperty(key))
                        (<any>this.languageDescriptions)![key] = _data["languageDescriptions"][key];
                }
            }
            if (Array.isArray(_data["units"])) {
                this.units = [] as any;
                for (let item of _data["units"])
                    this.units!.push(item);
            }
            this.decommissioned = _data["decommissioned"];
            this.count = _data["count"];
            this.countInherited = _data["countInherited"];
            (<any>this).total = _data["total"];
            this.isCapability = _data["isCapability"];
        }
    }

    static fromJS(data: any): ModelSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modelId"] = this.modelId;
        data["label"] = this.label;
        if (this.languageDisplayNames) {
            data["languageDisplayNames"] = {};
            for (let key in this.languageDisplayNames) {
                if (this.languageDisplayNames.hasOwnProperty(key))
                    (<any>data["languageDisplayNames"])[key] = (<any>this.languageDisplayNames)[key];
            }
        }
        if (this.languageDescriptions) {
            data["languageDescriptions"] = {};
            for (let key in this.languageDescriptions) {
                if (this.languageDescriptions.hasOwnProperty(key))
                    (<any>data["languageDescriptions"])[key] = (<any>this.languageDescriptions)[key];
            }
        }
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item);
        }
        data["decommissioned"] = this.decommissioned;
        data["count"] = this.count;
        data["countInherited"] = this.countInherited;
        data["total"] = this.total;
        data["isCapability"] = this.isCapability;
        return data;
    }
}

export interface IModelSimpleDto {
    id?: number;
    modelId?: string | undefined;
    label?: string | undefined;
    languageDisplayNames?: { [key: string]: string; } | undefined;
    languageDescriptions?: { [key: string]: string; } | undefined;
    units?: string[] | undefined;
    decommissioned?: boolean;
    count?: number;
    countInherited?: number;
    total?: number;
    isCapability?: boolean;
}

export class ModelSimpleGraphDto implements IModelSimpleGraphDto {
    nodes?: ModelSimpleDto[] | undefined;
    relationships?: ModelSimpleRelationshipDto[] | undefined;

    constructor(data?: IModelSimpleGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(ModelSimpleDto.fromJS(item));
            }
            if (Array.isArray(_data["relationships"])) {
                this.relationships = [] as any;
                for (let item of _data["relationships"])
                    this.relationships!.push(ModelSimpleRelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelSimpleGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelSimpleGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item.toJSON());
        }
        if (Array.isArray(this.relationships)) {
            data["relationships"] = [];
            for (let item of this.relationships)
                data["relationships"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModelSimpleGraphDto {
    nodes?: ModelSimpleDto[] | undefined;
    relationships?: ModelSimpleRelationshipDto[] | undefined;
}

export class ModelSimpleRelationshipDto implements IModelSimpleRelationshipDto {
    startId?: number;
    endId?: number;
    relationship?: string | undefined;
    substance?: string | undefined;

    constructor(data?: IModelSimpleRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startId = _data["startId"];
            this.endId = _data["endId"];
            this.relationship = _data["relationship"];
            this.substance = _data["substance"];
        }
    }

    static fromJS(data: any): ModelSimpleRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelSimpleRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startId"] = this.startId;
        data["endId"] = this.endId;
        data["relationship"] = this.relationship;
        data["substance"] = this.substance;
        return data;
    }
}

export interface IModelSimpleRelationshipDto {
    startId?: number;
    endId?: number;
    relationship?: string | undefined;
    substance?: string | undefined;
}

/** A named point mapping a rule variable name to a point entity Id */
export class NamedPointDto implements INamedPointDto {
    /** The Twin Id */
    id?: string | undefined;
    /** The name that is used grids and expression field */
    variableName?: string | undefined;
    /** The calculated unambiguous name that used in the rule expression */
    fullName?: string | undefined;
    /** The units from the Twin */
    unit?: string | undefined;
    /** The units from the Twin */
    shortName?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Parent chain by locatedIn and isPartOf */
    locations?: TwinLocation[] | undefined;

    constructor(data?: INamedPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.variableName = _data["variableName"];
            this.fullName = _data["fullName"];
            this.unit = _data["unit"];
            this.shortName = _data["shortName"];
            this.modelId = _data["modelId"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NamedPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new NamedPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["variableName"] = this.variableName;
        data["fullName"] = this.fullName;
        data["unit"] = this.unit;
        data["shortName"] = this.shortName;
        data["modelId"] = this.modelId;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data;
    }
}

/** A named point mapping a rule variable name to a point entity Id */
export interface INamedPointDto {
    /** The Twin Id */
    id?: string | undefined;
    /** The name that is used grids and expression field */
    variableName?: string | undefined;
    /** The calculated unambiguous name that used in the rule expression */
    fullName?: string | undefined;
    /** The units from the Twin */
    unit?: string | undefined;
    /** The units from the Twin */
    shortName?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Parent chain by locatedIn and isPartOf */
    locations?: TwinLocation[] | undefined;
}

/** An output value with a start time, optional end time, boolean result, and impacts */
export class OutputValueDto implements IOutputValueDto {
    /** Start time of this output value */
    startTime?: moment.Moment;
    /** End time of this output value, may be same as start time for last instance
which really means open to now */
    endTime?: moment.Moment;
    /** Gets the duration of this output value */
    duration?: string | undefined;
    /** Validity state during this window of time */
    isValid?: boolean;
    /** Failed when true */
    faulted?: boolean;
    /** Text description TODO: Change this to an array */
    text?: string | undefined;

    constructor(data?: IOutputValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment.parseZone(_data["endTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.isValid = _data["isValid"];
            this.faulted = _data["faulted"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): OutputValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutputValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString(true) : <any>undefined;
        data["duration"] = this.duration;
        data["isValid"] = this.isValid;
        data["faulted"] = this.faulted;
        data["text"] = this.text;
        return data;
    }
}

/** An output value with a start time, optional end time, boolean result, and impacts */
export interface IOutputValueDto {
    /** Start time of this output value */
    startTime?: moment.Moment;
    /** End time of this output value, may be same as start time for last instance
which really means open to now */
    endTime?: moment.Moment;
    /** Gets the duration of this output value */
    duration?: string | undefined;
    /** Validity state during this window of time */
    isValid?: boolean;
    /** Failed when true */
    faulted?: boolean;
    /** Text description TODO: Change this to an array */
    text?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Tracks progress by the processor back-end, may be rendered by the front-end */
export class ProgressDto implements IProgressDto {
    /** Is this a queued request */
    queued?: boolean;
    status?: ProgressStatus;
    /** The reason for failure */
    failedReason?: string | undefined;
    /** The Id */
    id?: string | undefined;
    type?: ProgressType;
    /** Whether it's realtime execution */
    isRealtime?: boolean;
    /** Is timeout */
    timeout?: boolean;
    /** Can be cancelled */
    canCancel?: boolean;
    /** Progress results for the inner calulations, e.g. Twins, Relationships, ... */
    readonly innerProgress?: ProgressInner[] | undefined;
    /** If the progress is for a specific entity, that's specified here, otherwise "" */
    entityId?: string | undefined;
    /** Correlation Id for progress that is in response to a request to do work */
    correlationId?: string | undefined;
    /** Timestamp for sorting to find most recent progress for any type */
    lastUpdated?: moment.Moment;
    /** Percentage progress */
    percentage?: number;
    /** Server started at this time */
    startTime?: moment.Moment;
    /** Server expects to end at this time */
    eta?: moment.Moment;
    /** Rule Id */
    ruleId?: string | undefined;
    /** Rule Name */
    ruleName?: string | undefined;
    /** Rule execution speed as a x on real-time */
    speed?: number;
    /** Start of tTime series execution time */
    startTimeSeriesTime?: moment.Moment;
    /** Time series execution time */
    currentTimeSeriesTime?: moment.Moment;
    /** End of time series execution time */
    endTimeSeriesTime?: moment.Moment;
    /** The user that requested the job */
    requestedBy?: string | undefined;
    /** The time the user requested */
    dateRequested?: moment.Moment;

    constructor(data?: IProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queued = _data["queued"];
            this.status = _data["status"];
            this.failedReason = _data["failedReason"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isRealtime = _data["isRealtime"];
            this.timeout = _data["timeout"];
            this.canCancel = _data["canCancel"];
            if (Array.isArray(_data["innerProgress"])) {
                (<any>this).innerProgress = [] as any;
                for (let item of _data["innerProgress"])
                    (<any>this).innerProgress!.push(ProgressInner.fromJS(item));
            }
            this.entityId = _data["entityId"];
            this.correlationId = _data["correlationId"];
            this.lastUpdated = _data["lastUpdated"] ? moment.parseZone(_data["lastUpdated"].toString()) : <any>undefined;
            this.percentage = _data["percentage"];
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.eta = _data["eta"] ? moment.parseZone(_data["eta"].toString()) : <any>undefined;
            this.ruleId = _data["ruleId"];
            this.ruleName = _data["ruleName"];
            this.speed = _data["speed"];
            this.startTimeSeriesTime = _data["startTimeSeriesTime"] ? moment.parseZone(_data["startTimeSeriesTime"].toString()) : <any>undefined;
            this.currentTimeSeriesTime = _data["currentTimeSeriesTime"] ? moment.parseZone(_data["currentTimeSeriesTime"].toString()) : <any>undefined;
            this.endTimeSeriesTime = _data["endTimeSeriesTime"] ? moment.parseZone(_data["endTimeSeriesTime"].toString()) : <any>undefined;
            this.requestedBy = _data["requestedBy"];
            this.dateRequested = _data["dateRequested"] ? moment.parseZone(_data["dateRequested"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queued"] = this.queued;
        data["status"] = this.status;
        data["failedReason"] = this.failedReason;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isRealtime"] = this.isRealtime;
        data["timeout"] = this.timeout;
        data["canCancel"] = this.canCancel;
        if (Array.isArray(this.innerProgress)) {
            data["innerProgress"] = [];
            for (let item of this.innerProgress)
                data["innerProgress"].push(item.toJSON());
        }
        data["entityId"] = this.entityId;
        data["correlationId"] = this.correlationId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString(true) : <any>undefined;
        data["percentage"] = this.percentage;
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["eta"] = this.eta ? this.eta.toISOString(true) : <any>undefined;
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["speed"] = this.speed;
        data["startTimeSeriesTime"] = this.startTimeSeriesTime ? this.startTimeSeriesTime.toISOString(true) : <any>undefined;
        data["currentTimeSeriesTime"] = this.currentTimeSeriesTime ? this.currentTimeSeriesTime.toISOString(true) : <any>undefined;
        data["endTimeSeriesTime"] = this.endTimeSeriesTime ? this.endTimeSeriesTime.toISOString(true) : <any>undefined;
        data["requestedBy"] = this.requestedBy;
        data["dateRequested"] = this.dateRequested ? this.dateRequested.toISOString(true) : <any>undefined;
        return data;
    }
}

/** Tracks progress by the processor back-end, may be rendered by the front-end */
export interface IProgressDto {
    /** Is this a queued request */
    queued?: boolean;
    status?: ProgressStatus;
    /** The reason for failure */
    failedReason?: string | undefined;
    /** The Id */
    id?: string | undefined;
    type?: ProgressType;
    /** Whether it's realtime execution */
    isRealtime?: boolean;
    /** Is timeout */
    timeout?: boolean;
    /** Can be cancelled */
    canCancel?: boolean;
    /** Progress results for the inner calulations, e.g. Twins, Relationships, ... */
    innerProgress?: ProgressInner[] | undefined;
    /** If the progress is for a specific entity, that's specified here, otherwise "" */
    entityId?: string | undefined;
    /** Correlation Id for progress that is in response to a request to do work */
    correlationId?: string | undefined;
    /** Timestamp for sorting to find most recent progress for any type */
    lastUpdated?: moment.Moment;
    /** Percentage progress */
    percentage?: number;
    /** Server started at this time */
    startTime?: moment.Moment;
    /** Server expects to end at this time */
    eta?: moment.Moment;
    /** Rule Id */
    ruleId?: string | undefined;
    /** Rule Name */
    ruleName?: string | undefined;
    /** Rule execution speed as a x on real-time */
    speed?: number;
    /** Start of tTime series execution time */
    startTimeSeriesTime?: moment.Moment;
    /** Time series execution time */
    currentTimeSeriesTime?: moment.Moment;
    /** End of time series execution time */
    endTimeSeriesTime?: moment.Moment;
    /** The user that requested the job */
    requestedBy?: string | undefined;
    /** The time the user requested */
    dateRequested?: moment.Moment;
}

export class ProgressInner implements IProgressInner {
    itemName?: string | undefined;
    currentCount?: number;
    totalCount?: number;
    readonly percentageComplete?: number;

    constructor(data?: IProgressInner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemName = _data["itemName"];
            this.currentCount = _data["currentCount"];
            this.totalCount = _data["totalCount"];
            (<any>this).percentageComplete = _data["percentageComplete"];
        }
    }

    static fromJS(data: any): ProgressInner {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressInner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemName"] = this.itemName;
        data["currentCount"] = this.currentCount;
        data["totalCount"] = this.totalCount;
        data["percentageComplete"] = this.percentageComplete;
        return data;
    }
}

export interface IProgressInner {
    itemName?: string | undefined;
    currentCount?: number;
    totalCount?: number;
    percentageComplete?: number;
}

export enum ProgressStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

/** A summary of current progress */
export class ProgressSummaryDto implements IProgressSummaryDto {
    cacheProgress?: ProgressDto;
    ruleExpansionProgress?: ProgressDto;
    ruleExecutionProgress?: ProgressDto;
    realtimeExecutionProgress?: ProgressDto;

    constructor(data?: IProgressSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheProgress = _data["cacheProgress"] ? ProgressDto.fromJS(_data["cacheProgress"]) : <any>undefined;
            this.ruleExpansionProgress = _data["ruleExpansionProgress"] ? ProgressDto.fromJS(_data["ruleExpansionProgress"]) : <any>undefined;
            this.ruleExecutionProgress = _data["ruleExecutionProgress"] ? ProgressDto.fromJS(_data["ruleExecutionProgress"]) : <any>undefined;
            this.realtimeExecutionProgress = _data["realtimeExecutionProgress"] ? ProgressDto.fromJS(_data["realtimeExecutionProgress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgressSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheProgress"] = this.cacheProgress ? this.cacheProgress.toJSON() : <any>undefined;
        data["ruleExpansionProgress"] = this.ruleExpansionProgress ? this.ruleExpansionProgress.toJSON() : <any>undefined;
        data["ruleExecutionProgress"] = this.ruleExecutionProgress ? this.ruleExecutionProgress.toJSON() : <any>undefined;
        data["realtimeExecutionProgress"] = this.realtimeExecutionProgress ? this.realtimeExecutionProgress.toJSON() : <any>undefined;
        return data;
    }
}

/** A summary of current progress */
export interface IProgressSummaryDto {
    cacheProgress?: ProgressDto;
    ruleExpansionProgress?: ProgressDto;
    ruleExecutionProgress?: ProgressDto;
    realtimeExecutionProgress?: ProgressDto;
}

export enum ProgressType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
}

/** Related entity */
export class RelatedEntityDto implements IRelatedEntityDto {
    /** Id of the twin */
    id?: string | undefined;
    /** Name */
    name?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Relationship name */
    relationship?: string | undefined;
    /** Substance */
    substance?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;

    constructor(data?: IRelatedEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
            this.relationship = _data["relationship"];
            this.substance = _data["substance"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): RelatedEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        data["relationship"] = this.relationship;
        data["substance"] = this.substance;
        data["unit"] = this.unit;
        return data;
    }
}

/** Related entity */
export interface IRelatedEntityDto {
    /** Id of the twin */
    id?: string | undefined;
    /** Name */
    name?: string | undefined;
    /** Model id */
    modelId?: string | undefined;
    /** Relationship name */
    relationship?: string | undefined;
    /** Substance */
    substance?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;
}

export enum ReviewStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

/** Comments for rule instance review */
export class RuleCommentDto implements IRuleCommentDto {
    /** The comment made */
    comment?: string | undefined;
    /** When the comment was created */
    created?: moment.Moment;
    /** Which user posted the comment */
    user?: string | undefined;

    constructor(data?: IRuleCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): RuleCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["user"] = this.user;
        return data;
    }
}

/** Comments for rule instance review */
export interface IRuleCommentDto {
    /** The comment made */
    comment?: string | undefined;
    /** When the comment was created */
    created?: moment.Moment;
    /** Which user posted the comment */
    user?: string | undefined;
}

/** A RulesEngine.Web.RuleDependencyBoundDto signifies a relationship between two rules */
export class RuleDependencyBoundDto implements IRuleDependencyBoundDto {
    /** The relationship to the referenced rule instance */
    relationship?: string | undefined;
    /** The rule instance id */
    ruleInstanceId?: string | undefined;
    /** The twin id of the referenced rule instance */
    twinId?: string | undefined;
    /** The twin name of the referenced rule instance */
    twinName?: string | undefined;
    /** The rule id of the referenced rule */
    ruleId?: string | undefined;
    /** The rule name of the referenced rule */
    ruleName?: string | undefined;

    constructor(data?: IRuleDependencyBoundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relationship = _data["relationship"];
            this.ruleInstanceId = _data["ruleInstanceId"];
            this.twinId = _data["twinId"];
            this.twinName = _data["twinName"];
            this.ruleId = _data["ruleId"];
            this.ruleName = _data["ruleName"];
        }
    }

    static fromJS(data: any): RuleDependencyBoundDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDependencyBoundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationship"] = this.relationship;
        data["ruleInstanceId"] = this.ruleInstanceId;
        data["twinId"] = this.twinId;
        data["twinName"] = this.twinName;
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        return data;
    }
}

/** A RulesEngine.Web.RuleDependencyBoundDto signifies a relationship between two rules */
export interface IRuleDependencyBoundDto {
    /** The relationship to the referenced rule instance */
    relationship?: string | undefined;
    /** The rule instance id */
    ruleInstanceId?: string | undefined;
    /** The twin id of the referenced rule instance */
    twinId?: string | undefined;
    /** The twin name of the referenced rule instance */
    twinName?: string | undefined;
    /** The rule id of the referenced rule */
    ruleId?: string | undefined;
    /** The rule name of the referenced rule */
    ruleName?: string | undefined;
}

/** A possible dependency that can be selected for a rule */
export class RuleDependencyDto implements IRuleDependencyDto {
    /** The relationship to the referenced rule */
    relationship?: string | undefined;
    /** The rule id of the referenced rule */
    ruleId?: string | undefined;

    constructor(data?: IRuleDependencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relationship = _data["relationship"];
            this.ruleId = _data["ruleId"];
        }
    }

    static fromJS(data: any): RuleDependencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDependencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationship"] = this.relationship;
        data["ruleId"] = this.ruleId;
        return data;
    }
}

/** A possible dependency that can be selected for a rule */
export interface IRuleDependencyDto {
    /** The relationship to the referenced rule */
    relationship?: string | undefined;
    /** The rule id of the referenced rule */
    ruleId?: string | undefined;
}

/** A possible dependency that can be selected for a rule */
export class RuleDependencyListItemDto implements IRuleDependencyListItemDto {
    /** The rule id */
    ruleId?: string | undefined;
    /** Whether this dependency is enabled */
    isEnabled?: boolean;
    /** The distance from the rule's model for related rules' models */
    distance?: number;
    /** The rule name */
    ruleName?: string | undefined;
    /** The relationship to the rule */
    relationship?: string | undefined;
    /** The rule category */
    ruleCategory?: string | undefined;
    /** The rule primary model id */
    rulePrimaryModelId?: string | undefined;
    /** The available relationships to this rule */
    availableRelationships?: string[] | undefined;
    /** Whether this rule has a fed by relationship to the rule */
    isRelated?: boolean;
    /** Whether this rule has the same or inherited model id */
    isSibling?: boolean;
    /** Whether this rule's primary model id is linked to a capability of the rule */
    isReferencedCapability?: boolean;
    /** An error to indicate if the dependency will create a circular reference */
    circularDependency?: boolean;
    /** The count of instances that the rule expanded to */
    ruleInstanceCount?: number;
    /** The count of valid instances of this rule */
    validInstanceCount?: number;

    constructor(data?: IRuleDependencyListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            this.isEnabled = _data["isEnabled"];
            this.distance = _data["distance"];
            this.ruleName = _data["ruleName"];
            this.relationship = _data["relationship"];
            this.ruleCategory = _data["ruleCategory"];
            this.rulePrimaryModelId = _data["rulePrimaryModelId"];
            if (Array.isArray(_data["availableRelationships"])) {
                this.availableRelationships = [] as any;
                for (let item of _data["availableRelationships"])
                    this.availableRelationships!.push(item);
            }
            this.isRelated = _data["isRelated"];
            this.isSibling = _data["isSibling"];
            this.isReferencedCapability = _data["isReferencedCapability"];
            this.circularDependency = _data["circularDependency"];
            this.ruleInstanceCount = _data["ruleInstanceCount"];
            this.validInstanceCount = _data["validInstanceCount"];
        }
    }

    static fromJS(data: any): RuleDependencyListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDependencyListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["isEnabled"] = this.isEnabled;
        data["distance"] = this.distance;
        data["ruleName"] = this.ruleName;
        data["relationship"] = this.relationship;
        data["ruleCategory"] = this.ruleCategory;
        data["rulePrimaryModelId"] = this.rulePrimaryModelId;
        if (Array.isArray(this.availableRelationships)) {
            data["availableRelationships"] = [];
            for (let item of this.availableRelationships)
                data["availableRelationships"].push(item);
        }
        data["isRelated"] = this.isRelated;
        data["isSibling"] = this.isSibling;
        data["isReferencedCapability"] = this.isReferencedCapability;
        data["circularDependency"] = this.circularDependency;
        data["ruleInstanceCount"] = this.ruleInstanceCount;
        data["validInstanceCount"] = this.validInstanceCount;
        return data;
    }
}

/** A possible dependency that can be selected for a rule */
export interface IRuleDependencyListItemDto {
    /** The rule id */
    ruleId?: string | undefined;
    /** Whether this dependency is enabled */
    isEnabled?: boolean;
    /** The distance from the rule's model for related rules' models */
    distance?: number;
    /** The rule name */
    ruleName?: string | undefined;
    /** The relationship to the rule */
    relationship?: string | undefined;
    /** The rule category */
    ruleCategory?: string | undefined;
    /** The rule primary model id */
    rulePrimaryModelId?: string | undefined;
    /** The available relationships to this rule */
    availableRelationships?: string[] | undefined;
    /** Whether this rule has a fed by relationship to the rule */
    isRelated?: boolean;
    /** Whether this rule has the same or inherited model id */
    isSibling?: boolean;
    /** Whether this rule's primary model id is linked to a capability of the rule */
    isReferencedCapability?: boolean;
    /** An error to indicate if the dependency will create a circular reference */
    circularDependency?: boolean;
    /** The count of instances that the rule expanded to */
    ruleInstanceCount?: number;
    /** The count of valid instances of this rule */
    validInstanceCount?: number;
}

/** A rule with associated metadata in a DTO for consumption by client-side code */
export class RuleDto implements IRuleDto {
    /** Primary key for Willow.Rules.Model.Rule table */
    id?: string | undefined;
    /** A human-readable name for a Willow.Rules.Model.Rule */
    name?: string | undefined;
    /** A language dictionary that contains the localized name */
    languageNames?: { [key: string]: string; } | undefined;
    /** Category (singular) */
    category?: string | undefined;
    /** Description of the rule */
    description?: string | undefined;
    /** Indicator whether a standard rule for willow */
    isWillowStandard?: boolean;
    /** A language dictionary that contains the localized description */
    languageDescriptions?: { [key: string]: string; } | undefined;
    /** Recommendations for fixing the fault */
    recommendations?: string | undefined;
    /** A language dictionary that contains the localized recommendations */
    languageRecommendations?: { [key: string]: string; } | undefined;
    /** Tags */
    tags?: string[] | undefined;
    twinQuery?: RuleTwinQueryDto;
    /** In a later version, rules will themselves be part of a directed acyclic graph allowing for fault-tree analysis */
    parentIds?: string[] | undefined;
    /** The rule template for this rule */
    templateId?: string | undefined;
    /** The points that this rule uses */
    parameters?: RuleParameterDto[] | undefined;
    /** Impacts scores for cost, comfort, reliability, etc. */
    impactScores?: RuleParameterDto[] | undefined;
    /** A set of filters to exlude twins on expansion */
    filters?: RuleParameterDto[] | undefined;
    /** Constant UI elements */
    elements?: RuleUIElementDto[] | undefined;
    /** A set rule dependencies for this rule */
    dependencies?: RuleDependencyDto[] | undefined;
    /** A set rule triggers for this rule */
    ruleTriggers?: RuleTriggerDto[] | undefined;
    ruleMetadata?: RuleMetadataDto;
    /** Json serialized version for export / import */
    json?: string | undefined;
    /** The primary model id that roots the sub-graph to a system of equipment items */
    primaryModelId?: string | undefined;
    /** The model ID the PrimaryModelId is related to */
    relatedModelId?: string | undefined;
    /** Rule is enabled for posting insights to command */
    commandEnabled?: boolean;
    /** Indicator that a rule is in Draft mode */
    isDraft?: boolean;
    /** Indicator that a rule is used for Calculated Point */
    isCalculatedPoint?: boolean;
    /** Rule is enabled to manage calculated point twins to ADT */
    adtEnabled?: boolean;
    /** The rule template for display purposes */
    templateName?: string | undefined;
    policies?: AuthenticatedUserAndPolicyDecisionsDto;

    constructor(data?: IRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (_data["languageNames"]) {
                this.languageNames = {} as any;
                for (let key in _data["languageNames"]) {
                    if (_data["languageNames"].hasOwnProperty(key))
                        (<any>this.languageNames)![key] = _data["languageNames"][key];
                }
            }
            this.category = _data["category"];
            this.description = _data["description"];
            this.isWillowStandard = _data["isWillowStandard"];
            if (_data["languageDescriptions"]) {
                this.languageDescriptions = {} as any;
                for (let key in _data["languageDescriptions"]) {
                    if (_data["languageDescriptions"].hasOwnProperty(key))
                        (<any>this.languageDescriptions)![key] = _data["languageDescriptions"][key];
                }
            }
            this.recommendations = _data["recommendations"];
            if (_data["languageRecommendations"]) {
                this.languageRecommendations = {} as any;
                for (let key in _data["languageRecommendations"]) {
                    if (_data["languageRecommendations"].hasOwnProperty(key))
                        (<any>this.languageRecommendations)![key] = _data["languageRecommendations"][key];
                }
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.twinQuery = _data["twinQuery"] ? RuleTwinQueryDto.fromJS(_data["twinQuery"]) : <any>undefined;
            if (Array.isArray(_data["parentIds"])) {
                this.parentIds = [] as any;
                for (let item of _data["parentIds"])
                    this.parentIds!.push(item);
            }
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["impactScores"])) {
                this.impactScores = [] as any;
                for (let item of _data["impactScores"])
                    this.impactScores!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(RuleUIElementDto.fromJS(item));
            }
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(RuleDependencyDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleTriggers"])) {
                this.ruleTriggers = [] as any;
                for (let item of _data["ruleTriggers"])
                    this.ruleTriggers!.push(RuleTriggerDto.fromJS(item));
            }
            this.ruleMetadata = _data["ruleMetadata"] ? RuleMetadataDto.fromJS(_data["ruleMetadata"]) : <any>undefined;
            this.json = _data["json"];
            this.primaryModelId = _data["primaryModelId"];
            this.relatedModelId = _data["relatedModelId"];
            this.commandEnabled = _data["commandEnabled"];
            this.isDraft = _data["isDraft"];
            this.isCalculatedPoint = _data["isCalculatedPoint"];
            this.adtEnabled = _data["adtEnabled"];
            this.templateName = _data["templateName"];
            this.policies = _data["policies"] ? AuthenticatedUserAndPolicyDecisionsDto.fromJS(_data["policies"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.languageNames) {
            data["languageNames"] = {};
            for (let key in this.languageNames) {
                if (this.languageNames.hasOwnProperty(key))
                    (<any>data["languageNames"])[key] = (<any>this.languageNames)[key];
            }
        }
        data["category"] = this.category;
        data["description"] = this.description;
        data["isWillowStandard"] = this.isWillowStandard;
        if (this.languageDescriptions) {
            data["languageDescriptions"] = {};
            for (let key in this.languageDescriptions) {
                if (this.languageDescriptions.hasOwnProperty(key))
                    (<any>data["languageDescriptions"])[key] = (<any>this.languageDescriptions)[key];
            }
        }
        data["recommendations"] = this.recommendations;
        if (this.languageRecommendations) {
            data["languageRecommendations"] = {};
            for (let key in this.languageRecommendations) {
                if (this.languageRecommendations.hasOwnProperty(key))
                    (<any>data["languageRecommendations"])[key] = (<any>this.languageRecommendations)[key];
            }
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["twinQuery"] = this.twinQuery ? this.twinQuery.toJSON() : <any>undefined;
        if (Array.isArray(this.parentIds)) {
            data["parentIds"] = [];
            for (let item of this.parentIds)
                data["parentIds"].push(item);
        }
        data["templateId"] = this.templateId;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.impactScores)) {
            data["impactScores"] = [];
            for (let item of this.impactScores)
                data["impactScores"].push(item.toJSON());
        }
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleTriggers)) {
            data["ruleTriggers"] = [];
            for (let item of this.ruleTriggers)
                data["ruleTriggers"].push(item.toJSON());
        }
        data["ruleMetadata"] = this.ruleMetadata ? this.ruleMetadata.toJSON() : <any>undefined;
        data["json"] = this.json;
        data["primaryModelId"] = this.primaryModelId;
        data["relatedModelId"] = this.relatedModelId;
        data["commandEnabled"] = this.commandEnabled;
        data["isDraft"] = this.isDraft;
        data["isCalculatedPoint"] = this.isCalculatedPoint;
        data["adtEnabled"] = this.adtEnabled;
        data["templateName"] = this.templateName;
        data["policies"] = this.policies ? this.policies.toJSON() : <any>undefined;
        return data;
    }
}

/** A rule with associated metadata in a DTO for consumption by client-side code */
export interface IRuleDto {
    /** Primary key for Willow.Rules.Model.Rule table */
    id?: string | undefined;
    /** A human-readable name for a Willow.Rules.Model.Rule */
    name?: string | undefined;
    /** A language dictionary that contains the localized name */
    languageNames?: { [key: string]: string; } | undefined;
    /** Category (singular) */
    category?: string | undefined;
    /** Description of the rule */
    description?: string | undefined;
    /** Indicator whether a standard rule for willow */
    isWillowStandard?: boolean;
    /** A language dictionary that contains the localized description */
    languageDescriptions?: { [key: string]: string; } | undefined;
    /** Recommendations for fixing the fault */
    recommendations?: string | undefined;
    /** A language dictionary that contains the localized recommendations */
    languageRecommendations?: { [key: string]: string; } | undefined;
    /** Tags */
    tags?: string[] | undefined;
    twinQuery?: RuleTwinQueryDto;
    /** In a later version, rules will themselves be part of a directed acyclic graph allowing for fault-tree analysis */
    parentIds?: string[] | undefined;
    /** The rule template for this rule */
    templateId?: string | undefined;
    /** The points that this rule uses */
    parameters?: RuleParameterDto[] | undefined;
    /** Impacts scores for cost, comfort, reliability, etc. */
    impactScores?: RuleParameterDto[] | undefined;
    /** A set of filters to exlude twins on expansion */
    filters?: RuleParameterDto[] | undefined;
    /** Constant UI elements */
    elements?: RuleUIElementDto[] | undefined;
    /** A set rule dependencies for this rule */
    dependencies?: RuleDependencyDto[] | undefined;
    /** A set rule triggers for this rule */
    ruleTriggers?: RuleTriggerDto[] | undefined;
    ruleMetadata?: RuleMetadataDto;
    /** Json serialized version for export / import */
    json?: string | undefined;
    /** The primary model id that roots the sub-graph to a system of equipment items */
    primaryModelId?: string | undefined;
    /** The model ID the PrimaryModelId is related to */
    relatedModelId?: string | undefined;
    /** Rule is enabled for posting insights to command */
    commandEnabled?: boolean;
    /** Indicator that a rule is in Draft mode */
    isDraft?: boolean;
    /** Indicator that a rule is used for Calculated Point */
    isCalculatedPoint?: boolean;
    /** Rule is enabled to manage calculated point twins to ADT */
    adtEnabled?: boolean;
    /** The rule template for display purposes */
    templateName?: string | undefined;
    policies?: AuthenticatedUserAndPolicyDecisionsDto;
}

/** A batched result */
export class RuleDtoBatchDto implements IRuleDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: RuleDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: IRuleDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RuleDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): RuleDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface IRuleDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: RuleDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

/** Tracks execution of a rule */
export class RuleExecutionDto implements IRuleExecutionDto {
    /** Rule Id */
    ruleId?: string | undefined;
    /** Percentage complete */
    percentage?: number;

    constructor(data?: IRuleExecutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): RuleExecutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleExecutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["percentage"] = this.percentage;
        return data;
    }
}

/** Tracks execution of a rule */
export interface IRuleExecutionDto {
    /** Rule Id */
    ruleId?: string | undefined;
    /** Percentage complete */
    percentage?: number;
}

/** A Willow.Rules.Model.RuleInstance DTO */
export class RuleInstanceDto implements IRuleInstanceDto {
    /** Id of the rule instance (a combination of the rule Id and the twin id) */
    readonly id?: string | undefined;
    /** Id of the rule that generated this instance */
    readonly ruleId?: string | undefined;
    /** Name of the rule */
    readonly ruleName?: string | undefined;
    /** Used to keep the descripiton of the rule and any equipment bound properties, e.g. {this.fanSpeed} */
    description?: string | undefined;
    /** Rule recommendations */
    recommendations?: string | undefined;
    /** Template to use for executing the rule */
    readonly ruleTemplate?: string | undefined;
    /** Anchor equipment twin id */
    readonly equipmentId?: string | undefined;
    /** Anchor equipment twin name */
    readonly equipmentName?: string | undefined;
    /** Anchor equipment unique Id */
    readonly equipmentUniqueId?: string | undefined;
    /** Site Id of the anchor equipment */
    readonly siteId?: string | undefined;
    /** Calculated property based on status */
    readonly valid?: boolean;
    status?: RuleInstanceStatus;
    /** Rule instance is disabled */
    readonly disabled?: boolean;
    /** The trend Ids that this instance is looking for in the real time data */
    readonly pointEntityIds?: NamedPointDto[] | undefined;
    /** Rule parameters and their binding to trend ids */
    readonly ruleParametersBound?: RuleParameterBoundDto[] | undefined;
    /** Rule impact scores */
    readonly ruleImpactScoresBound?: RuleParameterBoundDto[] | undefined;
    /** Rule filters bound */
    readonly ruleFiltersBound?: RuleParameterBoundDto[] | undefined;
    /** Rule parameters */
    readonly parameters?: RuleParameterDto[] | undefined;
    /** Rule impact scores */
    readonly impactScores?: RuleParameterDto[] | undefined;
    /** Rule filters */
    readonly filters?: RuleParameterDto[] | undefined;
    /** Rule dependencies */
    readonly ruleDependenciesBound?: RuleDependencyBoundDto[] | undefined;
    /** Rule triggers */
    readonly ruleTriggersBound?: RuleTriggerBoundDto[] | undefined;
    /** Total Rule Dependencies */
    readonly ruleDependencyCount?: number;
    /** Count of triggers for this rule instance */
    readonly triggerCount?: number;
    /** Ascendant locations */
    readonly locations?: TwinLocation[] | undefined;
    /** Entities that feed into the core rule entity */
    readonly feeds?: string[] | undefined;
    /** Entities fed by the core rule entity */
    readonly fedBy?: string[] | undefined;
    /** The output trendId for a calculate point */
    readonly outputTrendId?: string | undefined;
    /** The timezone of the primary equipment in the rule */
    readonly timeZone?: string | undefined;
    /** Indicator that this instance is used for Calculated Point Twin */
    isCalculatedPointTwin?: boolean;
    /** Total number of capabilities linked to the equipment */
    capabilityCount?: number;
    reviewStatus?: ReviewStatus;
    /** Comments for this rule instance */
    comments?: RuleCommentDto[] | undefined;
    /** When the last comment was posted */
    lastCommentPosted?: moment.Moment | undefined;
    /** Total comments posted */
    totalComments?: number;
    /** Tags */
    tags?: string[] | undefined;

    constructor(data?: IRuleInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).ruleId = _data["ruleId"];
            (<any>this).ruleName = _data["ruleName"];
            this.description = _data["description"];
            this.recommendations = _data["recommendations"];
            (<any>this).ruleTemplate = _data["ruleTemplate"];
            (<any>this).equipmentId = _data["equipmentId"];
            (<any>this).equipmentName = _data["equipmentName"];
            (<any>this).equipmentUniqueId = _data["equipmentUniqueId"];
            (<any>this).siteId = _data["siteId"];
            (<any>this).valid = _data["valid"];
            this.status = _data["status"];
            (<any>this).disabled = _data["disabled"];
            if (Array.isArray(_data["pointEntityIds"])) {
                (<any>this).pointEntityIds = [] as any;
                for (let item of _data["pointEntityIds"])
                    (<any>this).pointEntityIds!.push(NamedPointDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleParametersBound"])) {
                (<any>this).ruleParametersBound = [] as any;
                for (let item of _data["ruleParametersBound"])
                    (<any>this).ruleParametersBound!.push(RuleParameterBoundDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleImpactScoresBound"])) {
                (<any>this).ruleImpactScoresBound = [] as any;
                for (let item of _data["ruleImpactScoresBound"])
                    (<any>this).ruleImpactScoresBound!.push(RuleParameterBoundDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleFiltersBound"])) {
                (<any>this).ruleFiltersBound = [] as any;
                for (let item of _data["ruleFiltersBound"])
                    (<any>this).ruleFiltersBound!.push(RuleParameterBoundDto.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                (<any>this).parameters = [] as any;
                for (let item of _data["parameters"])
                    (<any>this).parameters!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["impactScores"])) {
                (<any>this).impactScores = [] as any;
                for (let item of _data["impactScores"])
                    (<any>this).impactScores!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["filters"])) {
                (<any>this).filters = [] as any;
                for (let item of _data["filters"])
                    (<any>this).filters!.push(RuleParameterDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleDependenciesBound"])) {
                (<any>this).ruleDependenciesBound = [] as any;
                for (let item of _data["ruleDependenciesBound"])
                    (<any>this).ruleDependenciesBound!.push(RuleDependencyBoundDto.fromJS(item));
            }
            if (Array.isArray(_data["ruleTriggersBound"])) {
                (<any>this).ruleTriggersBound = [] as any;
                for (let item of _data["ruleTriggersBound"])
                    (<any>this).ruleTriggersBound!.push(RuleTriggerBoundDto.fromJS(item));
            }
            (<any>this).ruleDependencyCount = _data["ruleDependencyCount"];
            (<any>this).triggerCount = _data["triggerCount"];
            if (Array.isArray(_data["locations"])) {
                (<any>this).locations = [] as any;
                for (let item of _data["locations"])
                    (<any>this).locations!.push(TwinLocation.fromJS(item));
            }
            if (Array.isArray(_data["feeds"])) {
                (<any>this).feeds = [] as any;
                for (let item of _data["feeds"])
                    (<any>this).feeds!.push(item);
            }
            if (Array.isArray(_data["fedBy"])) {
                (<any>this).fedBy = [] as any;
                for (let item of _data["fedBy"])
                    (<any>this).fedBy!.push(item);
            }
            (<any>this).outputTrendId = _data["outputTrendId"];
            (<any>this).timeZone = _data["timeZone"];
            this.isCalculatedPointTwin = _data["isCalculatedPointTwin"];
            this.capabilityCount = _data["capabilityCount"];
            this.reviewStatus = _data["reviewStatus"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(RuleCommentDto.fromJS(item));
            }
            this.lastCommentPosted = _data["lastCommentPosted"] ? moment.parseZone(_data["lastCommentPosted"].toString()) : <any>undefined;
            this.totalComments = _data["totalComments"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): RuleInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["description"] = this.description;
        data["recommendations"] = this.recommendations;
        data["ruleTemplate"] = this.ruleTemplate;
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["equipmentUniqueId"] = this.equipmentUniqueId;
        data["siteId"] = this.siteId;
        data["valid"] = this.valid;
        data["status"] = this.status;
        data["disabled"] = this.disabled;
        if (Array.isArray(this.pointEntityIds)) {
            data["pointEntityIds"] = [];
            for (let item of this.pointEntityIds)
                data["pointEntityIds"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleParametersBound)) {
            data["ruleParametersBound"] = [];
            for (let item of this.ruleParametersBound)
                data["ruleParametersBound"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleImpactScoresBound)) {
            data["ruleImpactScoresBound"] = [];
            for (let item of this.ruleImpactScoresBound)
                data["ruleImpactScoresBound"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleFiltersBound)) {
            data["ruleFiltersBound"] = [];
            for (let item of this.ruleFiltersBound)
                data["ruleFiltersBound"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.impactScores)) {
            data["impactScores"] = [];
            for (let item of this.impactScores)
                data["impactScores"].push(item.toJSON());
        }
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleDependenciesBound)) {
            data["ruleDependenciesBound"] = [];
            for (let item of this.ruleDependenciesBound)
                data["ruleDependenciesBound"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleTriggersBound)) {
            data["ruleTriggersBound"] = [];
            for (let item of this.ruleTriggersBound)
                data["ruleTriggersBound"].push(item.toJSON());
        }
        data["ruleDependencyCount"] = this.ruleDependencyCount;
        data["triggerCount"] = this.triggerCount;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.feeds)) {
            data["feeds"] = [];
            for (let item of this.feeds)
                data["feeds"].push(item);
        }
        if (Array.isArray(this.fedBy)) {
            data["fedBy"] = [];
            for (let item of this.fedBy)
                data["fedBy"].push(item);
        }
        data["outputTrendId"] = this.outputTrendId;
        data["timeZone"] = this.timeZone;
        data["isCalculatedPointTwin"] = this.isCalculatedPointTwin;
        data["capabilityCount"] = this.capabilityCount;
        data["reviewStatus"] = this.reviewStatus;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["lastCommentPosted"] = this.lastCommentPosted ? this.lastCommentPosted.toISOString(true) : <any>undefined;
        data["totalComments"] = this.totalComments;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

/** A Willow.Rules.Model.RuleInstance DTO */
export interface IRuleInstanceDto {
    /** Id of the rule instance (a combination of the rule Id and the twin id) */
    id?: string | undefined;
    /** Id of the rule that generated this instance */
    ruleId?: string | undefined;
    /** Name of the rule */
    ruleName?: string | undefined;
    /** Used to keep the descripiton of the rule and any equipment bound properties, e.g. {this.fanSpeed} */
    description?: string | undefined;
    /** Rule recommendations */
    recommendations?: string | undefined;
    /** Template to use for executing the rule */
    ruleTemplate?: string | undefined;
    /** Anchor equipment twin id */
    equipmentId?: string | undefined;
    /** Anchor equipment twin name */
    equipmentName?: string | undefined;
    /** Anchor equipment unique Id */
    equipmentUniqueId?: string | undefined;
    /** Site Id of the anchor equipment */
    siteId?: string | undefined;
    /** Calculated property based on status */
    valid?: boolean;
    status?: RuleInstanceStatus;
    /** Rule instance is disabled */
    disabled?: boolean;
    /** The trend Ids that this instance is looking for in the real time data */
    pointEntityIds?: NamedPointDto[] | undefined;
    /** Rule parameters and their binding to trend ids */
    ruleParametersBound?: RuleParameterBoundDto[] | undefined;
    /** Rule impact scores */
    ruleImpactScoresBound?: RuleParameterBoundDto[] | undefined;
    /** Rule filters bound */
    ruleFiltersBound?: RuleParameterBoundDto[] | undefined;
    /** Rule parameters */
    parameters?: RuleParameterDto[] | undefined;
    /** Rule impact scores */
    impactScores?: RuleParameterDto[] | undefined;
    /** Rule filters */
    filters?: RuleParameterDto[] | undefined;
    /** Rule dependencies */
    ruleDependenciesBound?: RuleDependencyBoundDto[] | undefined;
    /** Rule triggers */
    ruleTriggersBound?: RuleTriggerBoundDto[] | undefined;
    /** Total Rule Dependencies */
    ruleDependencyCount?: number;
    /** Count of triggers for this rule instance */
    triggerCount?: number;
    /** Ascendant locations */
    locations?: TwinLocation[] | undefined;
    /** Entities that feed into the core rule entity */
    feeds?: string[] | undefined;
    /** Entities fed by the core rule entity */
    fedBy?: string[] | undefined;
    /** The output trendId for a calculate point */
    outputTrendId?: string | undefined;
    /** The timezone of the primary equipment in the rule */
    timeZone?: string | undefined;
    /** Indicator that this instance is used for Calculated Point Twin */
    isCalculatedPointTwin?: boolean;
    /** Total number of capabilities linked to the equipment */
    capabilityCount?: number;
    reviewStatus?: ReviewStatus;
    /** Comments for this rule instance */
    comments?: RuleCommentDto[] | undefined;
    /** When the last comment was posted */
    lastCommentPosted?: moment.Moment | undefined;
    /** Total comments posted */
    totalComments?: number;
    /** Tags */
    tags?: string[] | undefined;
}

/** A batched result */
export class RuleInstanceDtoBatchDto implements IRuleInstanceDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: RuleInstanceDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: IRuleInstanceDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RuleInstanceDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): RuleInstanceDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleInstanceDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface IRuleInstanceDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: RuleInstanceDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

/** A lite version of a rule instance */
export class RuleInstanceListItemDto implements IRuleInstanceListItemDto {
    /** Id of the rule instance (a combination of the rule Id and the twin id) */
    id?: string | undefined;
    /** Anchor equipment twin id */
    equipmentId?: string | undefined;
    /** Anchor equipment twin name */
    equipmentName?: string | undefined;
    status?: RuleInstanceStatus;

    constructor(data?: IRuleInstanceListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RuleInstanceListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleInstanceListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["status"] = this.status;
        return data;
    }
}

/** A lite version of a rule instance */
export interface IRuleInstanceListItemDto {
    /** Id of the rule instance (a combination of the rule Id and the twin id) */
    id?: string | undefined;
    /** Anchor equipment twin id */
    equipmentId?: string | undefined;
    /** Anchor equipment twin name */
    equipmentName?: string | undefined;
    status?: RuleInstanceStatus;
}

/** Properties that can be updated and ids of rule instances to be updated */
export class RuleInstancePropertiesDto implements IRuleInstancePropertiesDto {
    /** Ids of rule instances to be updated */
    ids?: string[] | undefined;
    /** Rule instance is disabled */
    disabled?: string | undefined;
    /** Rule instance review status */
    reviewStatus?: string | undefined;
    /** Comment to be added to rule instance */
    comment?: string | undefined;

    constructor(data?: IRuleInstancePropertiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.disabled = _data["disabled"];
            this.reviewStatus = _data["reviewStatus"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): RuleInstancePropertiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleInstancePropertiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["disabled"] = this.disabled;
        data["reviewStatus"] = this.reviewStatus;
        data["comment"] = this.comment;
        return data;
    }
}

/** Properties that can be updated and ids of rule instances to be updated */
export interface IRuleInstancePropertiesDto {
    /** Ids of rule instances to be updated */
    ids?: string[] | undefined;
    /** Rule instance is disabled */
    disabled?: string | undefined;
    /** Rule instance review status */
    reviewStatus?: string | undefined;
    /** Comment to be added to rule instance */
    comment?: string | undefined;
}

export enum RuleInstanceStatus {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

/** Metadata for a rule, updated in real-time as rule instances are created by the back-end */
export class RuleMetadataDto implements IRuleMetadataDto {
    /** The version of the rule. Usually increments for rule expression updates */
    version?: number;
    /** Count of how many commands were generated */
    commandsGenerated?: number;
    /** The ID of the rule for which this metadata was created */
    id?: string | undefined;
    /** The user who created the rule */
    createdBy?: string | undefined;
    /** The user who last modified the rule */
    modifiedBy?: string | undefined;
    /** The last time the rule was modified */
    lastModified?: moment.Moment;
    /** When the rule was created */
    created?: moment.Moment;
    ruleInstanceStatus?: RuleInstanceStatus;
    /** Scan started */
    scanStarted?: boolean;
    /** Counts are updated */
    scanComplete?: boolean;
    scanState?: ScanState;
    /** The last scan error */
    scanError?: string | undefined;
    /** Datetimeoffset when the scan state was last updated */
    scanStateAsOf?: moment.Moment;
    /** The count of instances that the rule expanded to */
    ruleInstanceCount?: number;
    /** The count of valid instances of this rule */
    validInstanceCount?: number;
    /** Count of how many FAULTED insights this rule has generated */
    insightsGenerated?: number;
    /** The earliest date the rule has ever executed against */
    earliestExecutionDate?: moment.Moment;
    /** Indicates wheter execution has ever run on this rule */
    hasExecuted?: boolean;
    /** A list of model ids found in the rule expressions */
    modelIds?: string[] | undefined;
    /** Audit logs */
    logs?: AuditLogEntryDto[] | undefined;

    constructor(data?: IRuleMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.commandsGenerated = _data["commandsGenerated"];
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.lastModified = _data["lastModified"] ? moment.parseZone(_data["lastModified"].toString()) : <any>undefined;
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.ruleInstanceStatus = _data["ruleInstanceStatus"];
            this.scanStarted = _data["scanStarted"];
            this.scanComplete = _data["scanComplete"];
            this.scanState = _data["scanState"];
            this.scanError = _data["scanError"];
            this.scanStateAsOf = _data["scanStateAsOf"] ? moment.parseZone(_data["scanStateAsOf"].toString()) : <any>undefined;
            this.ruleInstanceCount = _data["ruleInstanceCount"];
            this.validInstanceCount = _data["validInstanceCount"];
            this.insightsGenerated = _data["insightsGenerated"];
            this.earliestExecutionDate = _data["earliestExecutionDate"] ? moment.parseZone(_data["earliestExecutionDate"].toString()) : <any>undefined;
            this.hasExecuted = _data["hasExecuted"];
            if (Array.isArray(_data["modelIds"])) {
                this.modelIds = [] as any;
                for (let item of _data["modelIds"])
                    this.modelIds!.push(item);
            }
            if (Array.isArray(_data["logs"])) {
                this.logs = [] as any;
                for (let item of _data["logs"])
                    this.logs!.push(AuditLogEntryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuleMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["commandsGenerated"] = this.commandsGenerated;
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString(true) : <any>undefined;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["ruleInstanceStatus"] = this.ruleInstanceStatus;
        data["scanStarted"] = this.scanStarted;
        data["scanComplete"] = this.scanComplete;
        data["scanState"] = this.scanState;
        data["scanError"] = this.scanError;
        data["scanStateAsOf"] = this.scanStateAsOf ? this.scanStateAsOf.toISOString(true) : <any>undefined;
        data["ruleInstanceCount"] = this.ruleInstanceCount;
        data["validInstanceCount"] = this.validInstanceCount;
        data["insightsGenerated"] = this.insightsGenerated;
        data["earliestExecutionDate"] = this.earliestExecutionDate ? this.earliestExecutionDate.toISOString(true) : <any>undefined;
        data["hasExecuted"] = this.hasExecuted;
        if (Array.isArray(this.modelIds)) {
            data["modelIds"] = [];
            for (let item of this.modelIds)
                data["modelIds"].push(item);
        }
        if (Array.isArray(this.logs)) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item.toJSON());
        }
        return data;
    }
}

/** Metadata for a rule, updated in real-time as rule instances are created by the back-end */
export interface IRuleMetadataDto {
    /** The version of the rule. Usually increments for rule expression updates */
    version?: number;
    /** Count of how many commands were generated */
    commandsGenerated?: number;
    /** The ID of the rule for which this metadata was created */
    id?: string | undefined;
    /** The user who created the rule */
    createdBy?: string | undefined;
    /** The user who last modified the rule */
    modifiedBy?: string | undefined;
    /** The last time the rule was modified */
    lastModified?: moment.Moment;
    /** When the rule was created */
    created?: moment.Moment;
    ruleInstanceStatus?: RuleInstanceStatus;
    /** Scan started */
    scanStarted?: boolean;
    /** Counts are updated */
    scanComplete?: boolean;
    scanState?: ScanState;
    /** The last scan error */
    scanError?: string | undefined;
    /** Datetimeoffset when the scan state was last updated */
    scanStateAsOf?: moment.Moment;
    /** The count of instances that the rule expanded to */
    ruleInstanceCount?: number;
    /** The count of valid instances of this rule */
    validInstanceCount?: number;
    /** Count of how many FAULTED insights this rule has generated */
    insightsGenerated?: number;
    /** The earliest date the rule has ever executed against */
    earliestExecutionDate?: moment.Moment;
    /** Indicates wheter execution has ever run on this rule */
    hasExecuted?: boolean;
    /** A list of model ids found in the rule expressions */
    modelIds?: string[] | undefined;
    /** Audit logs */
    logs?: AuditLogEntryDto[] | undefined;
}

/** A rule parameter bound to a set of trend ids */
export class RuleParameterBoundDto implements IRuleParameterBoundDto {
    /** The field Id of the field that was used, e.g. "Binding" even though it's called "Temperature" in the UI */
    fieldId?: string | undefined;
    /** Name */
    name?: string | undefined;
    /** Units */
    units?: string | undefined;
    /** Point expression to find the right capability from the sub-graph */
    pointExpression?: string | undefined;
    /** Point expression translated for mapped point entity ids */
    pointExpressionExplained?: string | undefined;
    status?: RuleInstanceStatus;
    cumulativeSetting?: CumulativeType;
    /** Is the bound parameter auto-generated */
    isAutoGenerated?: boolean;

    constructor(data?: IRuleParameterBoundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.name = _data["name"];
            this.units = _data["units"];
            this.pointExpression = _data["pointExpression"];
            this.pointExpressionExplained = _data["pointExpressionExplained"];
            this.status = _data["status"];
            this.cumulativeSetting = _data["cumulativeSetting"];
            this.isAutoGenerated = _data["isAutoGenerated"];
        }
    }

    static fromJS(data: any): RuleParameterBoundDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleParameterBoundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["name"] = this.name;
        data["units"] = this.units;
        data["pointExpression"] = this.pointExpression;
        data["pointExpressionExplained"] = this.pointExpressionExplained;
        data["status"] = this.status;
        data["cumulativeSetting"] = this.cumulativeSetting;
        data["isAutoGenerated"] = this.isAutoGenerated;
        return data;
    }
}

/** A rule parameter bound to a set of trend ids */
export interface IRuleParameterBoundDto {
    /** The field Id of the field that was used, e.g. "Binding" even though it's called "Temperature" in the UI */
    fieldId?: string | undefined;
    /** Name */
    name?: string | undefined;
    /** Units */
    units?: string | undefined;
    /** Point expression to find the right capability from the sub-graph */
    pointExpression?: string | undefined;
    /** Point expression translated for mapped point entity ids */
    pointExpressionExplained?: string | undefined;
    status?: RuleInstanceStatus;
    cumulativeSetting?: CumulativeType;
    /** Is the bound parameter auto-generated */
    isAutoGenerated?: boolean;
}

/** Rule parameter DTO for UI */
export class RuleParameterDto implements IRuleParameterDto {
    /** Gets the name of the Willow.Rules.Model.RuleParameter */
    name?: string | undefined;
    /** Gets the Id */
    fieldId?: string | undefined;
    /** Gets the serialized expression for the Willow.Rules.Model.RuleParameter */
    pointExpression?: string | undefined;
    /** An optional unit of measure for the parameter */
    units?: string | undefined;
    cumulativeSetting?: CumulativeType;

    constructor(data?: IRuleParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fieldId = _data["fieldId"];
            this.pointExpression = _data["pointExpression"];
            this.units = _data["units"];
            this.cumulativeSetting = _data["cumulativeSetting"];
        }
    }

    static fromJS(data: any): RuleParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fieldId"] = this.fieldId;
        data["pointExpression"] = this.pointExpression;
        data["units"] = this.units;
        data["cumulativeSetting"] = this.cumulativeSetting;
        return data;
    }
}

/** Rule parameter DTO for UI */
export interface IRuleParameterDto {
    /** Gets the name of the Willow.Rules.Model.RuleParameter */
    name?: string | undefined;
    /** Gets the Id */
    fieldId?: string | undefined;
    /** Gets the serialized expression for the Willow.Rules.Model.RuleParameter */
    pointExpression?: string | undefined;
    /** An optional unit of measure for the parameter */
    units?: string | undefined;
    cumulativeSetting?: CumulativeType;
}

/** A reference that may exist for a global */
export class RuleReferenceDto implements IRuleReferenceDto {
    /** Is this a rule reference */
    referenceType?: string | undefined;
    /** The referenced object's id */
    id?: string | undefined;
    /** The referenced object's name */
    name?: string | undefined;

    constructor(data?: IRuleReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceType = _data["referenceType"];
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RuleReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceType"] = this.referenceType;
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** A reference that may exist for a global */
export interface IRuleReferenceDto {
    /** Is this a rule reference */
    referenceType?: string | undefined;
    /** The referenced object's id */
    id?: string | undefined;
    /** The referenced object's name */
    name?: string | undefined;
}

/** Request object for simulation */
export class RuleSimulationRequest implements IRuleSimulationRequest {
    /** Rule id for existing rule */
    ruleId?: string | undefined;
    /** Equipment id to run simuaiton against */
    equipmentId?: string | undefined;
    /** Start time for simulation */
    startTime?: moment.Moment;
    /** End time for simulation */
    endTime?: moment.Moment;
    /** Use existing actor data */
    useExistingData?: boolean;
    /** Optionally update rule from rule dto in request before simulation */
    updateRule?: boolean;
    /** Optionally generate calc input values for point */
    generatePointTracking?: boolean;
    /** Optionally show auto generated variables */
    showAutoVariables?: boolean;
    /** Indicates whetehr compression optmisations are done */
    optimizeCompression?: boolean;
    /** Indicates wheter compression is enabled */
    enableCompression?: boolean;
    /** Optionally exclude optmisations, by defualt true */
    optimizeExpression?: boolean;
    /** Optionally applies lilmits to timeseries and variables */
    applyLimits?: boolean;
    /** Optionally ignore 24hr point limit */
    skipMaxPointLimit?: boolean;
    rule?: RuleDto;
    global?: GlobalVariableDto;

    constructor(data?: IRuleSimulationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            this.equipmentId = _data["equipmentId"];
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment.parseZone(_data["endTime"].toString()) : <any>undefined;
            this.useExistingData = _data["useExistingData"];
            this.updateRule = _data["updateRule"];
            this.generatePointTracking = _data["generatePointTracking"];
            this.showAutoVariables = _data["showAutoVariables"];
            this.optimizeCompression = _data["optimizeCompression"];
            this.enableCompression = _data["enableCompression"];
            this.optimizeExpression = _data["optimizeExpression"];
            this.applyLimits = _data["applyLimits"];
            this.skipMaxPointLimit = _data["skipMaxPointLimit"];
            this.rule = _data["rule"] ? RuleDto.fromJS(_data["rule"]) : <any>undefined;
            this.global = _data["global"] ? GlobalVariableDto.fromJS(_data["global"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuleSimulationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RuleSimulationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["equipmentId"] = this.equipmentId;
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString(true) : <any>undefined;
        data["useExistingData"] = this.useExistingData;
        data["updateRule"] = this.updateRule;
        data["generatePointTracking"] = this.generatePointTracking;
        data["showAutoVariables"] = this.showAutoVariables;
        data["optimizeCompression"] = this.optimizeCompression;
        data["enableCompression"] = this.enableCompression;
        data["optimizeExpression"] = this.optimizeExpression;
        data["applyLimits"] = this.applyLimits;
        data["skipMaxPointLimit"] = this.skipMaxPointLimit;
        data["rule"] = this.rule ? this.rule.toJSON() : <any>undefined;
        data["global"] = this.global ? this.global.toJSON() : <any>undefined;
        return data;
    }
}

/** Request object for simulation */
export interface IRuleSimulationRequest {
    /** Rule id for existing rule */
    ruleId?: string | undefined;
    /** Equipment id to run simuaiton against */
    equipmentId?: string | undefined;
    /** Start time for simulation */
    startTime?: moment.Moment;
    /** End time for simulation */
    endTime?: moment.Moment;
    /** Use existing actor data */
    useExistingData?: boolean;
    /** Optionally update rule from rule dto in request before simulation */
    updateRule?: boolean;
    /** Optionally generate calc input values for point */
    generatePointTracking?: boolean;
    /** Optionally show auto generated variables */
    showAutoVariables?: boolean;
    /** Indicates whetehr compression optmisations are done */
    optimizeCompression?: boolean;
    /** Indicates wheter compression is enabled */
    enableCompression?: boolean;
    /** Optionally exclude optmisations, by defualt true */
    optimizeExpression?: boolean;
    /** Optionally applies lilmits to timeseries and variables */
    applyLimits?: boolean;
    /** Optionally ignore 24hr point limit */
    skipMaxPointLimit?: boolean;
    rule?: RuleDto;
    global?: GlobalVariableDto;
}

/** A rule template id and name */
export class RuleTemplateDto implements IRuleTemplateDto {
    /** Id of rule template */
    id?: string | undefined;
    /** Name of rule template */
    name?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** Sample elements */
    elements?: RuleUIElementDto[] | undefined;
    /** Parameters */
    parameters?: RuleUIElementDto[] | undefined;
    /** Scores */
    impactScores?: RuleUIElementDto[] | undefined;

    constructor(data?: IRuleTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(RuleUIElementDto.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(RuleUIElementDto.fromJS(item));
            }
            if (Array.isArray(_data["impactScores"])) {
                this.impactScores = [] as any;
                for (let item of _data["impactScores"])
                    this.impactScores!.push(RuleUIElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuleTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.impactScores)) {
            data["impactScores"] = [];
            for (let item of this.impactScores)
                data["impactScores"].push(item.toJSON());
        }
        return data;
    }
}

/** A rule template id and name */
export interface IRuleTemplateDto {
    /** Id of rule template */
    id?: string | undefined;
    /** Name of rule template */
    name?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** Sample elements */
    elements?: RuleUIElementDto[] | undefined;
    /** Parameters */
    parameters?: RuleUIElementDto[] | undefined;
    /** Scores */
    impactScores?: RuleUIElementDto[] | undefined;
}

/** A RulesEngine.Web.RuleTriggerBoundDto represents an output trigger for a rule instance */
export class RuleTriggerBoundDto implements IRuleTriggerBoundDto {
    /** The id of the trigger */
    id?: string | undefined;
    /** The name of the trigger */
    name?: string | undefined;
    condition?: RuleParameterBoundDto;
    value?: RuleParameterBoundDto;
    point?: RuleParameterBoundDto;
    /** The twin id for command triggers */
    twinId?: string | undefined;
    /** The twin name for command triggers */
    twinName?: string | undefined;
    /** The external id of the twin */
    externalId?: string | undefined;
    /** The connector id of the twin */
    connectorId?: string | undefined;
    status?: RuleInstanceStatus;
    /** Additional twin relationship information sent to command */
    relationships?: RuleTriggerBoundRelationshipDto[] | undefined;

    constructor(data?: IRuleTriggerBoundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.condition = _data["condition"] ? RuleParameterBoundDto.fromJS(_data["condition"]) : <any>undefined;
            this.value = _data["value"] ? RuleParameterBoundDto.fromJS(_data["value"]) : <any>undefined;
            this.point = _data["point"] ? RuleParameterBoundDto.fromJS(_data["point"]) : <any>undefined;
            this.twinId = _data["twinId"];
            this.twinName = _data["twinName"];
            this.externalId = _data["externalId"];
            this.connectorId = _data["connectorId"];
            this.status = _data["status"];
            if (Array.isArray(_data["relationships"])) {
                this.relationships = [] as any;
                for (let item of _data["relationships"])
                    this.relationships!.push(RuleTriggerBoundRelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuleTriggerBoundDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTriggerBoundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["point"] = this.point ? this.point.toJSON() : <any>undefined;
        data["twinId"] = this.twinId;
        data["twinName"] = this.twinName;
        data["externalId"] = this.externalId;
        data["connectorId"] = this.connectorId;
        data["status"] = this.status;
        if (Array.isArray(this.relationships)) {
            data["relationships"] = [];
            for (let item of this.relationships)
                data["relationships"].push(item.toJSON());
        }
        return data;
    }
}

/** A RulesEngine.Web.RuleTriggerBoundDto represents an output trigger for a rule instance */
export interface IRuleTriggerBoundDto {
    /** The id of the trigger */
    id?: string | undefined;
    /** The name of the trigger */
    name?: string | undefined;
    condition?: RuleParameterBoundDto;
    value?: RuleParameterBoundDto;
    point?: RuleParameterBoundDto;
    /** The twin id for command triggers */
    twinId?: string | undefined;
    /** The twin name for command triggers */
    twinName?: string | undefined;
    /** The external id of the twin */
    externalId?: string | undefined;
    /** The connector id of the twin */
    connectorId?: string | undefined;
    status?: RuleInstanceStatus;
    /** Additional twin relationship information sent to command */
    relationships?: RuleTriggerBoundRelationshipDto[] | undefined;
}

/** Additionaltwin relationship information sent to command */
export class RuleTriggerBoundRelationshipDto implements IRuleTriggerBoundRelationshipDto {
    /** Gets or sets the ID of the twin at the other end of the relationship. */
    twinId?: string | undefined;
    /** Gets or sets the name of the twin at the other end of the relationship. */
    twinName?: string | undefined;
    /** Gets or sets the model ID of the twin at the other end of the relationship. */
    modelId?: string | undefined;
    /** Gets or sets the type of relationship between the two twins. */
    relationshipType?: string | undefined;

    constructor(data?: IRuleTriggerBoundRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.twinName = _data["twinName"];
            this.modelId = _data["modelId"];
            this.relationshipType = _data["relationshipType"];
        }
    }

    static fromJS(data: any): RuleTriggerBoundRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTriggerBoundRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["twinName"] = this.twinName;
        data["modelId"] = this.modelId;
        data["relationshipType"] = this.relationshipType;
        return data;
    }
}

/** Additionaltwin relationship information sent to command */
export interface IRuleTriggerBoundRelationshipDto {
    /** Gets or sets the ID of the twin at the other end of the relationship. */
    twinId?: string | undefined;
    /** Gets or sets the name of the twin at the other end of the relationship. */
    twinName?: string | undefined;
    /** Gets or sets the model ID of the twin at the other end of the relationship. */
    modelId?: string | undefined;
    /** Gets or sets the type of relationship between the two twins. */
    relationshipType?: string | undefined;
}

/** Dto for A Willow.Rules.Model.RuleTrigger */
export class RuleTriggerDto implements IRuleTriggerDto {
    /** The name of the trigger */
    name?: string | undefined;
    condition?: RuleParameterDto;
    triggerType?: RuleTriggerType;
    point?: RuleParameterDto;
    value?: RuleParameterDto;
    commandType?: CommandType;

    constructor(data?: IRuleTriggerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.condition = _data["condition"] ? RuleParameterDto.fromJS(_data["condition"]) : <any>undefined;
            this.triggerType = _data["triggerType"];
            this.point = _data["point"] ? RuleParameterDto.fromJS(_data["point"]) : <any>undefined;
            this.value = _data["value"] ? RuleParameterDto.fromJS(_data["value"]) : <any>undefined;
            this.commandType = _data["commandType"];
        }
    }

    static fromJS(data: any): RuleTriggerDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTriggerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        data["triggerType"] = this.triggerType;
        data["point"] = this.point ? this.point.toJSON() : <any>undefined;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["commandType"] = this.commandType;
        return data;
    }
}

/** Dto for A Willow.Rules.Model.RuleTrigger */
export interface IRuleTriggerDto {
    /** The name of the trigger */
    name?: string | undefined;
    condition?: RuleParameterDto;
    triggerType?: RuleTriggerType;
    point?: RuleParameterDto;
    value?: RuleParameterDto;
    commandType?: CommandType;
}

export enum RuleTriggerType {
    _1 = 1,
}

/** Dto form of a Willow.Rules.Model.RuleTwinQuery */
export class RuleTwinQueryDto implements IRuleTwinQueryDto {
    /** Model Ids involved in Query, primary model Id at index []zero */
    readonly modelIds?: string[] | undefined;

    constructor(data?: IRuleTwinQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["modelIds"])) {
                (<any>this).modelIds = [] as any;
                for (let item of _data["modelIds"])
                    (<any>this).modelIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RuleTwinQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTwinQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.modelIds)) {
            data["modelIds"] = [];
            for (let item of this.modelIds)
                data["modelIds"].push(item);
        }
        return data;
    }
}

/** Dto form of a Willow.Rules.Model.RuleTwinQuery */
export interface IRuleTwinQueryDto {
    /** Model Ids involved in Query, primary model Id at index []zero */
    modelIds?: string[] | undefined;
}

/** An input field in the rules UI */
export class RuleUIElementDto implements IRuleUIElementDto {
    /** Id for persistence */
    id?: string | undefined;
    /** Name to display in UI */
    name?: string | undefined;
    /** Units of measure */
    units?: string | undefined;
    /** The value */
    valueString?: string | undefined;
    /** The int value */
    valueInt?: number;
    /** The double value */
    valueDouble?: number;
    elementType?: RuleUIElementType;

    constructor(data?: IRuleUIElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.units = _data["units"];
            this.valueString = _data["valueString"];
            this.valueInt = _data["valueInt"];
            this.valueDouble = _data["valueDouble"];
            this.elementType = _data["elementType"];
        }
    }

    static fromJS(data: any): RuleUIElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleUIElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["units"] = this.units;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["valueDouble"] = this.valueDouble;
        data["elementType"] = this.elementType;
        return data;
    }
}

/** An input field in the rules UI */
export interface IRuleUIElementDto {
    /** Id for persistence */
    id?: string | undefined;
    /** Name to display in UI */
    name?: string | undefined;
    /** Units of measure */
    units?: string | undefined;
    /** The value */
    valueString?: string | undefined;
    /** The int value */
    valueInt?: number;
    /** The double value */
    valueDouble?: number;
    elementType?: RuleUIElementType;
}

export enum RuleUIElementType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

/** Rule upload result DTO for consumption by client-side code */
export class RuleUploadResultDto implements IRuleUploadResultDto {
    /** List of failed file names */
    failures?: string[] | undefined;
    /** List of duplicate file names */
    duplicates?: string[] | undefined;
    /** Number of rules processed */
    processedCount?: number;
    /** Number of unique rules */
    uniqueCount?: number;
    /** Number of duplicates */
    duplicateCount?: number;
    /** Number of failures */
    failureCount?: number;
    /** Overall status of process */
    success?: boolean;

    constructor(data?: IRuleUploadResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["failures"])) {
                this.failures = [] as any;
                for (let item of _data["failures"])
                    this.failures!.push(item);
            }
            if (Array.isArray(_data["duplicates"])) {
                this.duplicates = [] as any;
                for (let item of _data["duplicates"])
                    this.duplicates!.push(item);
            }
            this.processedCount = _data["processedCount"];
            this.uniqueCount = _data["uniqueCount"];
            this.duplicateCount = _data["duplicateCount"];
            this.failureCount = _data["failureCount"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RuleUploadResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleUploadResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.failures)) {
            data["failures"] = [];
            for (let item of this.failures)
                data["failures"].push(item);
        }
        if (Array.isArray(this.duplicates)) {
            data["duplicates"] = [];
            for (let item of this.duplicates)
                data["duplicates"].push(item);
        }
        data["processedCount"] = this.processedCount;
        data["uniqueCount"] = this.uniqueCount;
        data["duplicateCount"] = this.duplicateCount;
        data["failureCount"] = this.failureCount;
        data["success"] = this.success;
        return data;
    }
}

/** Rule upload result DTO for consumption by client-side code */
export interface IRuleUploadResultDto {
    /** List of failed file names */
    failures?: string[] | undefined;
    /** List of duplicate file names */
    duplicates?: string[] | undefined;
    /** Number of rules processed */
    processedCount?: number;
    /** Number of unique rules */
    uniqueCount?: number;
    /** Number of duplicates */
    duplicateCount?: number;
    /** Number of failures */
    failureCount?: number;
    /** Overall status of process */
    success?: boolean;
}

export enum ScanState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

/** One search result */
export class SearchLineDto implements ISearchLineDto {
    /** Type of search result */
    type?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** The key which is globally unique, suitable for a react key */
    id?: string | undefined;
    /** The Id for use in a link to the thing */
    linkId?: string | undefined;
    /** Score from Azure */
    score?: number;
    /** Parent chain by locatedIn and isPartOf */
    locations?: TwinLocation[] | undefined;

    constructor(data?: ISearchLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.linkId = _data["linkId"];
            this.score = _data["score"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        data["linkId"] = this.linkId;
        data["score"] = this.score;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data;
    }
}

/** One search result */
export interface ISearchLineDto {
    /** Type of search result */
    type?: string | undefined;
    /** Description */
    description?: string | undefined;
    /** The key which is globally unique, suitable for a react key */
    id?: string | undefined;
    /** The Id for use in a link to the thing */
    linkId?: string | undefined;
    /** Score from Azure */
    score?: number;
    /** Parent chain by locatedIn and isPartOf */
    locations?: TwinLocation[] | undefined;
}

/** Result of searching */
export class SearchResultDto implements ISearchResultDto {
    /** The incoming query */
    query?: string | undefined;
    /** The results */
    results?: SearchLineDto[] | undefined;

    constructor(data?: ISearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.query = _data["query"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SearchLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** Result of searching */
export interface ISearchResultDto {
    /** The incoming query */
    query?: string | undefined;
    /** The results */
    results?: SearchLineDto[] | undefined;
}

/** Sort-lived token for file download requests */
export class ShortLivedTokenDto implements IShortLivedTokenDto {
    /** The crypto random token */
    token?: string | undefined;

    constructor(data?: IShortLivedTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ShortLivedTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortLivedTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

/** Sort-lived token for file download requests */
export interface IShortLivedTokenDto {
    /** The crypto random token */
    token?: string | undefined;
}

/** A execution simulation result */
export class SimulationResultDto implements ISimulationResultDto {
    /** An error message if any */
    error?: string | undefined;
    /** An error message if any */
    warning?: string | undefined;
    insight?: InsightDto;
    /** The commands generated by the simulation */
    commands?: CommandDto[] | undefined;
    ruleInstance?: RuleInstanceDto;
    timeSeriesData?: TimeSeriesDataDto;

    constructor(data?: ISimulationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.warning = _data["warning"];
            this.insight = _data["insight"] ? InsightDto.fromJS(_data["insight"]) : <any>undefined;
            if (Array.isArray(_data["commands"])) {
                this.commands = [] as any;
                for (let item of _data["commands"])
                    this.commands!.push(CommandDto.fromJS(item));
            }
            this.ruleInstance = _data["ruleInstance"] ? RuleInstanceDto.fromJS(_data["ruleInstance"]) : <any>undefined;
            this.timeSeriesData = _data["timeSeriesData"] ? TimeSeriesDataDto.fromJS(_data["timeSeriesData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimulationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimulationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["warning"] = this.warning;
        data["insight"] = this.insight ? this.insight.toJSON() : <any>undefined;
        if (Array.isArray(this.commands)) {
            data["commands"] = [];
            for (let item of this.commands)
                data["commands"].push(item.toJSON());
        }
        data["ruleInstance"] = this.ruleInstance ? this.ruleInstance.toJSON() : <any>undefined;
        data["timeSeriesData"] = this.timeSeriesData ? this.timeSeriesData.toJSON() : <any>undefined;
        return data;
    }
}

/** A execution simulation result */
export interface ISimulationResultDto {
    /** An error message if any */
    error?: string | undefined;
    /** An error message if any */
    warning?: string | undefined;
    insight?: InsightDto;
    /** The commands generated by the simulation */
    commands?: CommandDto[] | undefined;
    ruleInstance?: RuleInstanceDto;
    timeSeriesData?: TimeSeriesDataDto;
}

export class SortSpecificationDto implements ISortSpecificationDto {
    field?: string | undefined;
    sort?: string | undefined;

    constructor(data?: ISortSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): SortSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SortSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["sort"] = this.sort;
        return data;
    }
}

export interface ISortSpecificationDto {
    field?: string | undefined;
    sort?: string | undefined;
}

/** Information about the state of the Rules Engine system */
export class SystemSummaryDto implements ISystemSummaryDto {
    /** When twins and relationships counts were set */
    adtAsOfDate?: moment.Moment;
    /** How many twins */
    countTwins?: number;
    /** How many twins with trend Ids */
    countCapabilities?: number;
    /** How many relationships */
    countRelationships?: number;
    /** How many rules */
    countRules?: number;
    /** How many rule instances */
    countRuleInstances?: number;
    /** How many calculated points */
    countCalculatedPoints?: number;
    /** How many live data points are coming in */
    countLiveData?: number;
    /** How many time series buffers */
    countTimeSeriesBuffers?: number;
    /** How many commands in total */
    countCommands?: number;
    /** How many commands are triggering */
    countCommandsTriggering?: number;
    /** How many insights in the faulted state */
    countInsightsFaulted?: number;
    /** How many insights invalid */
    countInsightsInValid?: number;
    /** How many insights in healthy state */
    countInsightsHealthy?: number;
    /** How many insights flowing to command */
    countCommandInsights?: number;
    /** How many data quality reports being sent */
    countDataQualityReports?: number;
    /** Speed of execution */
    speed?: number;
    /** Last time stamp processed */
    lastTimeStamp?: moment.Moment | undefined;
    /** Health checks flattened */
    health?: HealthCheckDto[] | undefined;
    /** Insights by model type */
    insightsByModel?: { [key: string]: number; } | undefined;
    /** Commands by model type */
    commandsByModel?: { [key: string]: number; } | undefined;
    /** Model summary */
    modelSummary?: ADTModelSummary[] | undefined;

    constructor(data?: ISystemSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adtAsOfDate = _data["adtAsOfDate"] ? moment.parseZone(_data["adtAsOfDate"].toString()) : <any>undefined;
            this.countTwins = _data["countTwins"];
            this.countCapabilities = _data["countCapabilities"];
            this.countRelationships = _data["countRelationships"];
            this.countRules = _data["countRules"];
            this.countRuleInstances = _data["countRuleInstances"];
            this.countCalculatedPoints = _data["countCalculatedPoints"];
            this.countLiveData = _data["countLiveData"];
            this.countTimeSeriesBuffers = _data["countTimeSeriesBuffers"];
            this.countCommands = _data["countCommands"];
            this.countCommandsTriggering = _data["countCommandsTriggering"];
            this.countInsightsFaulted = _data["countInsightsFaulted"];
            this.countInsightsInValid = _data["countInsightsInValid"];
            this.countInsightsHealthy = _data["countInsightsHealthy"];
            this.countCommandInsights = _data["countCommandInsights"];
            this.countDataQualityReports = _data["countDataQualityReports"];
            this.speed = _data["speed"];
            this.lastTimeStamp = _data["lastTimeStamp"] ? moment.parseZone(_data["lastTimeStamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["health"])) {
                this.health = [] as any;
                for (let item of _data["health"])
                    this.health!.push(HealthCheckDto.fromJS(item));
            }
            if (_data["insightsByModel"]) {
                this.insightsByModel = {} as any;
                for (let key in _data["insightsByModel"]) {
                    if (_data["insightsByModel"].hasOwnProperty(key))
                        (<any>this.insightsByModel)![key] = _data["insightsByModel"][key];
                }
            }
            if (_data["commandsByModel"]) {
                this.commandsByModel = {} as any;
                for (let key in _data["commandsByModel"]) {
                    if (_data["commandsByModel"].hasOwnProperty(key))
                        (<any>this.commandsByModel)![key] = _data["commandsByModel"][key];
                }
            }
            if (Array.isArray(_data["modelSummary"])) {
                this.modelSummary = [] as any;
                for (let item of _data["modelSummary"])
                    this.modelSummary!.push(ADTModelSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adtAsOfDate"] = this.adtAsOfDate ? this.adtAsOfDate.toISOString(true) : <any>undefined;
        data["countTwins"] = this.countTwins;
        data["countCapabilities"] = this.countCapabilities;
        data["countRelationships"] = this.countRelationships;
        data["countRules"] = this.countRules;
        data["countRuleInstances"] = this.countRuleInstances;
        data["countCalculatedPoints"] = this.countCalculatedPoints;
        data["countLiveData"] = this.countLiveData;
        data["countTimeSeriesBuffers"] = this.countTimeSeriesBuffers;
        data["countCommands"] = this.countCommands;
        data["countCommandsTriggering"] = this.countCommandsTriggering;
        data["countInsightsFaulted"] = this.countInsightsFaulted;
        data["countInsightsInValid"] = this.countInsightsInValid;
        data["countInsightsHealthy"] = this.countInsightsHealthy;
        data["countCommandInsights"] = this.countCommandInsights;
        data["countDataQualityReports"] = this.countDataQualityReports;
        data["speed"] = this.speed;
        data["lastTimeStamp"] = this.lastTimeStamp ? this.lastTimeStamp.toISOString(true) : <any>undefined;
        if (Array.isArray(this.health)) {
            data["health"] = [];
            for (let item of this.health)
                data["health"].push(item.toJSON());
        }
        if (this.insightsByModel) {
            data["insightsByModel"] = {};
            for (let key in this.insightsByModel) {
                if (this.insightsByModel.hasOwnProperty(key))
                    (<any>data["insightsByModel"])[key] = (<any>this.insightsByModel)[key];
            }
        }
        if (this.commandsByModel) {
            data["commandsByModel"] = {};
            for (let key in this.commandsByModel) {
                if (this.commandsByModel.hasOwnProperty(key))
                    (<any>data["commandsByModel"])[key] = (<any>this.commandsByModel)[key];
            }
        }
        if (Array.isArray(this.modelSummary)) {
            data["modelSummary"] = [];
            for (let item of this.modelSummary)
                data["modelSummary"].push(item.toJSON());
        }
        return data;
    }
}

/** Information about the state of the Rules Engine system */
export interface ISystemSummaryDto {
    /** When twins and relationships counts were set */
    adtAsOfDate?: moment.Moment;
    /** How many twins */
    countTwins?: number;
    /** How many twins with trend Ids */
    countCapabilities?: number;
    /** How many relationships */
    countRelationships?: number;
    /** How many rules */
    countRules?: number;
    /** How many rule instances */
    countRuleInstances?: number;
    /** How many calculated points */
    countCalculatedPoints?: number;
    /** How many live data points are coming in */
    countLiveData?: number;
    /** How many time series buffers */
    countTimeSeriesBuffers?: number;
    /** How many commands in total */
    countCommands?: number;
    /** How many commands are triggering */
    countCommandsTriggering?: number;
    /** How many insights in the faulted state */
    countInsightsFaulted?: number;
    /** How many insights invalid */
    countInsightsInValid?: number;
    /** How many insights in healthy state */
    countInsightsHealthy?: number;
    /** How many insights flowing to command */
    countCommandInsights?: number;
    /** How many data quality reports being sent */
    countDataQualityReports?: number;
    /** Speed of execution */
    speed?: number;
    /** Last time stamp processed */
    lastTimeStamp?: moment.Moment | undefined;
    /** Health checks flattened */
    health?: HealthCheckDto[] | undefined;
    /** Insights by model type */
    insightsByModel?: { [key: string]: number; } | undefined;
    /** Commands by model type */
    commandsByModel?: { [key: string]: number; } | undefined;
    /** Model summary */
    modelSummary?: ADTModelSummary[] | undefined;
}

/** Time series buffer data for examining inputs to rules engine */
export class TimeSeriesBufferDto implements ITimeSeriesBufferDto {
    /** The twin id */
    id?: string | undefined;
    /** The Timezone for the result */
    timeZone?: string | undefined;
    timeSeries?: TimeSeriesDto;
    trendline?: TrendlineDto;
    rawTrendline?: TrendlineDto;

    constructor(data?: ITimeSeriesBufferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeZone = _data["timeZone"];
            this.timeSeries = _data["timeSeries"] ? TimeSeriesDto.fromJS(_data["timeSeries"]) : <any>undefined;
            this.trendline = _data["trendline"] ? TrendlineDto.fromJS(_data["trendline"]) : <any>undefined;
            this.rawTrendline = _data["rawTrendline"] ? TrendlineDto.fromJS(_data["rawTrendline"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeSeriesBufferDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesBufferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeZone"] = this.timeZone;
        data["timeSeries"] = this.timeSeries ? this.timeSeries.toJSON() : <any>undefined;
        data["trendline"] = this.trendline ? this.trendline.toJSON() : <any>undefined;
        data["rawTrendline"] = this.rawTrendline ? this.rawTrendline.toJSON() : <any>undefined;
        return data;
    }
}

/** Time series buffer data for examining inputs to rules engine */
export interface ITimeSeriesBufferDto {
    /** The twin id */
    id?: string | undefined;
    /** The Timezone for the result */
    timeZone?: string | undefined;
    timeSeries?: TimeSeriesDto;
    trendline?: TrendlineDto;
    rawTrendline?: TrendlineDto;
}

/** Time series data for multiple trends for a chart */
export class TimeSeriesDataDto implements ITimeSeriesDataDto {
    /** An Id for the time series (fix name) */
    id?: string | undefined;
    /** The start time for the timeseries data */
    startTime?: moment.Moment;
    /** The end time for the timeseries data */
    endTime?: moment.Moment;
    /** The time series data */
    trendlines?: TrendlineDto[] | undefined;
    /** Insights for this trendline */
    insights?: TrendlineInsightDto[] | undefined;
    /** Names of axes (y, y2, y3, ...) */
    readonly axes?: AxisDto[] | undefined;

    constructor(data?: ITimeSeriesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment.parseZone(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["trendlines"])) {
                this.trendlines = [] as any;
                for (let item of _data["trendlines"])
                    this.trendlines!.push(TrendlineDto.fromJS(item));
            }
            if (Array.isArray(_data["insights"])) {
                this.insights = [] as any;
                for (let item of _data["insights"])
                    this.insights!.push(TrendlineInsightDto.fromJS(item));
            }
            if (Array.isArray(_data["axes"])) {
                (<any>this).axes = [] as any;
                for (let item of _data["axes"])
                    (<any>this).axes!.push(AxisDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeSeriesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString(true) : <any>undefined;
        if (Array.isArray(this.trendlines)) {
            data["trendlines"] = [];
            for (let item of this.trendlines)
                data["trendlines"].push(item.toJSON());
        }
        if (Array.isArray(this.insights)) {
            data["insights"] = [];
            for (let item of this.insights)
                data["insights"].push(item.toJSON());
        }
        if (Array.isArray(this.axes)) {
            data["axes"] = [];
            for (let item of this.axes)
                data["axes"].push(item.toJSON());
        }
        return data;
    }
}

/** Time series data for multiple trends for a chart */
export interface ITimeSeriesDataDto {
    /** An Id for the time series (fix name) */
    id?: string | undefined;
    /** The start time for the timeseries data */
    startTime?: moment.Moment;
    /** The end time for the timeseries data */
    endTime?: moment.Moment;
    /** The time series data */
    trendlines?: TrendlineDto[] | undefined;
    /** Insights for this trendline */
    insights?: TrendlineInsightDto[] | undefined;
    /** Names of axes (y, y2, y3, ...) */
    axes?: AxisDto[] | undefined;
}

/** Time series summary */
export class TimeSeriesDto implements ITimeSeriesDto {
    /** An Id for the time series */
    id?: string | undefined;
    /** The start time for the timeseries data */
    startTime?: moment.Moment;
    /** The end time for the timeseries data */
    endTime?: moment.Moment;
    /** Count in the buffer */
    bufferCount?: number;
    /** Max time to keep */
    maxTimeToKeep?: number | undefined;
    /** Max count to keep */
    maxCountToKeep?: number | undefined;
    /** Total values processed */
    totalValuesProcessed?: number;
    /** Estimate of period in seconds */
    estimatedPeriod?: number;
    /** Average value calculated how? */
    averageValue?: number | undefined;
    /** Average of values in the buffer */
    averageInBuffer?: number;
    /** Unit of measure (same as Twin provides) */
    unitOfMeasure?: string | undefined;
    /** The maximum value over time */
    maxValue?: number;
    /** The minimum value over time */
    minValue?: number;
    /** The sum of all values over time */
    totalValue?: number;
    /** The digital twin Id (or null)  Not set until caching has run after point was found */
    dtId?: string | undefined;
    /** The DTDL Model */
    modelId?: string | undefined;
    /** The Connector Id for the twin. Optionally used to identify a twin with ExternalId */
    connectorId?: string | undefined;
    /** The External Id for the twin. Optionally used to identify a twin with ConnectorId */
    externalId?: string | undefined;
    /** The Trend interval (in seconds) copied over from the twin */
    trendInterval?: number | undefined;
    status?: TimeSeriesStatus;
    /** The compression for the buffer */
    compression?: number;
    /** Kalman filtered latency */
    latency?: number;
    /** Parent chain by locatedIn and isPartOf */
    twinLocations?: TwinLocation[] | undefined;

    constructor(data?: ITimeSeriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startTime = _data["startTime"] ? moment.parseZone(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment.parseZone(_data["endTime"].toString()) : <any>undefined;
            this.bufferCount = _data["bufferCount"];
            this.maxTimeToKeep = _data["maxTimeToKeep"];
            this.maxCountToKeep = _data["maxCountToKeep"];
            this.totalValuesProcessed = _data["totalValuesProcessed"];
            this.estimatedPeriod = _data["estimatedPeriod"];
            this.averageValue = _data["averageValue"];
            this.averageInBuffer = _data["averageInBuffer"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.maxValue = _data["maxValue"];
            this.minValue = _data["minValue"];
            this.totalValue = _data["totalValue"];
            this.dtId = _data["dtId"];
            this.modelId = _data["modelId"];
            this.connectorId = _data["connectorId"];
            this.externalId = _data["externalId"];
            this.trendInterval = _data["trendInterval"];
            this.status = _data["status"];
            this.compression = _data["compression"];
            this.latency = _data["latency"];
            if (Array.isArray(_data["twinLocations"])) {
                this.twinLocations = [] as any;
                for (let item of _data["twinLocations"])
                    this.twinLocations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeSeriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString(true) : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString(true) : <any>undefined;
        data["bufferCount"] = this.bufferCount;
        data["maxTimeToKeep"] = this.maxTimeToKeep;
        data["maxCountToKeep"] = this.maxCountToKeep;
        data["totalValuesProcessed"] = this.totalValuesProcessed;
        data["estimatedPeriod"] = this.estimatedPeriod;
        data["averageValue"] = this.averageValue;
        data["averageInBuffer"] = this.averageInBuffer;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["maxValue"] = this.maxValue;
        data["minValue"] = this.minValue;
        data["totalValue"] = this.totalValue;
        data["dtId"] = this.dtId;
        data["modelId"] = this.modelId;
        data["connectorId"] = this.connectorId;
        data["externalId"] = this.externalId;
        data["trendInterval"] = this.trendInterval;
        data["status"] = this.status;
        data["compression"] = this.compression;
        data["latency"] = this.latency;
        if (Array.isArray(this.twinLocations)) {
            data["twinLocations"] = [];
            for (let item of this.twinLocations)
                data["twinLocations"].push(item.toJSON());
        }
        return data;
    }
}

/** Time series summary */
export interface ITimeSeriesDto {
    /** An Id for the time series */
    id?: string | undefined;
    /** The start time for the timeseries data */
    startTime?: moment.Moment;
    /** The end time for the timeseries data */
    endTime?: moment.Moment;
    /** Count in the buffer */
    bufferCount?: number;
    /** Max time to keep */
    maxTimeToKeep?: number | undefined;
    /** Max count to keep */
    maxCountToKeep?: number | undefined;
    /** Total values processed */
    totalValuesProcessed?: number;
    /** Estimate of period in seconds */
    estimatedPeriod?: number;
    /** Average value calculated how? */
    averageValue?: number | undefined;
    /** Average of values in the buffer */
    averageInBuffer?: number;
    /** Unit of measure (same as Twin provides) */
    unitOfMeasure?: string | undefined;
    /** The maximum value over time */
    maxValue?: number;
    /** The minimum value over time */
    minValue?: number;
    /** The sum of all values over time */
    totalValue?: number;
    /** The digital twin Id (or null)  Not set until caching has run after point was found */
    dtId?: string | undefined;
    /** The DTDL Model */
    modelId?: string | undefined;
    /** The Connector Id for the twin. Optionally used to identify a twin with ExternalId */
    connectorId?: string | undefined;
    /** The External Id for the twin. Optionally used to identify a twin with ConnectorId */
    externalId?: string | undefined;
    /** The Trend interval (in seconds) copied over from the twin */
    trendInterval?: number | undefined;
    status?: TimeSeriesStatus;
    /** The compression for the buffer */
    compression?: number;
    /** Kalman filtered latency */
    latency?: number;
    /** Parent chain by locatedIn and isPartOf */
    twinLocations?: TwinLocation[] | undefined;
}

/** A batched result */
export class TimeSeriesDtoBatchDto implements ITimeSeriesDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: TimeSeriesDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;

    constructor(data?: ITimeSeriesDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TimeSeriesDto.fromJS(item));
            }
            this.next = _data["next"];
        }
    }

    static fromJS(data: any): TimeSeriesDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        return data;
    }
}

/** A batched result */
export interface ITimeSeriesDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: TimeSeriesDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
}

export enum TimeSeriesStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
}

/** A timestamped value for a single trendId */
export class TimedValueDto implements ITimedValueDto {
    /** Timestamp of this observation */
    timestamp?: moment.Moment;
    /** For points with a double or int value */
    valueDouble?: number | undefined;
    /** For points that are bool values, or for tracking state against a point */
    valueBool?: boolean | undefined;
    /** Whether a point triggered from a command */
    triggered?: boolean;
    /** Custom Text */
    text?: string | undefined;

    constructor(data?: ITimedValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? moment.parseZone(_data["timestamp"].toString()) : <any>undefined;
            this.valueDouble = _data["valueDouble"];
            this.valueBool = _data["valueBool"];
            this.triggered = _data["triggered"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): TimedValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimedValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString(true) : <any>undefined;
        data["valueDouble"] = this.valueDouble;
        data["valueBool"] = this.valueBool;
        data["triggered"] = this.triggered;
        data["text"] = this.text;
        return data;
    }
}

/** A timestamped value for a single trendId */
export interface ITimedValueDto {
    /** Timestamp of this observation */
    timestamp?: moment.Moment;
    /** For points with a double or int value */
    valueDouble?: number | undefined;
    /** For points that are bool values, or for tracking state against a point */
    valueBool?: boolean | undefined;
    /** Whether a point triggered from a command */
    triggered?: boolean;
    /** Custom Text */
    text?: string | undefined;
}

/** An annotation for a trendline */
export class TrendlineAnnotationDto implements ITrendlineAnnotationDto {
    /** Timestamp of this annotation */
    timestamp?: moment.Moment;
    /** The text for this annotation */
    text?: string | undefined;

    constructor(data?: ITrendlineAnnotationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? moment.parseZone(_data["timestamp"].toString()) : <any>undefined;
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): TrendlineAnnotationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrendlineAnnotationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString(true) : <any>undefined;
        data["text"] = this.text;
        return data;
    }
}

/** An annotation for a trendline */
export interface ITrendlineAnnotationDto {
    /** Timestamp of this annotation */
    timestamp?: moment.Moment;
    /** The text for this annotation */
    text?: string | undefined;
}

/** A single time series line */
export class TrendlineDto implements ITrendlineDto {
    /** Id of the time series */
    id?: string | undefined;
    /** Name of the time series */
    name?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;
    /** Is this value an output value? They group together */
    isOutput?: boolean;
    /** Is this value calculated by the rule, otherwise this is a user defined expression */
    isSystemGenerated?: boolean;
    /** Is this a ranking value */
    isRanking?: boolean;
    /** Is this line for a trigger */
    isTrigger?: boolean;
    /** The timed values */
    data?: TimedValueDto[] | undefined;
    /** Status changes for the time series */
    statuses?: TrendlineStatusDto[] | undefined;
    /** Annotations for this trendline */
    annotations?: TrendlineAnnotationDto[] | undefined;
    /** The axis name: y, y2, y3, ... */
    axis?: string | undefined;
    /** One of the D3 shapes, hv (stepped data), spline or linear */
    shape?: string | undefined;

    constructor(data?: ITrendlineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.isOutput = _data["isOutput"];
            this.isSystemGenerated = _data["isSystemGenerated"];
            this.isRanking = _data["isRanking"];
            this.isTrigger = _data["isTrigger"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TimedValueDto.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(TrendlineStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["annotations"])) {
                this.annotations = [] as any;
                for (let item of _data["annotations"])
                    this.annotations!.push(TrendlineAnnotationDto.fromJS(item));
            }
            this.axis = _data["axis"];
            this.shape = _data["shape"];
        }
    }

    static fromJS(data: any): TrendlineDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrendlineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["isOutput"] = this.isOutput;
        data["isSystemGenerated"] = this.isSystemGenerated;
        data["isRanking"] = this.isRanking;
        data["isTrigger"] = this.isTrigger;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.annotations)) {
            data["annotations"] = [];
            for (let item of this.annotations)
                data["annotations"].push(item.toJSON());
        }
        data["axis"] = this.axis;
        data["shape"] = this.shape;
        return data;
    }
}

/** A single time series line */
export interface ITrendlineDto {
    /** Id of the time series */
    id?: string | undefined;
    /** Name of the time series */
    name?: string | undefined;
    /** Unit of measure */
    unit?: string | undefined;
    /** Is this value an output value? They group together */
    isOutput?: boolean;
    /** Is this value calculated by the rule, otherwise this is a user defined expression */
    isSystemGenerated?: boolean;
    /** Is this a ranking value */
    isRanking?: boolean;
    /** Is this line for a trigger */
    isTrigger?: boolean;
    /** The timed values */
    data?: TimedValueDto[] | undefined;
    /** Status changes for the time series */
    statuses?: TrendlineStatusDto[] | undefined;
    /** Annotations for this trendline */
    annotations?: TrendlineAnnotationDto[] | undefined;
    /** The axis name: y, y2, y3, ... */
    axis?: string | undefined;
    /** One of the D3 shapes, hv (stepped data), spline or linear */
    shape?: string | undefined;
}

/** An insight for a trendline */
export class TrendlineInsightDto implements ITrendlineInsightDto {
    /** Start Timestamp of this insight */
    startTimestamp?: moment.Moment;
    /** End Timestamp of this insight */
    endTimestamp?: moment.Moment;
    /** The total hours */
    hours?: number;
    /** Indicator whether the occurrence is valid */
    isValid?: boolean;

    constructor(data?: ITrendlineInsightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTimestamp = _data["startTimestamp"] ? moment.parseZone(_data["startTimestamp"].toString()) : <any>undefined;
            this.endTimestamp = _data["endTimestamp"] ? moment.parseZone(_data["endTimestamp"].toString()) : <any>undefined;
            this.hours = _data["hours"];
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): TrendlineInsightDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrendlineInsightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTimestamp"] = this.startTimestamp ? this.startTimestamp.toISOString(true) : <any>undefined;
        data["endTimestamp"] = this.endTimestamp ? this.endTimestamp.toISOString(true) : <any>undefined;
        data["hours"] = this.hours;
        data["isValid"] = this.isValid;
        return data;
    }
}

/** An insight for a trendline */
export interface ITrendlineInsightDto {
    /** Start Timestamp of this insight */
    startTimestamp?: moment.Moment;
    /** End Timestamp of this insight */
    endTimestamp?: moment.Moment;
    /** The total hours */
    hours?: number;
    /** Indicator whether the occurrence is valid */
    isValid?: boolean;
}

/** Represents a status for a time range */
export class TrendlineStatusDto implements ITrendlineStatusDto {
    values?: TrendlineDto;
    status?: TimeSeriesStatus;

    constructor(data?: ITrendlineStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.values = _data["values"] ? TrendlineDto.fromJS(_data["values"]) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TrendlineStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrendlineStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["values"] = this.values ? this.values.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

/** Represents a status for a time range */
export interface ITrendlineStatusDto {
    values?: TrendlineDto;
    status?: TimeSeriesStatus;
}

export class TwinDto implements ITwinDto {
    id?: string | undefined;
    name?: string | undefined;
    siteId?: string | undefined;
    equipmentUniqueId?: string | undefined;
    trendID?: string | undefined;
    externalID?: string | undefined;
    connectorID?: string | undefined;
    unit?: string | undefined;
    trendInterval?: number | undefined;
    position?: string | undefined;
    description?: string | undefined;
    tags?: { [key: string]: boolean; } | undefined;
    modelId?: string | undefined;
    eTag?: string | undefined;
    contents?: { [key: string]: any; } | undefined;
    valueExpression?: string | undefined;
    timezone?: string | undefined;
    lastUpdatedOn?: moment.Moment | undefined;
    locations?: TwinLocation[] | undefined;

    constructor(data?: ITwinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.siteId = _data["siteId"];
            this.equipmentUniqueId = _data["equipmentUniqueId"];
            this.trendID = _data["trendID"];
            this.externalID = _data["externalID"];
            this.connectorID = _data["connectorID"];
            this.unit = _data["unit"];
            this.trendInterval = _data["trendInterval"];
            this.position = _data["position"];
            this.description = _data["description"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
            this.modelId = _data["modelId"];
            this.eTag = _data["eTag"];
            if (_data["contents"]) {
                this.contents = {} as any;
                for (let key in _data["contents"]) {
                    if (_data["contents"].hasOwnProperty(key))
                        (<any>this.contents)![key] = _data["contents"][key];
                }
            }
            this.valueExpression = _data["valueExpression"];
            this.timezone = _data["timezone"];
            this.lastUpdatedOn = _data["lastUpdatedOn"] ? moment.parseZone(_data["lastUpdatedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(TwinLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TwinDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["siteId"] = this.siteId;
        data["equipmentUniqueId"] = this.equipmentUniqueId;
        data["trendID"] = this.trendID;
        data["externalID"] = this.externalID;
        data["connectorID"] = this.connectorID;
        data["unit"] = this.unit;
        data["trendInterval"] = this.trendInterval;
        data["position"] = this.position;
        data["description"] = this.description;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        data["modelId"] = this.modelId;
        data["eTag"] = this.eTag;
        if (this.contents) {
            data["contents"] = {};
            for (let key in this.contents) {
                if (this.contents.hasOwnProperty(key))
                    (<any>data["contents"])[key] = (<any>this.contents)[key];
            }
        }
        data["valueExpression"] = this.valueExpression;
        data["timezone"] = this.timezone;
        data["lastUpdatedOn"] = this.lastUpdatedOn ? this.lastUpdatedOn.toISOString(true) : <any>undefined;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITwinDto {
    id?: string | undefined;
    name?: string | undefined;
    siteId?: string | undefined;
    equipmentUniqueId?: string | undefined;
    trendID?: string | undefined;
    externalID?: string | undefined;
    connectorID?: string | undefined;
    unit?: string | undefined;
    trendInterval?: number | undefined;
    position?: string | undefined;
    description?: string | undefined;
    tags?: { [key: string]: boolean; } | undefined;
    modelId?: string | undefined;
    eTag?: string | undefined;
    contents?: { [key: string]: any; } | undefined;
    valueExpression?: string | undefined;
    timezone?: string | undefined;
    lastUpdatedOn?: moment.Moment | undefined;
    locations?: TwinLocation[] | undefined;
}

/** TwinDto Batch Dto */
export class TwinDtoBatchDto implements ITwinDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: TwinDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** A unique list of content types for the twins' extended data */
    contentTypes?: TwinDtoContentType[] | undefined;

    constructor(data?: ITwinDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryString = _data["queryString"];
            this.before = _data["before"];
            this.after = _data["after"];
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TwinDto.fromJS(item));
            }
            this.next = _data["next"];
            if (Array.isArray(_data["contentTypes"])) {
                this.contentTypes = [] as any;
                for (let item of _data["contentTypes"])
                    this.contentTypes!.push(TwinDtoContentType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TwinDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryString"] = this.queryString;
        data["before"] = this.before;
        data["after"] = this.after;
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["next"] = this.next;
        if (Array.isArray(this.contentTypes)) {
            data["contentTypes"] = [];
            for (let item of this.contentTypes)
                data["contentTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** TwinDto Batch Dto */
export interface ITwinDtoBatchDto {
    /** Query string for debugging */
    queryString?: string | undefined;
    /** Count before */
    before?: number;
    /** Count after (including items if any) */
    after?: number;
    /** Total Count */
    total?: number;
    /** Items */
    items?: TwinDto[] | undefined;
    /** A reference to the next set or records after this (if any) */
    next?: string | undefined;
    /** A unique list of content types for the twins' extended data */
    contentTypes?: TwinDtoContentType[] | undefined;
}

/** A twin content entry type */
export class TwinDtoContentType implements ITwinDtoContentType {
    /** The content type name */
    name?: string | undefined;
    /** Indicator whether content type is a bool */
    isBool?: boolean;
    /** Indicator whether content type is a number */
    isNumber?: boolean;
    /** Indicator whether content type is a string */
    isString?: boolean;

    constructor(data?: ITwinDtoContentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isBool = _data["isBool"];
            this.isNumber = _data["isNumber"];
            this.isString = _data["isString"];
        }
    }

    static fromJS(data: any): TwinDtoContentType {
        data = typeof data === 'object' ? data : {};
        let result = new TwinDtoContentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isBool"] = this.isBool;
        data["isNumber"] = this.isNumber;
        data["isString"] = this.isString;
        return data;
    }
}

/** A twin content entry type */
export interface ITwinDtoContentType {
    /** The content type name */
    name?: string | undefined;
    /** Indicator whether content type is a bool */
    isBool?: boolean;
    /** Indicator whether content type is a number */
    isNumber?: boolean;
    /** Indicator whether content type is a string */
    isString?: boolean;
}

export class TwinGraphDto implements ITwinGraphDto {
    nodes?: TwinNodeDto[] | undefined;
    edges?: TwinRelationshipDto[] | undefined;

    constructor(data?: ITwinGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(TwinNodeDto.fromJS(item));
            }
            if (Array.isArray(_data["edges"])) {
                this.edges = [] as any;
                for (let item of _data["edges"])
                    this.edges!.push(TwinRelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TwinGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item.toJSON());
        }
        if (Array.isArray(this.edges)) {
            data["edges"] = [];
            for (let item of this.edges)
                data["edges"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITwinGraphDto {
    nodes?: TwinNodeDto[] | undefined;
    edges?: TwinRelationshipDto[] | undefined;
}

/** Twin's insight count */
export class TwinInsightsCountDto implements ITwinInsightsCountDto {
    /** The twin Id */
    twinId?: string | undefined;
    /** The insights count for the twin */
    insightsCount?: number;

    constructor(data?: ITwinInsightsCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.insightsCount = _data["insightsCount"];
        }
    }

    static fromJS(data: any): TwinInsightsCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinInsightsCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["insightsCount"] = this.insightsCount;
        return data;
    }
}

/** Twin's insight count */
export interface ITwinInsightsCountDto {
    /** The twin Id */
    twinId?: string | undefined;
    /** The insights count for the twin */
    insightsCount?: number;
}

export class TwinLocation implements ITwinLocation {
    id?: string | undefined;
    name?: string | undefined;
    modelId?: string | undefined;

    constructor(data?: ITwinLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.modelId = _data["modelId"];
        }
    }

    static fromJS(data: any): TwinLocation {
        data = typeof data === 'object' ? data : {};
        let result = new TwinLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        return data;
    }
}

export interface ITwinLocation {
    id?: string | undefined;
    name?: string | undefined;
    modelId?: string | undefined;
}

export class TwinNodeDto implements ITwinNodeDto {
    id?: number;
    twinId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelId?: string | undefined;
    trendInterval?: number | undefined;
    unit?: string | undefined;
    position?: string | undefined;
    isSelected?: boolean;
    isCollapsed?: boolean;
    isExpanded?: boolean;
    groupKey?: string | undefined;
    groupKey2?: string | undefined;
    collapseKey?: string | undefined;
    valueExpression?: string | undefined;
    contents?: { [key: string]: any; } | undefined;

    constructor(data?: ITwinNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.twinId = _data["twinId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.modelId = _data["modelId"];
            this.trendInterval = _data["trendInterval"];
            this.unit = _data["unit"];
            this.position = _data["position"];
            this.isSelected = _data["isSelected"];
            this.isCollapsed = _data["isCollapsed"];
            this.isExpanded = _data["isExpanded"];
            this.groupKey = _data["groupKey"];
            this.groupKey2 = _data["groupKey2"];
            this.collapseKey = _data["collapseKey"];
            this.valueExpression = _data["valueExpression"];
            if (_data["contents"]) {
                this.contents = {} as any;
                for (let key in _data["contents"]) {
                    if (_data["contents"].hasOwnProperty(key))
                        (<any>this.contents)![key] = _data["contents"][key];
                }
            }
        }
    }

    static fromJS(data: any): TwinNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["twinId"] = this.twinId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["modelId"] = this.modelId;
        data["trendInterval"] = this.trendInterval;
        data["unit"] = this.unit;
        data["position"] = this.position;
        data["isSelected"] = this.isSelected;
        data["isCollapsed"] = this.isCollapsed;
        data["isExpanded"] = this.isExpanded;
        data["groupKey"] = this.groupKey;
        data["groupKey2"] = this.groupKey2;
        data["collapseKey"] = this.collapseKey;
        data["valueExpression"] = this.valueExpression;
        if (this.contents) {
            data["contents"] = {};
            for (let key in this.contents) {
                if (this.contents.hasOwnProperty(key))
                    (<any>data["contents"])[key] = (<any>this.contents)[key];
            }
        }
        return data;
    }
}

export interface ITwinNodeDto {
    id?: number;
    twinId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelId?: string | undefined;
    trendInterval?: number | undefined;
    unit?: string | undefined;
    position?: string | undefined;
    isSelected?: boolean;
    isCollapsed?: boolean;
    isExpanded?: boolean;
    groupKey?: string | undefined;
    groupKey2?: string | undefined;
    collapseKey?: string | undefined;
    valueExpression?: string | undefined;
    contents?: { [key: string]: any; } | undefined;
}

export class TwinRelationshipDto implements ITwinRelationshipDto {
    readonly id?: string | undefined;
    startId?: number;
    endId?: number;
    name?: string | undefined;
    substance?: string | undefined;
    startTwinId?: string | undefined;
    endTwinId?: string | undefined;

    constructor(data?: ITwinRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.startId = _data["startId"];
            this.endId = _data["endId"];
            this.name = _data["name"];
            this.substance = _data["substance"];
            this.startTwinId = _data["startTwinId"];
            this.endTwinId = _data["endTwinId"];
        }
    }

    static fromJS(data: any): TwinRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startId"] = this.startId;
        data["endId"] = this.endId;
        data["name"] = this.name;
        data["substance"] = this.substance;
        data["startTwinId"] = this.startTwinId;
        data["endTwinId"] = this.endTwinId;
        return data;
    }
}

export interface ITwinRelationshipDto {
    id?: string | undefined;
    startId?: number;
    endId?: number;
    name?: string | undefined;
    substance?: string | undefined;
    startTwinId?: string | undefined;
    endTwinId?: string | undefined;
}

/** Dto for Willow.Expressions.Unit */
export class UnitDto implements IUnitDto {
    /** Name of the unit */
    name?: string | undefined;
    /** Aliases for the unit */
    aliases?: string[] | undefined;

    constructor(data?: IUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
        }
    }

    static fromJS(data: any): UnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        return data;
    }
}

/** Dto for Willow.Expressions.Unit */
export interface IUnitDto {
    /** Name of the unit */
    name?: string | undefined;
    /** Aliases for the unit */
    aliases?: string[] | undefined;
}

export enum UnitOutputType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

/** Validation results from a post to server */
export class ValidationReponseDto implements IValidationReponseDto {
    /** Fields and validation messages */
    results?: ValidationReponseElementDto[] | undefined;

    constructor(data?: IValidationReponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ValidationReponseElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationReponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationReponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** Validation results from a post to server */
export interface IValidationReponseDto {
    /** Fields and validation messages */
    results?: ValidationReponseElementDto[] | undefined;
}

/** Validation results from a post to server */
export class ValidationReponseElementDto implements IValidationReponseElementDto {
    /** Field name */
    field?: string | undefined;
    /** Message */
    message?: string | undefined;
    /** Parent field name which is useful for validation highlights */
    parentField?: string | undefined;

    constructor(data?: IValidationReponseElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.message = _data["message"];
            this.parentField = _data["parentField"];
        }
    }

    static fromJS(data: any): ValidationReponseElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationReponseElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["message"] = this.message;
        data["parentField"] = this.parentField;
        return data;
    }
}

/** Validation results from a post to server */
export interface IValidationReponseElementDto {
    /** Field name */
    field?: string | undefined;
    /** Message */
    message?: string | undefined;
    /** Parent field name which is useful for validation highlights */
    parentField?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}