import { Accordion, AccordionDetails, AccordionSummary, FormControlLabel, Grid, Stack, Switch, Typography } from "@mui/material";
import { GridColDef } from "@mui/x-data-grid-pro";
import { ChangeEvent, useMemo, useState } from "react";
import { IRuleParameterBoundDto, RuleInstanceDto, RuleInstanceStatus } from "../Rules";
import BindingsTable from "./grids/BindingsTable";
import { stringOperators } from "./grids/GridFunctions";
import PointEntitiesTable from "./grids/PointEntitiesTable";

interface ITriggerBound extends IRuleParameterBoundDto {
  commandName: string,
  twinName: string,
  twinId: string,
  externalId: string,
  connectorId: string
};

const RuleInstanceBindings = (params: { ruleInstance: RuleInstanceDto, pageId: string, showInvalidOnly?: boolean, showBindingsToggle?: boolean }) => {
  const ruleInstance = params.ruleInstance;
  const pageId = params.pageId;
  const showBindingsToggle = (params.showBindingsToggle ?? false) && ruleInstance.status != 1;
  const ruleId = ruleInstance.id;
  const [autoVariablesExpanded, setAutoVariablesExpanded] = useState(false);
  const [showInvalidOnly, setShowInvalidOnly] = useState(params.showInvalidOnly ?? false);

  const [ruleParametersBound, setRuleParametersBound] = useState(ruleInstance.ruleParametersBound!.filter((p) => !p.isAutoGenerated));
  const [autoVariables, setAutoVariables] = useState(ruleInstance.ruleParametersBound!.filter((p) => p.isAutoGenerated));
  const [ruleImpactScoresBound, setRuleImpactScoresBound] = useState(ruleInstance.ruleImpactScoresBound!);
  const [ruleFiltersBound, setRuleFiltersBound] = useState(ruleInstance.ruleFiltersBound!);
  const [ruleTriggersBound, setRuleTriggersBound] = useState(ruleInstance.ruleTriggersBound!);
  const [pointEntityIds, setPointEntityIds] = useState(ruleInstance.pointEntityIds!);

  function setBindings(showFailed: boolean) {
    if (showFailed) {
      setRuleParametersBound(ruleInstance.ruleParametersBound!.filter((p) => !p.isAutoGenerated)!.filter(v => !(v.status! & RuleInstanceStatus._1)));
      setAutoVariables(ruleInstance.ruleParametersBound!.filter((p) => p.isAutoGenerated)!.filter(v => !(v.status! & RuleInstanceStatus._1)));
      setRuleImpactScoresBound(ruleInstance.ruleImpactScoresBound!.filter(v => !(v.status! & RuleInstanceStatus._1)));
      setRuleFiltersBound(ruleInstance.ruleFiltersBound!.filter(v => !(v.status! & RuleInstanceStatus._1)));
      setRuleTriggersBound(ruleInstance.ruleTriggersBound!.filter(v => !(v.status! & RuleInstanceStatus._1)));
      setPointEntityIds([]);
    }
    else {
      setRuleParametersBound(ruleInstance.ruleParametersBound!.filter((p) => !p.isAutoGenerated));
      setAutoVariables(ruleInstance.ruleParametersBound!.filter((p) => p.isAutoGenerated));
      setRuleImpactScoresBound(ruleInstance.ruleImpactScoresBound!);
      setRuleFiltersBound(ruleInstance.ruleFiltersBound!);
      setRuleTriggersBound(ruleInstance.ruleTriggersBound!);
      setPointEntityIds(ruleInstance.pointEntityIds!);
    }
  }

  const handleShowAllChange = async (event: ChangeEvent<HTMLInputElement>) => {
    const checked = event.target.checked;
    setShowInvalidOnly(checked);
    setBindings(checked);
  };

  useMemo(() => {
    setBindings(showInvalidOnly);
  }, []);

  const triggerGridData = ruleTriggersBound!.map((v) => {
    return [
      { ...v.condition!, commandName: v.name, twinName: v.twinName, twinId: v.twinId, externalId: v.externalId, connectorId: v.connectorId } as ITriggerBound,
      { ...v.point!, commandName: v.name, twinName: v.twinName, twinId: v.twinId, externalId: v.externalId, connectorId: v.connectorId } as ITriggerBound,
      { ...v.value!, commandName: v.name, twinName: v.twinName, twinId: v.twinId, externalId: v.externalId, connectorId: v.connectorId } as ITriggerBound,
    ];
  }).reduce((a, b) => a.concat(b), []);

  const triggerColumns: GridColDef[] = [
    {
      field: 'CommandName', headerName: 'Command', flex: 2, minWidth: 250,
      valueGetter: (params: any) => {
        return params.row.commandName;
      },
      filterOperators: stringOperators()
    },
    {
      field: 'TwinName', headerName: 'Point', flex: 2, minWidth: 250,
      valueGetter: (params: any) => {
        return params.row.twinName;
      },
      filterOperators: stringOperators()
    },
    {
      field: 'ConnectorId', headerName: 'Connector Id', minWidth: 150,
      valueGetter: (params: any) => params.row.connectorId,
      filterOperators: stringOperators()
    },
    {
      field: 'ExternalId', headerName: 'External Id', flex: 2, minWidth: 250,
      valueGetter: (params: any) => params.row.externalId,
      filterOperators: stringOperators()
    },
    {
      field: 'TwinId', headerName: 'Twin Id', flex: 2, minWidth: 250,
      valueGetter: (params: any) => params.row.twinId,
      filterOperators: stringOperators()
    },
  ];

  return (
    <Stack spacing={2}>
      <Grid container>
        <Grid item xs={8}>
          <Typography variant="h4">Bindings</Typography>
        </Grid>

        {showBindingsToggle &&
          <Grid container xs={4} justifyContent="flex-end" pr={1}>
            <FormControlLabel control={<Switch checked={showInvalidOnly} onChange={handleShowAllChange} />} labelPlacement="start" label="Failed Bindings" />
          </Grid>
        }
      </Grid>

      {(ruleParametersBound.length > 0) && <BindingsTable props={{
        parameters: ruleParametersBound,
        showUnits: true,
        showCumulativeSetting: true,
        key: ruleId!,
        pageId: pageId
      }} />}
      {autoVariables.length > 0 && <Accordion disableGutters={true} sx={{ backgroundColor: 'transparent', backgroundImage: 'none', boxShadow: 'none' }}
        expanded={autoVariablesExpanded} onChange={() => setAutoVariablesExpanded(!autoVariablesExpanded)} square={true}>
        <AccordionSummary>
          <Typography variant="h4">Generated variables</Typography>
        </AccordionSummary>
        <AccordionDetails>
          <BindingsTable props={{
            parameters: ruleInstance.ruleParametersBound?.filter((p) => p.isAutoGenerated),
            showUnits: true,
            showCumulativeSetting: false,
            key: ruleId!,
            pageId: pageId
          }} />
        </AccordionDetails>
      </Accordion>}
      {(ruleImpactScoresBound.length > 0) &&
        <>
          <Typography variant="h4">Impact scores</Typography>
          <BindingsTable props={{
            parameters: ruleImpactScoresBound, showUnits: true, showCumulativeSetting: true, key: ruleId!, pageId: pageId
          }} />
        </>}

      {(ruleFiltersBound.length > 0) &&
        <>
          <Typography variant="h4">Filters</Typography>
          <BindingsTable props={{
            parameters: ruleInstance.ruleFiltersBound, showUnits: false, showCumulativeSetting: false, key: ruleId!, pageId: pageId
          }} />
        </>
      }
      {(pointEntityIds.length > 0) &&
        <>
          <Typography variant="h4">Points</Typography>
          <PointEntitiesTable props={{
            calculatedPointId: 'X', points: pointEntityIds, key: ruleId!, pageId: pageId
          }} />
        </>
      }
      {ruleTriggersBound.map((v, i) => {
        return (
          <div key={i}>
            <Typography variant="h5">{v.name}</Typography>
            <BindingsTable props={{
              parameters: triggerGridData,
              showUnits: true, showCumulativeSetting: false, key: ruleId!, pageId: pageId,
              additionalColumns: triggerColumns
            }} />
          </div>)
      })}
    </Stack>);
};

export default RuleInstanceBindings;
