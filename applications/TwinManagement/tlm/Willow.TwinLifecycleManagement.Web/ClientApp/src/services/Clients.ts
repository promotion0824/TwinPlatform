//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    authorization( cancelToken?: CancelToken): Promise<AuthorizationResponseDto> {
        let url_ = this.baseUrl + "/api/Authorization";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorization(_response);
        });
    }

    protected processAuthorization(response: AxiosResponse): Promise<AuthorizationResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorizationResponseDto.fromJS(resultData200);
            return Promise.resolve<AuthorizationResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorizationResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    config( cancelToken?: CancelToken): Promise<any> {
        let url_ = this.baseUrl + "/api/Config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfig(_response);
        });
    }

    protected processConfig(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    getTlmAndDependenciesVersions( cancelToken?: CancelToken): Promise<AppVersion> {
        let url_ = this.baseUrl + "/api/Config/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTlmAndDependenciesVersions(_response);
        });
    }

    protected processGetTlmAndDependenciesVersions(response: AxiosResponse): Promise<AppVersion> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppVersion.fromJS(resultData200);
            return Promise.resolve<AppVersion>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppVersion>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    chat(body: CopilotChatRequest | undefined, cancelToken?: CancelToken): Promise<CopilotChatResponse> {
        let url_ = this.baseUrl + "/api/Copilot/Chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChat(_response);
        });
    }

    protected processChat(response: AxiosResponse): Promise<CopilotChatResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CopilotChatResponse.fromJS(resultData200);
            return Promise.resolve<CopilotChatResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CopilotChatResponse>(null as any);
    }

    /**
     * @return OK
     */
    speechToken( cancelToken?: CancelToken): Promise<SpeechAuthorizationTokenResponse> {
        let url_ = this.baseUrl + "/api/Copilot/speechToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSpeechToken(_response);
        });
    }

    protected processSpeechToken(response: AxiosResponse): Promise<SpeechAuthorizationTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SpeechAuthorizationTokenResponse.fromJS(resultData200);
            return Promise.resolve<SpeechAuthorizationTokenResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SpeechAuthorizationTokenResponse>(null as any);
    }

    /**
     * @param user_Data (optional) 
     * @param includeDependencies (optional) 
     * @return OK
     */
    modelsDELETE(user_Id: string, user_Data: string | undefined, includeDependencies: boolean | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/Delete/models?";
        if (includeDependencies === null)
            throw new Error("The parameter 'includeDependencies' cannot be null.");
        else if (includeDependencies !== undefined)
            url_ += "includeDependencies=" + encodeURIComponent("" + includeDependencies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "User-Id": user_Id !== undefined && user_Id !== null ? "" + user_Id : "",
                "User-Data": user_Data !== undefined && user_Data !== null ? "" + user_Data : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModelsDELETE(_response);
        });
    }

    protected processModelsDELETE(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param user_Data (optional) 
     * @param deleteOnlyRelationships (optional) 
     * @return OK
     */
    twinsDELETE(user_Id: string, user_Data: string | undefined, deleteOnlyRelationships: boolean | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/Delete/twins?";
        if (deleteOnlyRelationships === null)
            throw new Error("The parameter 'deleteOnlyRelationships' cannot be null.");
        else if (deleteOnlyRelationships !== undefined)
            url_ += "deleteOnlyRelationships=" + encodeURIComponent("" + deleteOnlyRelationships) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "User-Id": user_Id !== undefined && user_Id !== null ? "" + user_Id : "",
                "User-Data": user_Data !== undefined && user_Data !== null ? "" + user_Data : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsDELETE(_response);
        });
    }

    protected processTwinsDELETE(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param user_Data (optional) 
     * @param isRelationshipsRequest (optional) 
     * @return OK
     */
    twinsDELETE2(siteId: string, user_Id: string, user_Data: string | undefined, isRelationshipsRequest: boolean | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/Delete/twins/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "User-Id": user_Id !== undefined && user_Id !== null ? "" + user_Id : "",
                "User-Data": user_Data !== undefined && user_Data !== null ? "" + user_Data : "",
                "IsRelationshipsRequest": isRelationshipsRequest !== undefined && isRelationshipsRequest !== null ? "" + isRelationshipsRequest : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsDELETE2(_response);
        });
    }

    protected processTwinsDELETE2(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param formFiles (optional) 
     * @param userData (optional) 
     * @param deleteOnlyRelationships (optional) 
     * @return OK
     */
    twinsOrRelationshipsBasedOnFile(formFiles: FileParameter[] | undefined, userData: string | undefined, deleteOnlyRelationships: boolean | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/Delete/twinsOrRelationshipsBasedOnFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFiles === null || formFiles === undefined)
            throw new Error("The parameter 'formFiles' cannot be null.");
        else
            formFiles.forEach(item_ => content_.append("formFiles", item_.data, item_.fileName ? item_.fileName : "formFiles") );
        if (userData === null || userData === undefined)
            throw new Error("The parameter 'userData' cannot be null.");
        else
            content_.append("userData", userData.toString());
        if (deleteOnlyRelationships === null || deleteOnlyRelationships === undefined)
            throw new Error("The parameter 'deleteOnlyRelationships' cannot be null.");
        else
            content_.append("deleteOnlyRelationships", deleteOnlyRelationships.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsOrRelationshipsBasedOnFile(_response);
        });
    }

    protected processTwinsOrRelationshipsBasedOnFile(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param formFiles (optional) 
     * @return OK
     */
    upload(formFiles: FileParameter[] | undefined, cancelToken?: CancelToken): Promise<RuleFileUploadResponse> {
        let url_ = this.baseUrl + "/api/DQRule/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFiles === null || formFiles === undefined)
            throw new Error("The parameter 'formFiles' cannot be null.");
        else
            formFiles.forEach(item_ => content_.append("formFiles", item_.data, item_.fileName ? item_.fileName : "formFiles") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<RuleFileUploadResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleFileUploadResponse.fromJS(resultData200);
            return Promise.resolve<RuleFileUploadResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleFileUploadResponse>(null as any);
    }

    /**
     * @return OK
     */
    getDQRules( cancelToken?: CancelToken): Promise<GetRulesResponse> {
        let url_ = this.baseUrl + "/api/DQRule/rules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDQRules(_response);
        });
    }

    protected processGetDQRules(response: AxiosResponse): Promise<GetRulesResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRulesResponse.fromJS(resultData200);
            return Promise.resolve<GetRulesResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRulesResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteAllDQRules( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/DQRule/DeleteAllDQRules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllDQRules(_response);
        });
    }

    protected processDeleteAllDQRules(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param userId (optional) 
     * @param status (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param fullDetails (optional) 
     * @return OK
     */
    getDQValidationJobs(id: string | undefined, userId: string | undefined, status: AsyncJobStatus | undefined, from: Date | undefined, to: Date | undefined, fullDetails: boolean | undefined, cancelToken?: CancelToken): Promise<TwinsValidationJob[]> {
        let url_ = this.baseUrl + "/api/DQValidation/validationJobs?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (fullDetails === null)
            throw new Error("The parameter 'fullDetails' cannot be null.");
        else if (fullDetails !== undefined)
            url_ += "fullDetails=" + encodeURIComponent("" + fullDetails) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDQValidationJobs(_response);
        });
    }

    protected processGetDQValidationJobs(response: AxiosResponse): Promise<TwinsValidationJob[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TwinsValidationJob.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TwinsValidationJob[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinsValidationJob[]>(null as any);
    }

    /**
     * @param status (optional) 
     * @return OK
     */
    getLatestDQValidationJob(status: AsyncJobStatus | undefined, cancelToken?: CancelToken): Promise<TwinsValidationJob> {
        let url_ = this.baseUrl + "/api/DQValidation/latestValidationJob?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLatestDQValidationJob(_response);
        });
    }

    protected processGetLatestDQValidationJob(response: AxiosResponse): Promise<TwinsValidationJob> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinsValidationJob.fromJS(resultData200);
            return Promise.resolve<TwinsValidationJob>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinsValidationJob>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param modelIds (optional) 
     * @param locationId (optional) 
     * @param isIncrementalScan (optional) 
     * @param exactModelMatch (optional) 
     * @return OK
     */
    validateTwins(userId: string | undefined, modelIds: string[] | undefined, locationId: string | undefined, isIncrementalScan: boolean | undefined, exactModelMatch: boolean | undefined, cancelToken?: CancelToken): Promise<TwinsValidationJob> {
        let url_ = this.baseUrl + "/api/DQValidation/validate?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (modelIds === null)
            throw new Error("The parameter 'modelIds' cannot be null.");
        else if (modelIds !== undefined)
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (isIncrementalScan === null)
            throw new Error("The parameter 'isIncrementalScan' cannot be null.");
        else if (isIncrementalScan !== undefined)
            url_ += "isIncrementalScan=" + encodeURIComponent("" + isIncrementalScan) + "&";
        if (exactModelMatch === null)
            throw new Error("The parameter 'exactModelMatch' cannot be null.");
        else if (exactModelMatch !== undefined)
            url_ += "exactModelMatch=" + encodeURIComponent("" + exactModelMatch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateTwins(_response);
        });
    }

    protected processValidateTwins(response: AxiosResponse): Promise<TwinsValidationJob> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinsValidationJob.fromJS(resultData200);
            return Promise.resolve<TwinsValidationJob>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinsValidationJob>(null as any);
    }

    /**
     * @param errorsOnly (optional) 
     * @param modelIds (optional) 
     * @param resultSources (optional) 
     * @param pageSize (optional) 
     * @param continuationToken (optional) 
     * @param searchString (optional) 
     * @param locationId (optional) 
     * @return OK
     */
    getDQResults(errorsOnly: boolean | undefined, modelIds: string[] | undefined, resultSources: string[] | undefined, pageSize: number | undefined, continuationToken: string | undefined, searchString: string | undefined, locationId: string | undefined, cancelToken?: CancelToken): Promise<ValidationResultsPage> {
        let url_ = this.baseUrl + "/api/DQValidation/results?";
        if (errorsOnly === null)
            throw new Error("The parameter 'errorsOnly' cannot be null.");
        else if (errorsOnly !== undefined)
            url_ += "errorsOnly=" + encodeURIComponent("" + errorsOnly) + "&";
        if (modelIds === null)
            throw new Error("The parameter 'modelIds' cannot be null.");
        else if (modelIds !== undefined)
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (resultSources === null)
            throw new Error("The parameter 'resultSources' cannot be null.");
        else if (resultSources !== undefined)
            resultSources && resultSources.forEach(item => { url_ += "resultSources=" + encodeURIComponent("" + item) + "&"; });
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "continuationToken": continuationToken !== undefined && continuationToken !== null ? "" + continuationToken : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDQResults(_response);
        });
    }

    protected processGetDQResults(response: AxiosResponse): Promise<ValidationResultsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ValidationResultsPage.fromJS(resultData200);
            return Promise.resolve<ValidationResultsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ValidationResultsPage>(null as any);
    }

    /**
     * @param locationId (optional) 
     * @param exactModelMatch (optional) 
     * @param includeRelationships (optional) 
     * @param includeIncomingRelationships (optional) 
     * @param isTemplateExportOnly (optional) 
     * @param body (optional) 
     * @return OK
     */
    twinsPOST(locationId: string | undefined, exactModelMatch: boolean | undefined, includeRelationships: boolean | undefined, includeIncomingRelationships: boolean | undefined, isTemplateExportOnly: boolean | undefined, body: string[] | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Export/twins?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (exactModelMatch === null)
            throw new Error("The parameter 'exactModelMatch' cannot be null.");
        else if (exactModelMatch !== undefined)
            url_ += "exactModelMatch=" + encodeURIComponent("" + exactModelMatch) + "&";
        if (includeRelationships === null)
            throw new Error("The parameter 'includeRelationships' cannot be null.");
        else if (includeRelationships !== undefined)
            url_ += "includeRelationships=" + encodeURIComponent("" + includeRelationships) + "&";
        if (includeIncomingRelationships === null)
            throw new Error("The parameter 'includeIncomingRelationships' cannot be null.");
        else if (includeIncomingRelationships !== undefined)
            url_ += "includeIncomingRelationships=" + encodeURIComponent("" + includeIncomingRelationships) + "&";
        if (isTemplateExportOnly === null)
            throw new Error("The parameter 'isTemplateExportOnly' cannot be null.");
        else if (isTemplateExportOnly !== undefined)
            url_ += "isTemplateExportOnly=" + encodeURIComponent("" + isTemplateExportOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/zip"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinsPOST(_response);
        });
    }

    protected processTwinsPOST(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    twinIds(body: string[] | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Export/twinIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/zip"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwinIds(_response);
        });
    }

    protected processTwinIds(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param formFiles (optional) 
     * @param siteId (optional) 
     * @param includeRelationships (optional) 
     * @param includeTwinProperties (optional) 
     * @param userData (optional) 
     * @return OK
     */
    importTwins(formFiles: FileParameter[] | undefined, siteId: string | undefined, includeRelationships: boolean | undefined, includeTwinProperties: boolean | undefined, userData: string | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/FileImport/ImportTwins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFiles === null || formFiles === undefined)
            throw new Error("The parameter 'formFiles' cannot be null.");
        else
            formFiles.forEach(item_ => content_.append("formFiles", item_.data, item_.fileName ? item_.fileName : "formFiles") );
        if (siteId === null || siteId === undefined)
            throw new Error("The parameter 'siteId' cannot be null.");
        else
            content_.append("siteId", siteId.toString());
        if (includeRelationships === null || includeRelationships === undefined)
            throw new Error("The parameter 'includeRelationships' cannot be null.");
        else
            content_.append("includeRelationships", includeRelationships.toString());
        if (includeTwinProperties === null || includeTwinProperties === undefined)
            throw new Error("The parameter 'includeTwinProperties' cannot be null.");
        else
            content_.append("includeTwinProperties", includeTwinProperties.toString());
        if (userData === null || userData === undefined)
            throw new Error("The parameter 'userData' cannot be null.");
        else
            content_.append("userData", userData.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportTwins(_response);
        });
    }

    protected processImportTwins(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param sasUrl (optional) 
     * @param userData (optional) 
     * @return OK
     */
    importTimeSeriesWithSasUrl(sasUrl: string | undefined, userData: string | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/FileImport/ImportTimeSeriesWithSasUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (sasUrl === null || sasUrl === undefined)
            throw new Error("The parameter 'sasUrl' cannot be null.");
        else
            content_.append("sasUrl", sasUrl.toString());
        if (userData === null || userData === undefined)
            throw new Error("The parameter 'userData' cannot be null.");
        else
            content_.append("userData", userData.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportTimeSeriesWithSasUrl(_response);
        });
    }

    protected processImportTimeSeriesWithSasUrl(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    clientUploadTimeSeries(body: ImportTimeSeriesHistoricalRequest, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/FileImport/clientUploadTimeSeries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClientUploadTimeSeries(_response);
        });
    }

    protected processClientUploadTimeSeries(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param files (optional) 
     * @param siteId (optional) 
     * @return OK
     */
    documentsPOST(files: FileParameter[] | undefined, siteId: string | undefined, cancelToken?: CancelToken): Promise<CreateDocumentResponse[]> {
        let url_ = this.baseUrl + "/api/FileImport/documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );
        if (siteId === null || siteId === undefined)
            throw new Error("The parameter 'siteId' cannot be null.");
        else
            content_.append("SiteId", siteId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentsPOST(_response);
        });
    }

    protected processDocumentsPOST(response: AxiosResponse): Promise<CreateDocumentResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateDocumentResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CreateDocumentResponse[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateDocumentResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    documentsGET( cancelToken?: CancelToken): Promise<Document[]> {
        let url_ = this.baseUrl + "/api/FileImport/documents";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentsGET(_response);
        });
    }

    protected processDocumentsGET(response: AxiosResponse): Promise<Document[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Document.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Document[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Document[]>(null as any);
    }

    /**
     * @param fileName (optional) 
     * @param documentType (optional) 
     * @param twinId (optional) 
     * @return OK
     */
    putDocument(fileName: string | undefined, documentType: string | undefined, twinId: string | undefined, cancelToken?: CancelToken): Promise<UpdateDocumentResponse> {
        let url_ = this.baseUrl + "/api/FileImport/document?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (documentType === null)
            throw new Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (twinId === null || twinId === undefined)
            throw new Error("The parameter 'twinId' cannot be null.");
        else
            content_.append("twinId", twinId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutDocument(_response);
        });
    }

    protected processPutDocument(response: AxiosResponse): Promise<UpdateDocumentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateDocumentResponse.fromJS(resultData200);
            return Promise.resolve<UpdateDocumentResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateDocumentResponse>(null as any);
    }

    /**
     * @param fileNames (optional) 
     * @return OK
     */
    getBlobUploadInfo(fileNames: string[] | undefined, cancelToken?: CancelToken): Promise<BlobUploadInfo> {
        let url_ = this.baseUrl + "/api/FileImport/getBlobUploadInfo?";
        if (fileNames === null)
            throw new Error("The parameter 'fileNames' cannot be null.");
        else if (fileNames !== undefined)
            fileNames && fileNames.forEach(item => { url_ += "fileNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBlobUploadInfo(_response);
        });
    }

    protected processGetBlobUploadInfo(response: AxiosResponse): Promise<BlobUploadInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlobUploadInfo.fromJS(resultData200);
            return Promise.resolve<BlobUploadInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlobUploadInfo>(null as any);
    }

    /**
     * @param fileNames (optional) 
     * @return OK
     */
    getTimeSeriesBlobUploadInfo(fileNames: string[] | undefined, cancelToken?: CancelToken): Promise<BlobUploadInfo> {
        let url_ = this.baseUrl + "/api/FileImport/getTimeSeriesBlobUploadInfo?";
        if (fileNames === null)
            throw new Error("The parameter 'fileNames' cannot be null.");
        else if (fileNames !== undefined)
            fileNames && fileNames.forEach(item => { url_ += "fileNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeSeriesBlobUploadInfo(_response);
        });
    }

    protected processGetTimeSeriesBlobUploadInfo(response: AxiosResponse): Promise<BlobUploadInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlobUploadInfo.fromJS(resultData200);
            return Promise.resolve<BlobUploadInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlobUploadInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    clientUploadDocument(body: Body | undefined, cancelToken?: CancelToken): Promise<CreateDocumentResponse> {
        let url_ = this.baseUrl + "/api/FileImport/clientUploadDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClientUploadDocument(_response);
        });
    }

    protected processClientUploadDocument(response: AxiosResponse): Promise<CreateDocumentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateDocumentResponse.fromJS(resultData200);
            return Promise.resolve<CreateDocumentResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateDocumentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    modelsPOST(body: GitRepoRequest | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/GitImport/models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModelsPOST(_response);
        });
    }

    protected processModelsPOST(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @return OK
     */
    getTwinGraph(body: string[], cancelToken?: CancelToken): Promise<TwinGraph> {
        let url_ = this.baseUrl + "/api/Graph/GetTwinGraph";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwinGraph(_response);
        });
    }

    protected processGetTwinGraph(response: AxiosResponse): Promise<TwinGraph> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinGraph.fromJS(resultData200);
            return Promise.resolve<TwinGraph>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinGraph>(null as any);
    }

    /**
     * @return OK
     */
    timeSeries(jobId: string, cancelToken?: CancelToken): Promise<TimeSeriesImportJob> {
        let url_ = this.baseUrl + "/api/JobStatus/timeSeries/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTimeSeries(_response);
        });
    }

    protected processTimeSeries(response: AxiosResponse): Promise<TimeSeriesImportJob> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeSeriesImportJob.fromJS(resultData200);
            return Promise.resolve<TimeSeriesImportJob>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeSeriesImportJob>(null as any);
    }

    /**
     * @return OK
     */
    cancelTimeSeriesImport(jobId: string, user_Id: string, cancelToken?: CancelToken): Promise<ActionResult> {
        let url_ = this.baseUrl + "/api/JobStatus/CancelTimeSeriesImport/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "User-Id": user_Id !== undefined && user_Id !== null ? "" + user_Id : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelTimeSeriesImport(_response);
        });
    }

    protected processCancelTimeSeriesImport(response: AxiosResponse): Promise<ActionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActionResult.fromJS(resultData200);
            return Promise.resolve<ActionResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActionResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getMappedEntries(body: MappedEntryRequest | undefined, cancelToken?: CancelToken): Promise<MappedEntryResponse> {
        let url_ = this.baseUrl + "/api/Mapping/getMappedEntries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMappedEntries(_response);
        });
    }

    protected processGetMappedEntries(response: AxiosResponse): Promise<MappedEntryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MappedEntryResponse.fromJS(resultData200);
            return Promise.resolve<MappedEntryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MappedEntryResponse>(null as any);
    }

    /**
     * @return OK
     */
    getFilterDropdown( cancelToken?: CancelToken): Promise<CombinedMappedEntriesGroupCount> {
        let url_ = this.baseUrl + "/api/Mapping/filterDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFilterDropdown(_response);
        });
    }

    protected processGetFilterDropdown(response: AxiosResponse): Promise<CombinedMappedEntriesGroupCount> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CombinedMappedEntriesGroupCount.fromJS(resultData200);
            return Promise.resolve<CombinedMappedEntriesGroupCount>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CombinedMappedEntriesGroupCount>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMappedEntry(body: CreateMappedEntry | undefined, cancelToken?: CancelToken): Promise<MappedEntry> {
        let url_ = this.baseUrl + "/api/Mapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMappedEntry(_response);
        });
    }

    protected processCreateMappedEntry(response: AxiosResponse): Promise<MappedEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MappedEntry.fromJS(resultData200);
            return Promise.resolve<MappedEntry>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MappedEntry>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putMappedEntry(body: UpdateMappedEntry | undefined, cancelToken?: CancelToken): Promise<MappedEntry> {
        let url_ = this.baseUrl + "/api/Mapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutMappedEntry(_response);
        });
    }

    protected processPutMappedEntry(response: AxiosResponse): Promise<MappedEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MappedEntry.fromJS(resultData200);
            return Promise.resolve<MappedEntry>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MappedEntry>(null as any);
    }

    /**
     * @return OK
     */
    deleteUpdateTwinRequests(body: string[], cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUpdateTwinRequests(_response);
        });
    }

    protected processDeleteUpdateTwinRequests(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param statuses (optional) 
     * @param prefixToMatchId (optional) 
     * @param excludePrefixes (optional) 
     * @return OK
     */
    getMappedEntriesCount(statuses: Status[] | undefined, prefixToMatchId: string[] | undefined, excludePrefixes: boolean | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/count?";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (prefixToMatchId === null)
            throw new Error("The parameter 'prefixToMatchId' cannot be null.");
        else if (prefixToMatchId !== undefined)
            prefixToMatchId && prefixToMatchId.forEach(item => { url_ += "prefixToMatchId=" + encodeURIComponent("" + item) + "&"; });
        if (excludePrefixes === null)
            throw new Error("The parameter 'excludePrefixes' cannot be null.");
        else if (excludePrefixes !== undefined)
            url_ += "excludePrefixes=" + encodeURIComponent("" + excludePrefixes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMappedEntriesCount(_response);
        });
    }

    protected processGetMappedEntriesCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param status (optional) 
     * @param body (optional) 
     * @return OK
     */
    changeMappedEntriesStatus(status: Status | undefined, body: string[] | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/changeMappedEntriesStatus?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeMappedEntriesStatus(_response);
        });
    }

    protected processChangeMappedEntriesStatus(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param status (optional) 
     * @param body (optional) 
     * @return OK
     */
    updateAllstatus(status: Status | undefined, body: MappedEntryAllRequest | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/updateAllstatus?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAllstatus(_response);
        });
    }

    protected processUpdateAllstatus(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    deleteBulk(body: string[], cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/deleteBulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteBulk(_response);
        });
    }

    protected processDeleteBulk(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteAll(body: MappedEntryAllRequest | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/deleteAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param offset (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getUpdateTwinRequests(offset: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<UpdateMappedTwinRequestResponse[]> {
        let url_ = this.baseUrl + "/api/Mapping/getUpdateTwinRequests?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUpdateTwinRequests(_response);
        });
    }

    protected processGetUpdateTwinRequests(response: AxiosResponse): Promise<UpdateMappedTwinRequestResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UpdateMappedTwinRequestResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UpdateMappedTwinRequestResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMappedTwinRequestResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    createUpdateTwinRequests(willowTwinId: string, body: JsonPatchOperation[], cancelToken?: CancelToken): Promise<UpdateMappedTwinRequest> {
        let url_ = this.baseUrl + "/api/Mapping/createUpdateTwinRequests?";
        if (willowTwinId === undefined || willowTwinId === null)
            throw new Error("The parameter 'willowTwinId' must be defined and cannot be null.");
        else
            url_ += "willowTwinId=" + encodeURIComponent("" + willowTwinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUpdateTwinRequests(_response);
        });
    }

    protected processCreateUpdateTwinRequests(response: AxiosResponse): Promise<UpdateMappedTwinRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateMappedTwinRequest.fromJS(resultData200);
            return Promise.resolve<UpdateMappedTwinRequest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMappedTwinRequest>(null as any);
    }

    /**
     * @return OK
     */
    updateTwinUpdateRequest(id: string, body: JsonPatchOperation[], cancelToken?: CancelToken): Promise<UpdateMappedTwinRequest> {
        let url_ = this.baseUrl + "/api/Mapping/UpdateTwinUpdateRequest?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTwinUpdateRequest(_response);
        });
    }

    protected processUpdateTwinUpdateRequest(response: AxiosResponse): Promise<UpdateMappedTwinRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateMappedTwinRequest.fromJS(resultData200);
            return Promise.resolve<UpdateMappedTwinRequest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMappedTwinRequest>(null as any);
    }

    /**
     * @return OK
     */
    upsertUpdateTwinRequest(willowTwinId: string, body: JsonPatchOperation[], cancelToken?: CancelToken): Promise<UpdateMappedTwinRequest> {
        let url_ = this.baseUrl + "/api/Mapping/UpsertUpdateTwinRequest?";
        if (willowTwinId === undefined || willowTwinId === null)
            throw new Error("The parameter 'willowTwinId' must be defined and cannot be null.");
        else
            url_ += "willowTwinId=" + encodeURIComponent("" + willowTwinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpsertUpdateTwinRequest(_response);
        });
    }

    protected processUpsertUpdateTwinRequest(response: AxiosResponse): Promise<UpdateMappedTwinRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateMappedTwinRequest.fromJS(resultData200);
            return Promise.resolve<UpdateMappedTwinRequest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMappedTwinRequest>(null as any);
    }

    /**
     * @return OK
     */
    getUpdateTwinRequestsCount( cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/UpdateTwinRequestsCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUpdateTwinRequestsCount(_response);
        });
    }

    protected processGetUpdateTwinRequestsCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    deleteAllUpdateTwinRequests( cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Mapping/deleteAllUpdateTwinRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllUpdateTwinRequests(_response);
        });
    }

    protected processDeleteAllUpdateTwinRequests(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param rootModel (optional) 
     * @param sourceType (optional) 
     * @return OK
     */
    getModels(rootModel: string | undefined, sourceType: SourceType | undefined, cancelToken?: CancelToken): Promise<InterfaceTwinsInfo[]> {
        let url_ = this.baseUrl + "/api/Models/GetModels?";
        if (rootModel === null)
            throw new Error("The parameter 'rootModel' cannot be null.");
        else if (rootModel !== undefined)
            url_ += "rootModel=" + encodeURIComponent("" + rootModel) + "&";
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetModels(_response);
        });
    }

    protected processGetModels(response: AxiosResponse): Promise<InterfaceTwinsInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InterfaceTwinsInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InterfaceTwinsInfo[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InterfaceTwinsInfo[]>(null as any);
    }

    /**
     * @param autoApprove (optional) 
     * @return OK
     */
    syncOrganization(autoApprove: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MTI/SyncOrganization?";
        if (autoApprove === null)
            throw new Error("The parameter 'autoApprove' cannot be null.");
        else if (autoApprove !== undefined)
            url_ += "autoApprove=" + encodeURIComponent("" + autoApprove) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncOrganization(_response);
        });
    }

    protected processSyncOrganization(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param autoApprove (optional) 
     * @param body (optional) 
     * @return OK
     */
    syncSpatial(autoApprove: boolean | undefined, body: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MTI/SyncSpatial?";
        if (autoApprove === null)
            throw new Error("The parameter 'autoApprove' cannot be null.");
        else if (autoApprove !== undefined)
            url_ += "autoApprove=" + encodeURIComponent("" + autoApprove) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncSpatial(_response);
        });
    }

    protected processSyncSpatial(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param connectorId (optional) 
     * @param autoApprove (optional) 
     * @param body (optional) 
     * @return OK
     */
    syncAssets(connectorId: string | undefined, autoApprove: boolean | undefined, body: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MTI/SyncAssets?";
        if (connectorId === null)
            throw new Error("The parameter 'connectorId' cannot be null.");
        else if (connectorId !== undefined)
            url_ += "connectorId=" + encodeURIComponent("" + connectorId) + "&";
        if (autoApprove === null)
            throw new Error("The parameter 'autoApprove' cannot be null.");
        else if (autoApprove !== undefined)
            url_ += "autoApprove=" + encodeURIComponent("" + autoApprove) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncAssets(_response);
        });
    }

    protected processSyncAssets(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param connectorId (optional) 
     * @param autoApprove (optional) 
     * @param matchStdPntList (optional) 
     * @param body (optional) 
     * @return OK
     */
    syncCapabilities(connectorId: string | undefined, autoApprove: boolean | undefined, matchStdPntList: boolean | undefined, body: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MTI/SyncCapabilities?";
        if (connectorId === null)
            throw new Error("The parameter 'connectorId' cannot be null.");
        else if (connectorId !== undefined)
            url_ += "connectorId=" + encodeURIComponent("" + connectorId) + "&";
        if (autoApprove === null)
            throw new Error("The parameter 'autoApprove' cannot be null.");
        else if (autoApprove !== undefined)
            url_ += "autoApprove=" + encodeURIComponent("" + autoApprove) + "&";
        if (matchStdPntList === null)
            throw new Error("The parameter 'matchStdPntList' cannot be null.");
        else if (matchStdPntList !== undefined)
            url_ += "matchStdPntList=" + encodeURIComponent("" + matchStdPntList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncCapabilities(_response);
        });
    }

    protected processSyncCapabilities(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param jobId (optional) 
     * @param status (optional) 
     * @return OK
     */
    findMtiAsyncJob(jobId: string | undefined, status: AsyncJobStatus | undefined, cancelToken?: CancelToken): Promise<MtiAsyncJob[]> {
        let url_ = this.baseUrl + "/api/MTI/FindMtiAsyncJob?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindMtiAsyncJob(_response);
        });
    }

    protected processFindMtiAsyncJob(response: AxiosResponse): Promise<MtiAsyncJob[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MtiAsyncJob.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MtiAsyncJob[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MtiAsyncJob[]>(null as any);
    }

    /**
     * @param status (optional) 
     * @return OK
     */
    getLatestMtiAsyncJob(status: AsyncJobStatus | undefined, cancelToken?: CancelToken): Promise<MtiAsyncJob> {
        let url_ = this.baseUrl + "/api/MTI/getLatestMtiAsyncJob?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLatestMtiAsyncJob(_response);
        });
    }

    protected processGetLatestMtiAsyncJob(response: AxiosResponse): Promise<MtiAsyncJob> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MtiAsyncJob.fromJS(resultData200);
            return Promise.resolve<MtiAsyncJob>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MtiAsyncJob>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMtiAsyncJob(body: MtiAsyncJobRequest | undefined, cancelToken?: CancelToken): Promise<MtiAsyncJob> {
        let url_ = this.baseUrl + "/api/MTI/CreateMtiAsyncJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMtiAsyncJob(_response);
        });
    }

    protected processCreateMtiAsyncJob(response: AxiosResponse): Promise<MtiAsyncJob> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MtiAsyncJob.fromJS(resultData200);
            return Promise.resolve<MtiAsyncJob>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MtiAsyncJob>(null as any);
    }

    /**
     * @param searchQuery (optional) 
     * @param mode (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    document(searchQuery: string | undefined, mode: DocumentSearchMode | undefined, skip: number | undefined, take: number | undefined, cancelToken?: CancelToken): Promise<DocumentSearchResponse> {
        let url_ = this.baseUrl + "/api/Search/Document?";
        if (searchQuery === null)
            throw new Error("The parameter 'searchQuery' cannot be null.");
        else if (searchQuery !== undefined)
            url_ += "searchQuery=" + encodeURIComponent("" + searchQuery) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocument(_response);
        });
    }

    protected processDocument(response: AxiosResponse): Promise<DocumentSearchResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentSearchResponse.fromJS(resultData200);
            return Promise.resolve<DocumentSearchResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentSearchResponse>(null as any);
    }

    /**
     * @param modelIds (optional) 
     * @param locationId (optional) 
     * @param exactModelMatch (optional) 
     * @param includeRelationships (optional) 
     * @param includeIncomingRelationships (optional) 
     * @param searchString (optional) 
     * @param pageSize (optional) 
     * @param continuationToken (optional) 
     * @param sourceType (optional) 
     * @param includeTotalCount (optional) 
     * @return OK
     */
    getTwins(modelIds: string[] | undefined, locationId: string | undefined, exactModelMatch: boolean | undefined, includeRelationships: boolean | undefined, includeIncomingRelationships: boolean | undefined, searchString: string | undefined, pageSize: number | undefined, continuationToken: string | undefined, sourceType: SourceType | undefined, includeTotalCount: boolean | undefined, cancelToken?: CancelToken): Promise<TwinWithRelationshipsPage> {
        let url_ = this.baseUrl + "/api/Twins?";
        if (modelIds === null)
            throw new Error("The parameter 'modelIds' cannot be null.");
        else if (modelIds !== undefined)
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (exactModelMatch === null)
            throw new Error("The parameter 'exactModelMatch' cannot be null.");
        else if (exactModelMatch !== undefined)
            url_ += "exactModelMatch=" + encodeURIComponent("" + exactModelMatch) + "&";
        if (includeRelationships === null)
            throw new Error("The parameter 'includeRelationships' cannot be null.");
        else if (includeRelationships !== undefined)
            url_ += "includeRelationships=" + encodeURIComponent("" + includeRelationships) + "&";
        if (includeIncomingRelationships === null)
            throw new Error("The parameter 'includeIncomingRelationships' cannot be null.");
        else if (includeIncomingRelationships !== undefined)
            url_ += "includeIncomingRelationships=" + encodeURIComponent("" + includeIncomingRelationships) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        if (includeTotalCount === null)
            throw new Error("The parameter 'includeTotalCount' cannot be null.");
        else if (includeTotalCount !== undefined)
            url_ += "includeTotalCount=" + encodeURIComponent("" + includeTotalCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "continuationToken": continuationToken !== undefined && continuationToken !== null ? "" + continuationToken : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwins(_response);
        });
    }

    protected processGetTwins(response: AxiosResponse): Promise<TwinWithRelationshipsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinWithRelationshipsPage.fromJS(resultData200);
            return Promise.resolve<TwinWithRelationshipsPage>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinWithRelationshipsPage>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param continuationToken (optional) 
     * @param includeTotalCount (optional) 
     * @return OK
     */
    queryTwins(pageSize: number | undefined, continuationToken: string | undefined, includeTotalCount: boolean | undefined, body: GetTwinsInfoRequestBFF, cancelToken?: CancelToken): Promise<TwinWithRelationshipsPage> {
        let url_ = this.baseUrl + "/api/Twins?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (includeTotalCount === null)
            throw new Error("The parameter 'includeTotalCount' cannot be null.");
        else if (includeTotalCount !== undefined)
            url_ += "includeTotalCount=" + encodeURIComponent("" + includeTotalCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "continuationToken": continuationToken !== undefined && continuationToken !== null ? "" + continuationToken : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQueryTwins(_response);
        });
    }

    protected processQueryTwins(response: AxiosResponse): Promise<TwinWithRelationshipsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinWithRelationshipsPage.fromJS(resultData200);
            return Promise.resolve<TwinWithRelationshipsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinWithRelationshipsPage>(null as any);
    }

    /**
     * @return OK
     */
    putTwin(body: BasicDigitalTwin, cancelToken?: CancelToken): Promise<BasicDigitalTwin> {
        let url_ = this.baseUrl + "/api/Twins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutTwin(_response);
        });
    }

    protected processPutTwin(response: AxiosResponse): Promise<BasicDigitalTwin> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BasicDigitalTwin.fromJS(resultData200);
            return Promise.resolve<BasicDigitalTwin>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BasicDigitalTwin>(null as any);
    }

    /**
     * @param sourceType (optional) 
     * @param includeRelationships (optional) 
     * @return OK
     */
    getTwinById(id: string, sourceType: SourceType | undefined, includeRelationships: boolean | undefined, cancelToken?: CancelToken): Promise<TwinWithRelationships> {
        let url_ = this.baseUrl + "/api/Twins/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        if (includeRelationships === null)
            throw new Error("The parameter 'includeRelationships' cannot be null.");
        else if (includeRelationships !== undefined)
            url_ += "includeRelationships=" + encodeURIComponent("" + includeRelationships) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwinById(_response);
        });
    }

    protected processGetTwinById(response: AxiosResponse): Promise<TwinWithRelationships> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinWithRelationships.fromJS(resultData200);
            return Promise.resolve<TwinWithRelationships>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinWithRelationships>(null as any);
    }

    /**
     * @param includeAdxUpdate (optional) 
     * @return OK
     */
    patchTwin(id: string, includeAdxUpdate: boolean | undefined, body: Operation[], cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Twins/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeAdxUpdate === null)
            throw new Error("The parameter 'includeAdxUpdate' cannot be null.");
        else if (includeAdxUpdate !== undefined)
            url_ += "includeAdxUpdate=" + encodeURIComponent("" + includeAdxUpdate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPatchTwin(_response);
        });
    }

    protected processPatchTwin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param sourceType (optional) 
     * @param includeRelationships (optional) 
     * @return OK
     */
    getTwinByIds(sourceType: SourceType | undefined, includeRelationships: boolean | undefined, body: string[], cancelToken?: CancelToken): Promise<TwinWithRelationships> {
        let url_ = this.baseUrl + "/api/Twins/ids?";
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        if (includeRelationships === null)
            throw new Error("The parameter 'includeRelationships' cannot be null.");
        else if (includeRelationships !== undefined)
            url_ += "includeRelationships=" + encodeURIComponent("" + includeRelationships) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwinByIds(_response);
        });
    }

    protected processGetTwinByIds(response: AxiosResponse): Promise<TwinWithRelationships> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwinWithRelationships.fromJS(resultData200);
            return Promise.resolve<TwinWithRelationships>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinWithRelationships>(null as any);
    }

    /**
     * @param outgoingRelationships (optional) 
     * @param incomingRelationships (optional) 
     * @param exactModelMatch (optional) 
     * @return OK
     */
    getTwinsTree(modelIds: string[], outgoingRelationships: string[] | undefined, incomingRelationships: string[] | undefined, exactModelMatch: boolean | undefined, cancelToken?: CancelToken): Promise<NestedTwin[]> {
        let url_ = this.baseUrl + "/api/Twins/GetTwinsTree?";
        if (modelIds === undefined || modelIds === null)
            throw new Error("The parameter 'modelIds' must be defined and cannot be null.");
        else
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (outgoingRelationships === null)
            throw new Error("The parameter 'outgoingRelationships' cannot be null.");
        else if (outgoingRelationships !== undefined)
            outgoingRelationships && outgoingRelationships.forEach(item => { url_ += "outgoingRelationships=" + encodeURIComponent("" + item) + "&"; });
        if (incomingRelationships === null)
            throw new Error("The parameter 'incomingRelationships' cannot be null.");
        else if (incomingRelationships !== undefined)
            incomingRelationships && incomingRelationships.forEach(item => { url_ += "incomingRelationships=" + encodeURIComponent("" + item) + "&"; });
        if (exactModelMatch === null)
            throw new Error("The parameter 'exactModelMatch' cannot be null.");
        else if (exactModelMatch !== undefined)
            url_ += "exactModelMatch=" + encodeURIComponent("" + exactModelMatch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwinsTree(_response);
        });
    }

    protected processGetTwinsTree(response: AxiosResponse): Promise<NestedTwin[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NestedTwin.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NestedTwin[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NestedTwin[]>(null as any);
    }

    /**
     * @param deleteRelationships (optional) 
     * @param body (optional) 
     * @return OK
     */
    deleteTwinsIds(deleteRelationships: boolean | undefined, body: DeleteTwinsRequest | undefined, cancelToken?: CancelToken): Promise<MultipleEntityResponse> {
        let url_ = this.baseUrl + "/api/Twins/deleteTwins?";
        if (deleteRelationships === null)
            throw new Error("The parameter 'deleteRelationships' cannot be null.");
        else if (deleteRelationships !== undefined)
            url_ += "deleteRelationships=" + encodeURIComponent("" + deleteRelationships) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteTwinsIds(_response);
        });
    }

    protected processDeleteTwinsIds(response: AxiosResponse): Promise<MultipleEntityResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MultipleEntityResponse.fromJS(resultData200);
            return Promise.resolve<MultipleEntityResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MultipleEntityResponse>(null as any);
    }

    /**
     * @param modelIds (optional) 
     * @param locationId (optional) 
     * @param exactModelMatch (optional) 
     * @param sourceType (optional) 
     * @param searchString (optional) 
     * @param isIncrementalScan (optional) 
     * @return OK
     */
    getTwinsCount(modelIds: string[] | undefined, locationId: string | undefined, exactModelMatch: boolean | undefined, sourceType: SourceType | undefined, searchString: string | undefined, isIncrementalScan: boolean | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/Twins/count?";
        if (modelIds === null)
            throw new Error("The parameter 'modelIds' cannot be null.");
        else if (modelIds !== undefined)
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (exactModelMatch === null)
            throw new Error("The parameter 'exactModelMatch' cannot be null.");
        else if (exactModelMatch !== undefined)
            url_ += "exactModelMatch=" + encodeURIComponent("" + exactModelMatch) + "&";
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (isIncrementalScan === null)
            throw new Error("The parameter 'isIncrementalScan' cannot be null.");
        else if (isIncrementalScan !== undefined)
            url_ += "isIncrementalScan=" + encodeURIComponent("" + isIncrementalScan) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTwinsCount(_response);
        });
    }

    protected processGetTwinsCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param modelIds (optional) 
     * @param sourceType (optional) 
     * @return OK
     */
    getAllTwins(modelIds: string[] | undefined, sourceType: SourceType | undefined, cancelToken?: CancelToken): Promise<TwinWithRelationships[]> {
        let url_ = this.baseUrl + "/api/Twins/getAllTwins?";
        if (modelIds === null)
            throw new Error("The parameter 'modelIds' cannot be null.");
        else if (modelIds !== undefined)
            modelIds && modelIds.forEach(item => { url_ += "modelIds=" + encodeURIComponent("" + item) + "&"; });
        if (sourceType === null)
            throw new Error("The parameter 'sourceType' cannot be null.");
        else if (sourceType !== undefined)
            url_ += "sourceType=" + encodeURIComponent("" + sourceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTwins(_response);
        });
    }

    protected processGetAllTwins(response: AxiosResponse): Promise<TwinWithRelationships[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TwinWithRelationships.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TwinWithRelationships[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwinWithRelationships[]>(null as any);
    }

    /**
     * @param includeDetails (optional) 
     * @param includeTotalCount (optional) 
     * @param body (optional) 
     * @return OK
     */
    listJobs(includeDetails: boolean | undefined, includeTotalCount: boolean | undefined, body: BatchRequestDto | undefined, cancelToken?: CancelToken): Promise<JobsResponse> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/listjobs?";
        if (includeDetails === null)
            throw new Error("The parameter 'includeDetails' cannot be null.");
        else if (includeDetails !== undefined)
            url_ += "includeDetails=" + encodeURIComponent("" + includeDetails) + "&";
        if (includeTotalCount === null)
            throw new Error("The parameter 'includeTotalCount' cannot be null.");
        else if (includeTotalCount !== undefined)
            url_ += "includeTotalCount=" + encodeURIComponent("" + includeTotalCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListJobs(_response);
        });
    }

    protected processListJobs(response: AxiosResponse): Promise<JobsResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsResponse.fromJS(resultData200);
            return Promise.resolve<JobsResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 424) {
            const _responseText = response.data;
            let result424: any = null;
            let resultData424  = _responseText;
            result424 = ErrorResponse.fromJS(resultData424);
            return throwException("Failed Dependency", status, _responseText, _headers, result424);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsResponse>(null as any);
    }

    /**
     * @return OK
     */
    getJob(jobId: string, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/getjob?";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined and cannot be null.");
        else
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @return OK
     */
    getJobtypes( cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/getJobTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJobtypes(_response);
        });
    }

    protected processGetJobtypes(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422  = _responseText;
            result422 = ErrorResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param userMessage (optional) 
     * @param body (optional) 
     * @return OK
     */
    createOnDemandJob(userMessage: string | undefined, body: any | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/createOnDemandJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "userMessage": userMessage !== undefined && userMessage !== null ? "" + userMessage : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOnDemandJob(_response);
        });
    }

    protected processCreateOnDemandJob(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createorupdateJobEntry(body: JobsEntry | undefined, cancelToken?: CancelToken): Promise<JobsEntry> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/createorupdateJobEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateorupdateJobEntry(_response);
        });
    }

    protected processCreateorupdateJobEntry(response: AxiosResponse): Promise<JobsEntry> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JobsEntry.fromJS(resultData200);
            return Promise.resolve<JobsEntry>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JobsEntry>(null as any);
    }

    /**
     * @param hardDelete (optional) 
     * @return OK
     */
    deleteJobEntries(hardDelete: boolean | undefined, body: string[], cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/deleteJobEntries?";
        if (hardDelete === null)
            throw new Error("The parameter 'hardDelete' cannot be null.");
        else if (hardDelete !== undefined)
            url_ += "hardDelete=" + encodeURIComponent("" + hardDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJobEntries(_response);
        });
    }

    protected processDeleteJobEntries(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param jobType (optional) 
     * @param hardDelete (optional) 
     * @return OK
     */
    deleteJobsOlderThan(date: Date, jobType: string | undefined, hardDelete: boolean | undefined, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/UnifiedJobs/deleteJobsOlderThan?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (jobType === null)
            throw new Error("The parameter 'jobType' cannot be null.");
        else if (jobType !== undefined)
            url_ += "jobType=" + encodeURIComponent("" + jobType) + "&";
        if (hardDelete === null)
            throw new Error("The parameter 'hardDelete' cannot be null.");
        else if (hardDelete !== undefined)
            url_ += "hardDelete=" + encodeURIComponent("" + hardDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJobsOlderThan(_response);
        });
    }

    protected processDeleteJobsOlderThan(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class ActionResult implements IActionResult {

    constructor(data?: IActionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ActionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IActionResult {
}

export class AppVersion implements IAppVersion {
    tlmAssemblyVersion?: string | undefined;
    adtApiVersion?: string | undefined;

    constructor(data?: IAppVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tlmAssemblyVersion = _data["tlmAssemblyVersion"];
            this.adtApiVersion = _data["adtApiVersion"];
        }
    }

    static fromJS(data: any): AppVersion {
        data = typeof data === 'object' ? data : {};
        let result = new AppVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlmAssemblyVersion"] = this.tlmAssemblyVersion;
        data["adtApiVersion"] = this.adtApiVersion;
        return data;
    }
}

export interface IAppVersion {
    tlmAssemblyVersion?: string | undefined;
    adtApiVersion?: string | undefined;
}

export class AsyncJobDetails implements IAsyncJobDetails {
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    status?: AsyncJobStatus;
    statusMessage?: string | undefined;

    constructor(data?: IAsyncJobDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.statusMessage = _data["statusMessage"];
        }
    }

    static fromJS(data: any): AsyncJobDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AsyncJobDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["statusMessage"] = this.statusMessage;
        return data;
    }
}

export interface IAsyncJobDetails {
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    status?: AsyncJobStatus;
    statusMessage?: string | undefined;
}

export enum AsyncJobStatus {
    Queued = "Queued",
    Processing = "Processing",
    Done = "Done",
    Error = "Error",
    Canceled = "Canceled",
    Aborted = "Aborted",
    CancelPending = "CancelPending",
    DeletePending = "DeletePending",
}

export class AuthorizationResponseDto implements IAuthorizationResponseDto {
    permissions?: string[] | undefined;
    isAdminUser?: boolean;

    constructor(data?: IAuthorizationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.isAdminUser = _data["isAdminUser"];
        }
    }

    static fromJS(data: any): AuthorizationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isAdminUser"] = this.isAdminUser;
        return data;
    }
}

export interface IAuthorizationResponseDto {
    permissions?: string[] | undefined;
    isAdminUser?: boolean;
}

export class BasicDigitalTwin implements IBasicDigitalTwin {
    $dtId?: string | undefined;
    $etag?: ETag;
    readonly $lastUpdateTime?: Date | undefined;
    $metadata?: DigitalTwinMetadata;

    [key: string]: any;

    constructor(data?: IBasicDigitalTwin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$dtId = _data["$dtId"];
            this.$etag = _data["$etag"] ? ETag.fromJS(_data["$etag"]) : <any>undefined;
            (<any>this).$lastUpdateTime = _data["$lastUpdateTime"] ? new Date(_data["$lastUpdateTime"].toString()) : <any>undefined;
            this.$metadata = _data["$metadata"] ? DigitalTwinMetadata.fromJS(_data["$metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BasicDigitalTwin {
        data = typeof data === 'object' ? data : {};
        let result = new BasicDigitalTwin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$dtId"] = this.$dtId;
        data["$etag"] = this.$etag ? this.$etag.toJSON() : <any>undefined;
        data["$lastUpdateTime"] = this.$lastUpdateTime ? this.$lastUpdateTime.toISOString() : <any>undefined;
        data["$metadata"] = this.$metadata ? this.$metadata.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBasicDigitalTwin {
    $dtId?: string | undefined;
    $etag?: ETag;
    $lastUpdateTime?: Date | undefined;
    $metadata?: DigitalTwinMetadata;

    [key: string]: any;
}

export class BasicRelationship implements IBasicRelationship {
    $relationshipId?: string | undefined;
    $targetId?: string | undefined;
    $sourceId?: string | undefined;
    $relationshipName?: string | undefined;
    $etag?: ETag;

    [key: string]: any;

    constructor(data?: IBasicRelationship) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$relationshipId = _data["$relationshipId"];
            this.$targetId = _data["$targetId"];
            this.$sourceId = _data["$sourceId"];
            this.$relationshipName = _data["$relationshipName"];
            this.$etag = _data["$etag"] ? ETag.fromJS(_data["$etag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BasicRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new BasicRelationship();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$relationshipId"] = this.$relationshipId;
        data["$targetId"] = this.$targetId;
        data["$sourceId"] = this.$sourceId;
        data["$relationshipName"] = this.$relationshipName;
        data["$etag"] = this.$etag ? this.$etag.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBasicRelationship {
    $relationshipId?: string | undefined;
    $targetId?: string | undefined;
    $sourceId?: string | undefined;
    $relationshipName?: string | undefined;
    $etag?: ETag;

    [key: string]: any;
}

export class BatchRequestDto implements IBatchRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IBatchRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): BatchRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IBatchRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
}

export class BlobUploadInfo implements IBlobUploadInfo {
    sasToken?: string | undefined;
    containerName?: string | undefined;
    blobPaths?: { [key: string]: string; } | undefined;

    constructor(data?: IBlobUploadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sasToken = _data["sasToken"];
            this.containerName = _data["containerName"];
            if (_data["blobPaths"]) {
                this.blobPaths = {} as any;
                for (let key in _data["blobPaths"]) {
                    if (_data["blobPaths"].hasOwnProperty(key))
                        (<any>this.blobPaths)![key] = _data["blobPaths"][key];
                }
            }
        }
    }

    static fromJS(data: any): BlobUploadInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BlobUploadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sasToken"] = this.sasToken;
        data["containerName"] = this.containerName;
        if (this.blobPaths) {
            data["blobPaths"] = {};
            for (let key in this.blobPaths) {
                if (this.blobPaths.hasOwnProperty(key))
                    (<any>data["blobPaths"])[key] = (<any>this.blobPaths)[key];
            }
        }
        return data;
    }
}

export interface IBlobUploadInfo {
    sasToken?: string | undefined;
    containerName?: string | undefined;
    blobPaths?: { [key: string]: string; } | undefined;
}

export enum CheckType {
    DataQualityRule = "DataQualityRule",
    Properties = "Properties",
    Relationships = "Relationships",
    Telemetry = "Telemetry",
}

export class CombinedMappedEntriesGroupCount implements ICombinedMappedEntriesGroupCount {
    buildingIdGroupedEntries?: MappedEntriesGroupCount[] | undefined;
    connectorIdGroupedEntries?: MappedEntriesGroupCount[] | undefined;

    constructor(data?: ICombinedMappedEntriesGroupCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["buildingIdGroupedEntries"])) {
                this.buildingIdGroupedEntries = [] as any;
                for (let item of _data["buildingIdGroupedEntries"])
                    this.buildingIdGroupedEntries!.push(MappedEntriesGroupCount.fromJS(item));
            }
            if (Array.isArray(_data["connectorIdGroupedEntries"])) {
                this.connectorIdGroupedEntries = [] as any;
                for (let item of _data["connectorIdGroupedEntries"])
                    this.connectorIdGroupedEntries!.push(MappedEntriesGroupCount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CombinedMappedEntriesGroupCount {
        data = typeof data === 'object' ? data : {};
        let result = new CombinedMappedEntriesGroupCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.buildingIdGroupedEntries)) {
            data["buildingIdGroupedEntries"] = [];
            for (let item of this.buildingIdGroupedEntries)
                data["buildingIdGroupedEntries"].push(item.toJSON());
        }
        if (Array.isArray(this.connectorIdGroupedEntries)) {
            data["connectorIdGroupedEntries"] = [];
            for (let item of this.connectorIdGroupedEntries)
                data["connectorIdGroupedEntries"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICombinedMappedEntriesGroupCount {
    buildingIdGroupedEntries?: MappedEntriesGroupCount[] | undefined;
    connectorIdGroupedEntries?: MappedEntriesGroupCount[] | undefined;
}

export class CopilotChatRequest implements ICopilotChatRequest {
    userInput?: string | undefined;
    context?: CopilotContext;
    options?: CopilotChatRequestOption;

    constructor(data?: ICopilotChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userInput = _data["userInput"];
            this.context = _data["context"] ? CopilotContext.fromJS(_data["context"]) : <any>undefined;
            this.options = _data["options"] ? CopilotChatRequestOption.fromJS(_data["options"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CopilotChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CopilotChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userInput"] = this.userInput;
        data["context"] = this.context ? this.context.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICopilotChatRequest {
    userInput?: string | undefined;
    context?: CopilotContext;
    options?: CopilotChatRequestOption;
}

export class CopilotChatRequestOption implements ICopilotChatRequestOption {
    modelHint?: string | undefined;
    promptHints?: string[] | undefined;
    runFlags?: string[] | undefined;

    constructor(data?: ICopilotChatRequestOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelHint = _data["modelHint"];
            if (Array.isArray(_data["promptHints"])) {
                this.promptHints = [] as any;
                for (let item of _data["promptHints"])
                    this.promptHints!.push(item);
            }
            if (Array.isArray(_data["runFlags"])) {
                this.runFlags = [] as any;
                for (let item of _data["runFlags"])
                    this.runFlags!.push(item);
            }
        }
    }

    static fromJS(data: any): CopilotChatRequestOption {
        data = typeof data === 'object' ? data : {};
        let result = new CopilotChatRequestOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelHint"] = this.modelHint;
        if (Array.isArray(this.promptHints)) {
            data["promptHints"] = [];
            for (let item of this.promptHints)
                data["promptHints"].push(item);
        }
        if (Array.isArray(this.runFlags)) {
            data["runFlags"] = [];
            for (let item of this.runFlags)
                data["runFlags"].push(item);
        }
        return data;
    }
}

export interface ICopilotChatRequestOption {
    modelHint?: string | undefined;
    promptHints?: string[] | undefined;
    runFlags?: string[] | undefined;
}

export class CopilotChatResponse implements ICopilotChatResponse {
    responseText?: string | undefined;

    constructor(data?: ICopilotChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseText = _data["responseText"];
        }
    }

    static fromJS(data: any): CopilotChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CopilotChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseText"] = this.responseText;
        return data;
    }
}

export interface ICopilotChatResponse {
    responseText?: string | undefined;
}

export class CopilotContext implements ICopilotContext {
    sessionId?: string | undefined;
    userName?: string | undefined;

    constructor(data?: ICopilotContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CopilotContext {
        data = typeof data === 'object' ? data : {};
        let result = new CopilotContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICopilotContext {
    sessionId?: string | undefined;
    userName?: string | undefined;
}

export class CreateDocumentResponse implements ICreateDocumentResponse {
    fileName?: string | undefined;
    isSuccessful?: boolean;
    twinId?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: ICreateDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.isSuccessful = _data["isSuccessful"];
            this.twinId = _data["twinId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CreateDocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["isSuccessful"] = this.isSuccessful;
        data["twinId"] = this.twinId;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ICreateDocumentResponse {
    fileName?: string | undefined;
    isSuccessful?: boolean;
    twinId?: string | undefined;
    errorMessage?: string | undefined;
}

export class CreateMappedEntry implements ICreateMappedEntry {
    mappedId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    willowId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;

    constructor(data?: ICreateMappedEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappedId = _data["mappedId"];
            this.mappedModelId = _data["mappedModelId"];
            this.willowModelId = _data["willowModelId"];
            this.parentMappedId = _data["parentMappedId"];
            this.parentWillowId = _data["parentWillowId"];
            this.willowParentRel = _data["willowParentRel"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.modelInformation = _data["modelInformation"];
            this.statusNotes = _data["statusNotes"];
            this.status = _data["status"];
            this.auditInformation = _data["auditInformation"];
            this.connectorId = _data["connectorId"];
            this.buildingId = _data["buildingId"];
            this.willowId = _data["willowId"];
            this.isExistingTwin = _data["isExistingTwin"];
            this.unit = _data["unit"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): CreateMappedEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMappedEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappedId"] = this.mappedId;
        data["mappedModelId"] = this.mappedModelId;
        data["willowModelId"] = this.willowModelId;
        data["parentMappedId"] = this.parentMappedId;
        data["parentWillowId"] = this.parentWillowId;
        data["willowParentRel"] = this.willowParentRel;
        data["name"] = this.name;
        data["description"] = this.description;
        data["modelInformation"] = this.modelInformation;
        data["statusNotes"] = this.statusNotes;
        data["status"] = this.status;
        data["auditInformation"] = this.auditInformation;
        data["connectorId"] = this.connectorId;
        data["buildingId"] = this.buildingId;
        data["willowId"] = this.willowId;
        data["isExistingTwin"] = this.isExistingTwin;
        data["unit"] = this.unit;
        data["dataType"] = this.dataType;
        return data;
    }
}

export interface ICreateMappedEntry {
    mappedId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    willowId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;
}

export class DeleteTwinsRequest implements IDeleteTwinsRequest {
    twinIDs?: string[] | undefined;
    externalIDs?: string[] | undefined;

    constructor(data?: IDeleteTwinsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["twinIDs"])) {
                this.twinIDs = [] as any;
                for (let item of _data["twinIDs"])
                    this.twinIDs!.push(item);
            }
            if (Array.isArray(_data["externalIDs"])) {
                this.externalIDs = [] as any;
                for (let item of _data["externalIDs"])
                    this.externalIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteTwinsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTwinsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.twinIDs)) {
            data["twinIDs"] = [];
            for (let item of this.twinIDs)
                data["twinIDs"].push(item);
        }
        if (Array.isArray(this.externalIDs)) {
            data["externalIDs"] = [];
            for (let item of this.externalIDs)
                data["externalIDs"].push(item);
        }
        return data;
    }
}

export interface IDeleteTwinsRequest {
    twinIDs?: string[] | undefined;
    externalIDs?: string[] | undefined;
}

export class DigitalTwinMetadata implements IDigitalTwinMetadata {
    $model?: string | undefined;
    propertyMetadata?: { [key: string]: DigitalTwinPropertyMetadata; } | undefined;

    constructor(data?: IDigitalTwinMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.$model = _data["$model"];
            if (_data["propertyMetadata"]) {
                this.propertyMetadata = {} as any;
                for (let key in _data["propertyMetadata"]) {
                    if (_data["propertyMetadata"].hasOwnProperty(key))
                        (<any>this.propertyMetadata)![key] = _data["propertyMetadata"][key] ? DigitalTwinPropertyMetadata.fromJS(_data["propertyMetadata"][key]) : new DigitalTwinPropertyMetadata();
                }
            }
        }
    }

    static fromJS(data: any): DigitalTwinMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalTwinMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$model"] = this.$model;
        if (this.propertyMetadata) {
            data["propertyMetadata"] = {};
            for (let key in this.propertyMetadata) {
                if (this.propertyMetadata.hasOwnProperty(key))
                    (<any>data["propertyMetadata"])[key] = this.propertyMetadata[key] ? this.propertyMetadata[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IDigitalTwinMetadata {
    $model?: string | undefined;
    propertyMetadata?: { [key: string]: DigitalTwinPropertyMetadata; } | undefined;
}

export class DigitalTwinPropertyMetadata implements IDigitalTwinPropertyMetadata {
    lastUpdateTime?: Date;
    sourceTime?: Date | undefined;

    constructor(data?: IDigitalTwinPropertyMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastUpdateTime = _data["lastUpdateTime"] ? new Date(_data["lastUpdateTime"].toString()) : <any>undefined;
            this.sourceTime = _data["sourceTime"] ? new Date(_data["sourceTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DigitalTwinPropertyMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalTwinPropertyMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["sourceTime"] = this.sourceTime ? this.sourceTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDigitalTwinPropertyMetadata {
    lastUpdateTime?: Date;
    sourceTime?: Date | undefined;
}

export class Document implements IDocument {
    id?: string | undefined;
    uniqueId?: string | undefined;
    fileName?: string | undefined;
    url?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    documentType?: string | undefined;
    siteName?: string | undefined;
    siteId?: string | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uniqueId = _data["uniqueId"];
            this.fileName = _data["fileName"];
            this.url = _data["url"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.documentType = _data["documentType"];
            this.siteName = _data["siteName"];
            this.siteId = _data["siteId"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["fileName"] = this.fileName;
        data["url"] = this.url;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["documentType"] = this.documentType;
        data["siteName"] = this.siteName;
        data["siteId"] = this.siteId;
        return data;
    }
}

export interface IDocument {
    id?: string | undefined;
    uniqueId?: string | undefined;
    fileName?: string | undefined;
    url?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    documentType?: string | undefined;
    siteName?: string | undefined;
    siteId?: string | undefined;
}

export enum DocumentSearchMode {
    Keyword = "Keyword",
    Vector = "Vector",
    Hybrid = "Hybrid",
}

export class DocumentSearchResponse implements IDocumentSearchResponse {
    skip?: number;
    take?: number;
    totalCount?: number;
    results?: { [key: string]: DocumentSearchResult; } | undefined;

    constructor(data?: IDocumentSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.totalCount = _data["totalCount"];
            if (_data["results"]) {
                this.results = {} as any;
                for (let key in _data["results"]) {
                    if (_data["results"].hasOwnProperty(key))
                        (<any>this.results)![key] = _data["results"][key] ? DocumentSearchResult.fromJS(_data["results"][key]) : new DocumentSearchResult();
                }
            }
        }
    }

    static fromJS(data: any): DocumentSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["totalCount"] = this.totalCount;
        if (this.results) {
            data["results"] = {};
            for (let key in this.results) {
                if (this.results.hasOwnProperty(key))
                    (<any>data["results"])[key] = this.results[key] ? this.results[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IDocumentSearchResponse {
    skip?: number;
    take?: number;
    totalCount?: number;
    results?: { [key: string]: DocumentSearchResult; } | undefined;
}

export class DocumentSearchResult implements IDocumentSearchResult {
    score?: number;
    id?: string | undefined;
    chunks?: ScoredDocumentChunk[] | undefined;
    title?: string | undefined;
    path?: string | undefined;
    lastModified?: Date | undefined;

    constructor(data?: IDocumentSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            this.id = _data["id"];
            if (Array.isArray(_data["chunks"])) {
                this.chunks = [] as any;
                for (let item of _data["chunks"])
                    this.chunks!.push(ScoredDocumentChunk.fromJS(item));
            }
            this.title = _data["title"];
            this.path = _data["path"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["id"] = this.id;
        if (Array.isArray(this.chunks)) {
            data["chunks"] = [];
            for (let item of this.chunks)
                data["chunks"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["path"] = this.path;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocumentSearchResult {
    score?: number;
    id?: string | undefined;
    chunks?: ScoredDocumentChunk[] | undefined;
    title?: string | undefined;
    path?: string | undefined;
    lastModified?: Date | undefined;
}

export class ETag implements IETag {

    constructor(data?: IETag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ETag {
        data = typeof data === 'object' ? data : {};
        let result = new ETag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IETag {
}

export class EntityResponse implements IEntityResponse {
    statusCode?: HttpStatusCode;
    entityId?: string | undefined;
    operation?: string | undefined;
    message?: string | undefined;
    subEntityId?: string | undefined;

    constructor(data?: IEntityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.entityId = _data["entityId"];
            this.operation = _data["operation"];
            this.message = _data["message"];
            this.subEntityId = _data["subEntityId"];
        }
    }

    static fromJS(data: any): EntityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["entityId"] = this.entityId;
        data["operation"] = this.operation;
        data["message"] = this.message;
        data["subEntityId"] = this.subEntityId;
        return data;
    }
}

export interface IEntityResponse {
    statusCode?: HttpStatusCode;
    entityId?: string | undefined;
    operation?: string | undefined;
    message?: string | undefined;
    subEntityId?: string | undefined;
}

export enum EntityType {
    Twins = "Twins",
    Relationships = "Relationships",
    Models = "Models",
    Unknown = "Unknown",
}

export class ErrorResponse implements IErrorResponse {
    statusCode?: number;
    message?: string | undefined;
    data?: any | undefined;
    callStack?: string[] | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
            if (Array.isArray(_data["callStack"])) {
                this.callStack = [] as any;
                for (let item of _data["callStack"])
                    this.callStack!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        if (Array.isArray(this.callStack)) {
            data["callStack"] = [];
            for (let item of this.callStack)
                data["callStack"].push(item);
        }
        return data;
    }
}

export interface IErrorResponse {
    statusCode?: number;
    message?: string | undefined;
    data?: any | undefined;
    callStack?: string[] | undefined;
}

export class FilterSpecificationDto implements IFilterSpecificationDto {
    field!: string;
    operator!: string;
    value?: any | undefined;

    constructor(data?: IFilterSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.operator = _data["operator"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilterSpecificationDto {
    field: string;
    operator: string;
    value?: any | undefined;
}

export class GetRulesResponse implements IGetRulesResponse {
    rules?: RuleTemplate[] | undefined;

    constructor(data?: IGetRulesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(RuleTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRulesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetRulesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRulesResponse {
    rules?: RuleTemplate[] | undefined;
}

export class GetTwinsInfoRequestBFF implements IGetTwinsInfoRequestBFF {
    modelId?: string[] | undefined;
    locationId?: string | undefined;
    exactModelMatch?: boolean;
    includeRelationships?: boolean;
    includeIncomingRelationships?: boolean;
    orphanOnly?: boolean;
    sourceType?: SourceType;
    relationshipsToTraverse?: string[] | undefined;
    searchString?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    queryFilter?: QueryFilter;
    filterSpecifications?: TwinFilterSpecificationDto[] | undefined;

    constructor(data?: IGetTwinsInfoRequestBFF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["modelId"])) {
                this.modelId = [] as any;
                for (let item of _data["modelId"])
                    this.modelId!.push(item);
            }
            this.locationId = _data["locationId"];
            this.exactModelMatch = _data["exactModelMatch"];
            this.includeRelationships = _data["includeRelationships"];
            this.includeIncomingRelationships = _data["includeIncomingRelationships"];
            this.orphanOnly = _data["orphanOnly"];
            this.sourceType = _data["sourceType"];
            if (Array.isArray(_data["relationshipsToTraverse"])) {
                this.relationshipsToTraverse = [] as any;
                for (let item of _data["relationshipsToTraverse"])
                    this.relationshipsToTraverse!.push(item);
            }
            this.searchString = _data["searchString"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.queryFilter = _data["queryFilter"] ? QueryFilter.fromJS(_data["queryFilter"]) : <any>undefined;
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(TwinFilterSpecificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTwinsInfoRequestBFF {
        data = typeof data === 'object' ? data : {};
        let result = new GetTwinsInfoRequestBFF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.modelId)) {
            data["modelId"] = [];
            for (let item of this.modelId)
                data["modelId"].push(item);
        }
        data["locationId"] = this.locationId;
        data["exactModelMatch"] = this.exactModelMatch;
        data["includeRelationships"] = this.includeRelationships;
        data["includeIncomingRelationships"] = this.includeIncomingRelationships;
        data["orphanOnly"] = this.orphanOnly;
        data["sourceType"] = this.sourceType;
        if (Array.isArray(this.relationshipsToTraverse)) {
            data["relationshipsToTraverse"] = [];
            for (let item of this.relationshipsToTraverse)
                data["relationshipsToTraverse"].push(item);
        }
        data["searchString"] = this.searchString;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["queryFilter"] = this.queryFilter ? this.queryFilter.toJSON() : <any>undefined;
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTwinsInfoRequestBFF {
    modelId?: string[] | undefined;
    locationId?: string | undefined;
    exactModelMatch?: boolean;
    includeRelationships?: boolean;
    includeIncomingRelationships?: boolean;
    orphanOnly?: boolean;
    sourceType?: SourceType;
    relationshipsToTraverse?: string[] | undefined;
    searchString?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    queryFilter?: QueryFilter;
    filterSpecifications?: TwinFilterSpecificationDto[] | undefined;
}

export class GitRepoRequest implements IGitRepoRequest {
    folderPath!: string;
    branchRef?: string | undefined;
    userInfo?: string | undefined;
    userId!: string;

    constructor(data?: IGitRepoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderPath = _data["folderPath"];
            this.branchRef = _data["branchRef"];
            this.userInfo = _data["userInfo"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GitRepoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GitRepoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderPath"] = this.folderPath;
        data["branchRef"] = this.branchRef;
        data["userInfo"] = this.userInfo;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGitRepoRequest {
    folderPath: string;
    branchRef?: string | undefined;
    userInfo?: string | undefined;
    userId: string;
}

export enum HttpStatusCode {
    Continue = "Continue",
    SwitchingProtocols = "SwitchingProtocols",
    Processing = "Processing",
    EarlyHints = "EarlyHints",
    OK = "OK",
    Created = "Created",
    Accepted = "Accepted",
    NonAuthoritativeInformation = "NonAuthoritativeInformation",
    NoContent = "NoContent",
    ResetContent = "ResetContent",
    PartialContent = "PartialContent",
    MultiStatus = "MultiStatus",
    AlreadyReported = "AlreadyReported",
    IMUsed = "IMUsed",
    MultipleChoices = "MultipleChoices",
    MovedPermanently = "MovedPermanently",
    Found = "Found",
    SeeOther = "SeeOther",
    NotModified = "NotModified",
    UseProxy = "UseProxy",
    Unused = "Unused",
    TemporaryRedirect = "TemporaryRedirect",
    PermanentRedirect = "PermanentRedirect",
    BadRequest = "BadRequest",
    Unauthorized = "Unauthorized",
    PaymentRequired = "PaymentRequired",
    Forbidden = "Forbidden",
    NotFound = "NotFound",
    MethodNotAllowed = "MethodNotAllowed",
    NotAcceptable = "NotAcceptable",
    ProxyAuthenticationRequired = "ProxyAuthenticationRequired",
    RequestTimeout = "RequestTimeout",
    Conflict = "Conflict",
    Gone = "Gone",
    LengthRequired = "LengthRequired",
    PreconditionFailed = "PreconditionFailed",
    RequestEntityTooLarge = "RequestEntityTooLarge",
    RequestUriTooLong = "RequestUriTooLong",
    UnsupportedMediaType = "UnsupportedMediaType",
    RequestedRangeNotSatisfiable = "RequestedRangeNotSatisfiable",
    ExpectationFailed = "ExpectationFailed",
    MisdirectedRequest = "MisdirectedRequest",
    UnprocessableEntity = "UnprocessableEntity",
    Locked = "Locked",
    FailedDependency = "FailedDependency",
    UpgradeRequired = "UpgradeRequired",
    PreconditionRequired = "PreconditionRequired",
    TooManyRequests = "TooManyRequests",
    RequestHeaderFieldsTooLarge = "RequestHeaderFieldsTooLarge",
    UnavailableForLegalReasons = "UnavailableForLegalReasons",
    InternalServerError = "InternalServerError",
    NotImplemented = "NotImplemented",
    BadGateway = "BadGateway",
    ServiceUnavailable = "ServiceUnavailable",
    GatewayTimeout = "GatewayTimeout",
    HttpVersionNotSupported = "HttpVersionNotSupported",
    VariantAlsoNegotiates = "VariantAlsoNegotiates",
    InsufficientStorage = "InsufficientStorage",
    LoopDetected = "LoopDetected",
    NotExtended = "NotExtended",
    NetworkAuthenticationRequired = "NetworkAuthenticationRequired",
}

export class ImportTimeSeriesHistoricalRequest implements IImportTimeSeriesHistoricalRequest {
    fileNames?: string[] | undefined;

    constructor(data?: IImportTimeSeriesHistoricalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fileNames"])) {
                this.fileNames = [] as any;
                for (let item of _data["fileNames"])
                    this.fileNames!.push(item);
            }
        }
    }

    static fromJS(data: any): ImportTimeSeriesHistoricalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTimeSeriesHistoricalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fileNames)) {
            data["fileNames"] = [];
            for (let item of this.fileNames)
                data["fileNames"].push(item);
        }
        return data;
    }
}

export interface IImportTimeSeriesHistoricalRequest {
    fileNames?: string[] | undefined;
}

export class InterfaceTwinsInfo implements IInterfaceTwinsInfo {
    id?: string | undefined;
    name?: string | undefined;
    exactCount?: number;
    totalCount?: number;
    description?: string | undefined;
    uploadTime?: Date | undefined;
    model?: string | undefined;

    constructor(data?: IInterfaceTwinsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.exactCount = _data["exactCount"];
            this.totalCount = _data["totalCount"];
            this.description = _data["description"];
            this.uploadTime = _data["uploadTime"] ? new Date(_data["uploadTime"].toString()) : <any>undefined;
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): InterfaceTwinsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InterfaceTwinsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["exactCount"] = this.exactCount;
        data["totalCount"] = this.totalCount;
        data["description"] = this.description;
        data["uploadTime"] = this.uploadTime ? this.uploadTime.toISOString() : <any>undefined;
        data["model"] = this.model;
        return data;
    }
}

export interface IInterfaceTwinsInfo {
    id?: string | undefined;
    name?: string | undefined;
    exactCount?: number;
    totalCount?: number;
    description?: string | undefined;
    uploadTime?: Date | undefined;
    model?: string | undefined;
}

export class JobsEntry implements IJobsEntry {
    jobId?: string | undefined;
    parentJobId?: string | undefined;
    jobType?: string | undefined;
    userId?: string | undefined;
    status!: AsyncJobStatus;
    progressCurrentCount?: number | undefined;
    progressTotalCount?: number | undefined;
    isDeleted?: boolean;
    userMessage?: string | undefined;
    progressStatusMessage?: string | undefined;
    sourceResourceUri?: string | undefined;
    targetResourceUri?: string | undefined;
    isExternal?: boolean;
    jobSubtype?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
    processingStartTime?: Date | undefined;
    processingEndTime?: Date | undefined;
    jobsEntryDetail?: JobsEntryDetail;

    constructor(data?: IJobsEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.parentJobId = _data["parentJobId"];
            this.jobType = _data["jobType"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.progressCurrentCount = _data["progressCurrentCount"];
            this.progressTotalCount = _data["progressTotalCount"];
            this.isDeleted = _data["isDeleted"];
            this.userMessage = _data["userMessage"];
            this.progressStatusMessage = _data["progressStatusMessage"];
            this.sourceResourceUri = _data["sourceResourceUri"];
            this.targetResourceUri = _data["targetResourceUri"];
            this.isExternal = _data["isExternal"];
            this.jobSubtype = _data["jobSubtype"];
            this.timeCreated = _data["timeCreated"] ? new Date(_data["timeCreated"].toString()) : <any>undefined;
            this.timeLastUpdated = _data["timeLastUpdated"] ? new Date(_data["timeLastUpdated"].toString()) : <any>undefined;
            this.processingStartTime = _data["processingStartTime"] ? new Date(_data["processingStartTime"].toString()) : <any>undefined;
            this.processingEndTime = _data["processingEndTime"] ? new Date(_data["processingEndTime"].toString()) : <any>undefined;
            this.jobsEntryDetail = _data["jobsEntryDetail"] ? JobsEntryDetail.fromJS(_data["jobsEntryDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobsEntry {
        data = typeof data === 'object' ? data : {};
        let result = new JobsEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["parentJobId"] = this.parentJobId;
        data["jobType"] = this.jobType;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["progressCurrentCount"] = this.progressCurrentCount;
        data["progressTotalCount"] = this.progressTotalCount;
        data["isDeleted"] = this.isDeleted;
        data["userMessage"] = this.userMessage;
        data["progressStatusMessage"] = this.progressStatusMessage;
        data["sourceResourceUri"] = this.sourceResourceUri;
        data["targetResourceUri"] = this.targetResourceUri;
        data["isExternal"] = this.isExternal;
        data["jobSubtype"] = this.jobSubtype;
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["timeLastUpdated"] = this.timeLastUpdated ? this.timeLastUpdated.toISOString() : <any>undefined;
        data["processingStartTime"] = this.processingStartTime ? this.processingStartTime.toISOString() : <any>undefined;
        data["processingEndTime"] = this.processingEndTime ? this.processingEndTime.toISOString() : <any>undefined;
        data["jobsEntryDetail"] = this.jobsEntryDetail ? this.jobsEntryDetail.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJobsEntry {
    jobId?: string | undefined;
    parentJobId?: string | undefined;
    jobType?: string | undefined;
    userId?: string | undefined;
    status: AsyncJobStatus;
    progressCurrentCount?: number | undefined;
    progressTotalCount?: number | undefined;
    isDeleted?: boolean;
    userMessage?: string | undefined;
    progressStatusMessage?: string | undefined;
    sourceResourceUri?: string | undefined;
    targetResourceUri?: string | undefined;
    isExternal?: boolean;
    jobSubtype?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
    processingStartTime?: Date | undefined;
    processingEndTime?: Date | undefined;
    jobsEntryDetail?: JobsEntryDetail;
}

export class JobsEntryDetail implements IJobsEntryDetail {
    jobId?: string | undefined;
    outputsJson?: string | undefined;
    errorsJson?: string | undefined;
    inputsJson?: string | undefined;
    customData?: string | undefined;

    constructor(data?: IJobsEntryDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.outputsJson = _data["outputsJson"];
            this.errorsJson = _data["errorsJson"];
            this.inputsJson = _data["inputsJson"];
            this.customData = _data["customData"];
        }
    }

    static fromJS(data: any): JobsEntryDetail {
        data = typeof data === 'object' ? data : {};
        let result = new JobsEntryDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["outputsJson"] = this.outputsJson;
        data["errorsJson"] = this.errorsJson;
        data["inputsJson"] = this.inputsJson;
        data["customData"] = this.customData;
        return data;
    }
}

export interface IJobsEntryDetail {
    jobId?: string | undefined;
    outputsJson?: string | undefined;
    errorsJson?: string | undefined;
    inputsJson?: string | undefined;
    customData?: string | undefined;
}

export class JobsResponse implements IJobsResponse {
    totalCount?: number;
    jobs?: JobsEntry[] | undefined;

    constructor(data?: IJobsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(JobsEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JobsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJobsResponse {
    totalCount?: number;
    jobs?: JobsEntry[] | undefined;
}

export class JsonPatchOperation implements IJsonPatchOperation {
    op?: OperationType;
    path?: string | undefined;
    value?: any | undefined;

    constructor(data?: IJsonPatchOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.op = _data["op"];
            this.path = _data["path"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JsonPatchOperation {
        data = typeof data === 'object' ? data : {};
        let result = new JsonPatchOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["op"] = this.op;
        data["path"] = this.path;
        data["value"] = this.value;
        return data;
    }
}

export interface IJsonPatchOperation {
    op?: OperationType;
    path?: string | undefined;
    value?: any | undefined;
}

export class MappedEntriesGroupCount implements IMappedEntriesGroupCount {
    key?: string | undefined;
    count?: number;

    constructor(data?: IMappedEntriesGroupCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): MappedEntriesGroupCount {
        data = typeof data === 'object' ? data : {};
        let result = new MappedEntriesGroupCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data;
    }
}

export interface IMappedEntriesGroupCount {
    key?: string | undefined;
    count?: number;
}

export class MappedEntry implements IMappedEntry {
    mappedId?: string | undefined;
    willowId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;

    constructor(data?: IMappedEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappedId = _data["mappedId"];
            this.willowId = _data["willowId"];
            this.mappedModelId = _data["mappedModelId"];
            this.willowModelId = _data["willowModelId"];
            this.parentMappedId = _data["parentMappedId"];
            this.parentWillowId = _data["parentWillowId"];
            this.willowParentRel = _data["willowParentRel"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.modelInformation = _data["modelInformation"];
            this.statusNotes = _data["statusNotes"];
            this.status = _data["status"];
            this.auditInformation = _data["auditInformation"];
            this.timeCreated = _data["timeCreated"] ? new Date(_data["timeCreated"].toString()) : <any>undefined;
            this.timeLastUpdated = _data["timeLastUpdated"] ? new Date(_data["timeLastUpdated"].toString()) : <any>undefined;
            this.connectorId = _data["connectorId"];
            this.buildingId = _data["buildingId"];
            this.isExistingTwin = _data["isExistingTwin"];
            this.unit = _data["unit"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): MappedEntry {
        data = typeof data === 'object' ? data : {};
        let result = new MappedEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappedId"] = this.mappedId;
        data["willowId"] = this.willowId;
        data["mappedModelId"] = this.mappedModelId;
        data["willowModelId"] = this.willowModelId;
        data["parentMappedId"] = this.parentMappedId;
        data["parentWillowId"] = this.parentWillowId;
        data["willowParentRel"] = this.willowParentRel;
        data["name"] = this.name;
        data["description"] = this.description;
        data["modelInformation"] = this.modelInformation;
        data["statusNotes"] = this.statusNotes;
        data["status"] = this.status;
        data["auditInformation"] = this.auditInformation;
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["timeLastUpdated"] = this.timeLastUpdated ? this.timeLastUpdated.toISOString() : <any>undefined;
        data["connectorId"] = this.connectorId;
        data["buildingId"] = this.buildingId;
        data["isExistingTwin"] = this.isExistingTwin;
        data["unit"] = this.unit;
        data["dataType"] = this.dataType;
        return data;
    }
}

export interface IMappedEntry {
    mappedId?: string | undefined;
    willowId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;
}

export class MappedEntryAllRequest implements IMappedEntryAllRequest {
    prefixToMatchId?: string[] | undefined;
    excludePrefixes?: boolean | undefined;
    statuses?: Status[] | undefined;
    buildingIds?: string[] | undefined;
    connectorId?: string | undefined;

    constructor(data?: IMappedEntryAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["prefixToMatchId"])) {
                this.prefixToMatchId = [] as any;
                for (let item of _data["prefixToMatchId"])
                    this.prefixToMatchId!.push(item);
            }
            this.excludePrefixes = _data["excludePrefixes"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            if (Array.isArray(_data["buildingIds"])) {
                this.buildingIds = [] as any;
                for (let item of _data["buildingIds"])
                    this.buildingIds!.push(item);
            }
            this.connectorId = _data["connectorId"];
        }
    }

    static fromJS(data: any): MappedEntryAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MappedEntryAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.prefixToMatchId)) {
            data["prefixToMatchId"] = [];
            for (let item of this.prefixToMatchId)
                data["prefixToMatchId"].push(item);
        }
        data["excludePrefixes"] = this.excludePrefixes;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        if (Array.isArray(this.buildingIds)) {
            data["buildingIds"] = [];
            for (let item of this.buildingIds)
                data["buildingIds"].push(item);
        }
        data["connectorId"] = this.connectorId;
        return data;
    }
}

export interface IMappedEntryAllRequest {
    prefixToMatchId?: string[] | undefined;
    excludePrefixes?: boolean | undefined;
    statuses?: Status[] | undefined;
    buildingIds?: string[] | undefined;
    connectorId?: string | undefined;
}

export class MappedEntryRequest implements IMappedEntryRequest {
    offset?: number;
    pageSize?: number;
    prefixToMatchId?: string[] | undefined;
    excludePrefixes?: boolean | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;

    constructor(data?: IMappedEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["prefixToMatchId"])) {
                this.prefixToMatchId = [] as any;
                for (let item of _data["prefixToMatchId"])
                    this.prefixToMatchId!.push(item);
            }
            this.excludePrefixes = _data["excludePrefixes"];
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MappedEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MappedEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.prefixToMatchId)) {
            data["prefixToMatchId"] = [];
            for (let item of this.prefixToMatchId)
                data["prefixToMatchId"].push(item);
        }
        data["excludePrefixes"] = this.excludePrefixes;
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMappedEntryRequest {
    offset?: number;
    pageSize?: number;
    prefixToMatchId?: string[] | undefined;
    excludePrefixes?: boolean | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
}

export class MappedEntryResponse implements IMappedEntryResponse {
    total?: number;
    items?: MappedEntry[] | undefined;

    constructor(data?: IMappedEntryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MappedEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MappedEntryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MappedEntryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMappedEntryResponse {
    total?: number;
    items?: MappedEntry[] | undefined;
}

export class MtiAsyncJob implements IMtiAsyncJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    jobType?: MtiAsyncJobType;
    buildingId?: string | undefined;
    connectorId?: string | undefined;

    constructor(data?: IMtiAsyncJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.details = _data["details"] ? AsyncJobDetails.fromJS(_data["details"]) : <any>undefined;
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.lastUpdateTime = _data["lastUpdateTime"] ? new Date(_data["lastUpdateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userData = _data["userData"];
            if (Array.isArray(_data["target"])) {
                this.target = [] as any;
                for (let item of _data["target"])
                    this.target!.push(item);
            }
            this.jobType = _data["jobType"];
            this.buildingId = _data["buildingId"];
            this.connectorId = _data["connectorId"];
        }
    }

    static fromJS(data: any): MtiAsyncJob {
        data = typeof data === 'object' ? data : {};
        let result = new MtiAsyncJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userData"] = this.userData;
        if (Array.isArray(this.target)) {
            data["target"] = [];
            for (let item of this.target)
                data["target"].push(item);
        }
        data["jobType"] = this.jobType;
        data["buildingId"] = this.buildingId;
        data["connectorId"] = this.connectorId;
        return data;
    }
}

export interface IMtiAsyncJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    jobType?: MtiAsyncJobType;
    buildingId?: string | undefined;
    connectorId?: string | undefined;
}

export class MtiAsyncJobRequest implements IMtiAsyncJobRequest {
    jobType?: MtiAsyncJobType;
    buildingId?: string | undefined;
    connectorId?: string | undefined;

    constructor(data?: IMtiAsyncJobRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobType = _data["jobType"];
            this.buildingId = _data["buildingId"];
            this.connectorId = _data["connectorId"];
        }
    }

    static fromJS(data: any): MtiAsyncJobRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MtiAsyncJobRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobType"] = this.jobType;
        data["buildingId"] = this.buildingId;
        data["connectorId"] = this.connectorId;
        return data;
    }
}

export interface IMtiAsyncJobRequest {
    jobType?: MtiAsyncJobType;
    buildingId?: string | undefined;
    connectorId?: string | undefined;
}

export enum MtiAsyncJobType {
    SyncOrganization = "SyncOrganization",
    SyncSpatial = "SyncSpatial",
    SyncConnectors = "SyncConnectors",
    SyncAssets = "SyncAssets",
    SyncCapabilities = "SyncCapabilities",
    PushToMapped = "PushToMapped",
    Ingest = "Ingest",
}

export class MultipleEntityResponse implements IMultipleEntityResponse {
    responses?: EntityResponse[] | undefined;
    statusCode?: HttpStatusCode;

    constructor(data?: IMultipleEntityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["responses"])) {
                this.responses = [] as any;
                for (let item of _data["responses"])
                    this.responses!.push(EntityResponse.fromJS(item));
            }
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): MultipleEntityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleEntityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.responses)) {
            data["responses"] = [];
            for (let item of this.responses)
                data["responses"].push(item.toJSON());
        }
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IMultipleEntityResponse {
    responses?: EntityResponse[] | undefined;
    statusCode?: HttpStatusCode;
}

export class NestedTwin implements INestedTwin {
    parentId?: string | undefined;
    twin?: BasicDigitalTwin;
    children?: NestedTwin[] | undefined;

    constructor(data?: INestedTwin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.twin = _data["twin"] ? BasicDigitalTwin.fromJS(_data["twin"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(NestedTwin.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NestedTwin {
        data = typeof data === 'object' ? data : {};
        let result = new NestedTwin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["twin"] = this.twin ? this.twin.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface INestedTwin {
    parentId?: string | undefined;
    twin?: BasicDigitalTwin;
    children?: NestedTwin[] | undefined;
}

export class Operation implements IOperation {
    operationType?: OperationType;
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;
    value?: any | undefined;

    constructor(data?: IOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["operationType"];
            this.path = _data["path"];
            this.op = _data["op"];
            this.from = _data["from"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["path"] = this.path;
        data["op"] = this.op;
        data["from"] = this.from;
        data["value"] = this.value;
        return data;
    }
}

export interface IOperation {
    operationType?: OperationType;
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;
    value?: any | undefined;
}

export enum OperationType {
    Add = "Add",
    Remove = "Remove",
    Replace = "Replace",
    Move = "Move",
    Copy = "Copy",
    Test = "Test",
    Invalid = "Invalid",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class QueryFilter implements IQueryFilter {
    type?: QueryFilterType;
    filter?: string | undefined;

    constructor(data?: IQueryFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): QueryFilter {
        data = typeof data === 'object' ? data : {};
        let result = new QueryFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IQueryFilter {
    type?: QueryFilterType;
    filter?: string | undefined;
}

export enum QueryFilterType {
    Direct = "Direct",
}

export enum Result {
    Ok = "Ok",
    Error = "Error",
}

export class RuleFileUploadResponse implements IRuleFileUploadResponse {
    fileUploaded?: { [key: string]: string; } | undefined;

    constructor(data?: IRuleFileUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fileUploaded"]) {
                this.fileUploaded = {} as any;
                for (let key in _data["fileUploaded"]) {
                    if (_data["fileUploaded"].hasOwnProperty(key))
                        (<any>this.fileUploaded)![key] = _data["fileUploaded"][key];
                }
            }
        }
    }

    static fromJS(data: any): RuleFileUploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RuleFileUploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fileUploaded) {
            data["fileUploaded"] = {};
            for (let key in this.fileUploaded) {
                if (this.fileUploaded.hasOwnProperty(key))
                    (<any>data["fileUploaded"])[key] = (<any>this.fileUploaded)[key];
            }
        }
        return data;
    }
}

export interface IRuleFileUploadResponse {
    fileUploaded?: { [key: string]: string; } | undefined;
}

export class RuleTemplate implements IRuleTemplate {
    id?: string | undefined;
    exactModelOnly?: boolean;
    templateId?: string | undefined;
    primaryModelId?: string | undefined;
    name?: { [key: string]: string; } | undefined;
    description?: { [key: string]: string; } | undefined;
    properties?: RuleTemplateProperty[] | undefined;
    expressions?: RuleTemplateExpression[] | undefined;
    paths?: RuleTemplatePath[] | undefined;

    constructor(data?: IRuleTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exactModelOnly = _data["exactModelOnly"];
            this.templateId = _data["templateId"];
            this.primaryModelId = _data["primaryModelId"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        (<any>this.name)![key] = _data["name"][key];
                }
            }
            if (_data["description"]) {
                this.description = {} as any;
                for (let key in _data["description"]) {
                    if (_data["description"].hasOwnProperty(key))
                        (<any>this.description)![key] = _data["description"][key];
                }
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(RuleTemplateProperty.fromJS(item));
            }
            if (Array.isArray(_data["expressions"])) {
                this.expressions = [] as any;
                for (let item of _data["expressions"])
                    this.expressions!.push(RuleTemplateExpression.fromJS(item));
            }
            if (Array.isArray(_data["paths"])) {
                this.paths = [] as any;
                for (let item of _data["paths"])
                    this.paths!.push(RuleTemplatePath.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuleTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exactModelOnly"] = this.exactModelOnly;
        data["templateId"] = this.templateId;
        data["primaryModelId"] = this.primaryModelId;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    (<any>data["name"])[key] = (<any>this.name)[key];
            }
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    (<any>data["description"])[key] = (<any>this.description)[key];
            }
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.expressions)) {
            data["expressions"] = [];
            for (let item of this.expressions)
                data["expressions"].push(item.toJSON());
        }
        if (Array.isArray(this.paths)) {
            data["paths"] = [];
            for (let item of this.paths)
                data["paths"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRuleTemplate {
    id?: string | undefined;
    exactModelOnly?: boolean;
    templateId?: string | undefined;
    primaryModelId?: string | undefined;
    name?: { [key: string]: string; } | undefined;
    description?: { [key: string]: string; } | undefined;
    properties?: RuleTemplateProperty[] | undefined;
    expressions?: RuleTemplateExpression[] | undefined;
    paths?: RuleTemplatePath[] | undefined;
}

export class RuleTemplateExpression implements IRuleTemplateExpression {
    name?: string | undefined;
    expression?: string | undefined;

    constructor(data?: IRuleTemplateExpression) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.expression = _data["expression"];
        }
    }

    static fromJS(data: any): RuleTemplateExpression {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTemplateExpression();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["expression"] = this.expression;
        return data;
    }
}

export interface IRuleTemplateExpression {
    name?: string | undefined;
    expression?: string | undefined;
}

export class RuleTemplatePath implements IRuleTemplatePath {
    name?: string | undefined;
    match?: string | undefined;

    constructor(data?: IRuleTemplatePath) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.match = _data["match"];
        }
    }

    static fromJS(data: any): RuleTemplatePath {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTemplatePath();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["match"] = this.match;
        return data;
    }
}

export interface IRuleTemplatePath {
    name?: string | undefined;
    match?: string | undefined;
}

export class RuleTemplateProperty implements IRuleTemplateProperty {
    name?: string | undefined;
    required?: boolean;

    constructor(data?: IRuleTemplateProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): RuleTemplateProperty {
        data = typeof data === 'object' ? data : {};
        let result = new RuleTemplateProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["required"] = this.required;
        return data;
    }
}

export interface IRuleTemplateProperty {
    name?: string | undefined;
    required?: boolean;
}

export class ScoredDocumentChunk implements IScoredDocumentChunk {
    chunk?: string | undefined;
    score?: number;

    constructor(data?: IScoredDocumentChunk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chunk = _data["chunk"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ScoredDocumentChunk {
        data = typeof data === 'object' ? data : {};
        let result = new ScoredDocumentChunk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chunk"] = this.chunk;
        data["score"] = this.score;
        return data;
    }
}

export interface IScoredDocumentChunk {
    chunk?: string | undefined;
    score?: number;
}

export class SortSpecificationDto implements ISortSpecificationDto {
    field!: string;
    sort?: string | undefined;
    readonly isSortDescending?: boolean;

    constructor(data?: ISortSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.sort = _data["sort"];
            (<any>this).isSortDescending = _data["isSortDescending"];
        }
    }

    static fromJS(data: any): SortSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SortSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["sort"] = this.sort;
        data["isSortDescending"] = this.isSortDescending;
        return data;
    }
}

export interface ISortSpecificationDto {
    field: string;
    sort?: string | undefined;
    isSortDescending?: boolean;
}

export enum SourceType {
    Adx = "Adx",
    AdtQuery = "AdtQuery",
    AdtMemory = "AdtMemory",
    Acs = "Acs",
}

export class SpeechAuthorizationTokenResponse implements ISpeechAuthorizationTokenResponse {
    token?: string | undefined;
    region?: string | undefined;

    constructor(data?: ISpeechAuthorizationTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): SpeechAuthorizationTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SpeechAuthorizationTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["region"] = this.region;
        return data;
    }
}

export interface ISpeechAuthorizationTokenResponse {
    token?: string | undefined;
    region?: string | undefined;
}

export enum Status {
    Pending = "Pending",
    Approved = "Approved",
    Ignore = "Ignore",
    Created = "Created",
}

export class TimeSeriesImportJob implements ITimeSeriesImportJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    entitiesError?: { [key: string]: string; } | undefined;
    requestPath?: string | undefined;
    processedEntities?: number;
    totalEntities?: number;
    isSasUrlImport?: boolean;

    constructor(data?: ITimeSeriesImportJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.details = _data["details"] ? AsyncJobDetails.fromJS(_data["details"]) : <any>undefined;
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.lastUpdateTime = _data["lastUpdateTime"] ? new Date(_data["lastUpdateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userData = _data["userData"];
            if (Array.isArray(_data["target"])) {
                this.target = [] as any;
                for (let item of _data["target"])
                    this.target!.push(item);
            }
            if (_data["entitiesError"]) {
                this.entitiesError = {} as any;
                for (let key in _data["entitiesError"]) {
                    if (_data["entitiesError"].hasOwnProperty(key))
                        (<any>this.entitiesError)![key] = _data["entitiesError"][key];
                }
            }
            this.requestPath = _data["requestPath"];
            this.processedEntities = _data["processedEntities"];
            this.totalEntities = _data["totalEntities"];
            this.isSasUrlImport = _data["isSasUrlImport"];
        }
    }

    static fromJS(data: any): TimeSeriesImportJob {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeriesImportJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userData"] = this.userData;
        if (Array.isArray(this.target)) {
            data["target"] = [];
            for (let item of this.target)
                data["target"].push(item);
        }
        if (this.entitiesError) {
            data["entitiesError"] = {};
            for (let key in this.entitiesError) {
                if (this.entitiesError.hasOwnProperty(key))
                    (<any>data["entitiesError"])[key] = (<any>this.entitiesError)[key];
            }
        }
        data["requestPath"] = this.requestPath;
        data["processedEntities"] = this.processedEntities;
        data["totalEntities"] = this.totalEntities;
        data["isSasUrlImport"] = this.isSasUrlImport;
        return data;
    }
}

export interface ITimeSeriesImportJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    entitiesError?: { [key: string]: string; } | undefined;
    requestPath?: string | undefined;
    processedEntities?: number;
    totalEntities?: number;
    isSasUrlImport?: boolean;
}

export class TwinFilterSpecificationDto implements ITwinFilterSpecificationDto {
    field!: string;
    operator!: string;
    value?: any | undefined;

    constructor(data?: ITwinFilterSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.operator = _data["operator"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TwinFilterSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwinFilterSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["value"] = this.value;
        return data;
    }
}

export interface ITwinFilterSpecificationDto {
    field: string;
    operator: string;
    value?: any | undefined;
}

export class TwinGraph implements ITwinGraph {
    nodes?: TwinNode[] | undefined;
    edges?: TwinRelationship[] | undefined;

    constructor(data?: ITwinGraph) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(TwinNode.fromJS(item));
            }
            if (Array.isArray(_data["edges"])) {
                this.edges = [] as any;
                for (let item of _data["edges"])
                    this.edges!.push(TwinRelationship.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TwinGraph {
        data = typeof data === 'object' ? data : {};
        let result = new TwinGraph();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item.toJSON());
        }
        if (Array.isArray(this.edges)) {
            data["edges"] = [];
            for (let item of this.edges)
                data["edges"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITwinGraph {
    nodes?: TwinNode[] | undefined;
    edges?: TwinRelationship[] | undefined;
}

export class TwinNode implements ITwinNode {
    id?: number;
    twinId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelId?: string | undefined;
    phenomenon?: string | undefined;
    unit?: string | undefined;
    position?: string | undefined;
    groupKey?: string | undefined;
    groupKey2?: string | undefined;
    collapseKey?: string | undefined;

    constructor(data?: ITwinNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.twinId = _data["twinId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.modelId = _data["modelId"];
            this.phenomenon = _data["phenomenon"];
            this.unit = _data["unit"];
            this.position = _data["position"];
            this.groupKey = _data["groupKey"];
            this.groupKey2 = _data["groupKey2"];
            this.collapseKey = _data["collapseKey"];
        }
    }

    static fromJS(data: any): TwinNode {
        data = typeof data === 'object' ? data : {};
        let result = new TwinNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["twinId"] = this.twinId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["modelId"] = this.modelId;
        data["phenomenon"] = this.phenomenon;
        data["unit"] = this.unit;
        data["position"] = this.position;
        data["groupKey"] = this.groupKey;
        data["groupKey2"] = this.groupKey2;
        data["collapseKey"] = this.collapseKey;
        return data;
    }
}

export interface ITwinNode {
    id?: number;
    twinId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelId?: string | undefined;
    phenomenon?: string | undefined;
    unit?: string | undefined;
    position?: string | undefined;
    groupKey?: string | undefined;
    groupKey2?: string | undefined;
    collapseKey?: string | undefined;
}

export class TwinRelationship implements ITwinRelationship {
    readonly id?: string | undefined;
    startId?: number;
    endId?: number;
    name?: string | undefined;
    startTwinId?: string | undefined;
    endTwinId?: string | undefined;

    constructor(data?: ITwinRelationship) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.startId = _data["startId"];
            this.endId = _data["endId"];
            this.name = _data["name"];
            this.startTwinId = _data["startTwinId"];
            this.endTwinId = _data["endTwinId"];
        }
    }

    static fromJS(data: any): TwinRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new TwinRelationship();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startId"] = this.startId;
        data["endId"] = this.endId;
        data["name"] = this.name;
        data["startTwinId"] = this.startTwinId;
        data["endTwinId"] = this.endTwinId;
        return data;
    }
}

export interface ITwinRelationship {
    id?: string | undefined;
    startId?: number;
    endId?: number;
    name?: string | undefined;
    startTwinId?: string | undefined;
    endTwinId?: string | undefined;
}

export class TwinValidationJobSummaryDetailErrors implements ITwinValidationJobSummaryDetailErrors {
    numOK?: number;
    numPropertyOK?: number;
    numRelationshipOK?: number;
    numErrors?: number;
    numPropertyErrors?: number;
    numRelationshipErrors?: number;
    numUnitErrors?: number;

    constructor(data?: ITwinValidationJobSummaryDetailErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numOK = _data["numOK"];
            this.numPropertyOK = _data["numPropertyOK"];
            this.numRelationshipOK = _data["numRelationshipOK"];
            this.numErrors = _data["numErrors"];
            this.numPropertyErrors = _data["numPropertyErrors"];
            this.numRelationshipErrors = _data["numRelationshipErrors"];
            this.numUnitErrors = _data["numUnitErrors"];
        }
    }

    static fromJS(data: any): TwinValidationJobSummaryDetailErrors {
        data = typeof data === 'object' ? data : {};
        let result = new TwinValidationJobSummaryDetailErrors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numOK"] = this.numOK;
        data["numPropertyOK"] = this.numPropertyOK;
        data["numRelationshipOK"] = this.numRelationshipOK;
        data["numErrors"] = this.numErrors;
        data["numPropertyErrors"] = this.numPropertyErrors;
        data["numRelationshipErrors"] = this.numRelationshipErrors;
        data["numUnitErrors"] = this.numUnitErrors;
        return data;
    }
}

export interface ITwinValidationJobSummaryDetailErrors {
    numOK?: number;
    numPropertyOK?: number;
    numRelationshipOK?: number;
    numErrors?: number;
    numPropertyErrors?: number;
    numRelationshipErrors?: number;
    numUnitErrors?: number;
}

export class TwinValidationJobSummaryDetails implements ITwinValidationJobSummaryDetails {
    processedEntities?: number;
    modelsQueried?: string[] | undefined;
    errorsByModel?: { [key: string]: TwinValidationJobSummaryDetailErrors; } | undefined;

    constructor(data?: ITwinValidationJobSummaryDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processedEntities = _data["processedEntities"];
            if (Array.isArray(_data["modelsQueried"])) {
                this.modelsQueried = [] as any;
                for (let item of _data["modelsQueried"])
                    this.modelsQueried!.push(item);
            }
            if (_data["errorsByModel"]) {
                this.errorsByModel = {} as any;
                for (let key in _data["errorsByModel"]) {
                    if (_data["errorsByModel"].hasOwnProperty(key))
                        (<any>this.errorsByModel)![key] = _data["errorsByModel"][key] ? TwinValidationJobSummaryDetailErrors.fromJS(_data["errorsByModel"][key]) : new TwinValidationJobSummaryDetailErrors();
                }
            }
        }
    }

    static fromJS(data: any): TwinValidationJobSummaryDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TwinValidationJobSummaryDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedEntities"] = this.processedEntities;
        if (Array.isArray(this.modelsQueried)) {
            data["modelsQueried"] = [];
            for (let item of this.modelsQueried)
                data["modelsQueried"].push(item);
        }
        if (this.errorsByModel) {
            data["errorsByModel"] = {};
            for (let key in this.errorsByModel) {
                if (this.errorsByModel.hasOwnProperty(key))
                    (<any>data["errorsByModel"])[key] = this.errorsByModel[key] ? this.errorsByModel[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ITwinValidationJobSummaryDetails {
    processedEntities?: number;
    modelsQueried?: string[] | undefined;
    errorsByModel?: { [key: string]: TwinValidationJobSummaryDetailErrors; } | undefined;
}

export class TwinWithRelationships implements ITwinWithRelationships {
    twin?: BasicDigitalTwin;
    incomingRelationships?: BasicRelationship[] | undefined;
    outgoingRelationships?: BasicRelationship[] | undefined;
    twinData?: { [key: string]: any; } | undefined;

    constructor(data?: ITwinWithRelationships) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twin = _data["twin"] ? BasicDigitalTwin.fromJS(_data["twin"]) : <any>undefined;
            if (Array.isArray(_data["incomingRelationships"])) {
                this.incomingRelationships = [] as any;
                for (let item of _data["incomingRelationships"])
                    this.incomingRelationships!.push(BasicRelationship.fromJS(item));
            }
            if (Array.isArray(_data["outgoingRelationships"])) {
                this.outgoingRelationships = [] as any;
                for (let item of _data["outgoingRelationships"])
                    this.outgoingRelationships!.push(BasicRelationship.fromJS(item));
            }
            if (_data["twinData"]) {
                this.twinData = {} as any;
                for (let key in _data["twinData"]) {
                    if (_data["twinData"].hasOwnProperty(key))
                        (<any>this.twinData)![key] = _data["twinData"][key];
                }
            }
        }
    }

    static fromJS(data: any): TwinWithRelationships {
        data = typeof data === 'object' ? data : {};
        let result = new TwinWithRelationships();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twin"] = this.twin ? this.twin.toJSON() : <any>undefined;
        if (Array.isArray(this.incomingRelationships)) {
            data["incomingRelationships"] = [];
            for (let item of this.incomingRelationships)
                data["incomingRelationships"].push(item.toJSON());
        }
        if (Array.isArray(this.outgoingRelationships)) {
            data["outgoingRelationships"] = [];
            for (let item of this.outgoingRelationships)
                data["outgoingRelationships"].push(item.toJSON());
        }
        if (this.twinData) {
            data["twinData"] = {};
            for (let key in this.twinData) {
                if (this.twinData.hasOwnProperty(key))
                    (<any>data["twinData"])[key] = (<any>this.twinData)[key];
            }
        }
        return data;
    }
}

export interface ITwinWithRelationships {
    twin?: BasicDigitalTwin;
    incomingRelationships?: BasicRelationship[] | undefined;
    outgoingRelationships?: BasicRelationship[] | undefined;
    twinData?: { [key: string]: any; } | undefined;
}

export class TwinWithRelationshipsPage implements ITwinWithRelationshipsPage {
    content?: TwinWithRelationships[] | undefined;
    continuationToken?: string | undefined;

    constructor(data?: ITwinWithRelationshipsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(TwinWithRelationships.fromJS(item));
            }
            this.continuationToken = _data["continuationToken"];
        }
    }

    static fromJS(data: any): TwinWithRelationshipsPage {
        data = typeof data === 'object' ? data : {};
        let result = new TwinWithRelationshipsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["continuationToken"] = this.continuationToken;
        return data;
    }
}

export interface ITwinWithRelationshipsPage {
    content?: TwinWithRelationships[] | undefined;
    continuationToken?: string | undefined;
}

export class TwinsValidationJob implements ITwinsValidationJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    modelIds?: string[] | undefined;
    exactModelMatch?: boolean | undefined;
    locationId?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    summaryDetails?: TwinValidationJobSummaryDetails;

    constructor(data?: ITwinsValidationJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.details = _data["details"] ? AsyncJobDetails.fromJS(_data["details"]) : <any>undefined;
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.lastUpdateTime = _data["lastUpdateTime"] ? new Date(_data["lastUpdateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userData = _data["userData"];
            if (Array.isArray(_data["target"])) {
                this.target = [] as any;
                for (let item of _data["target"])
                    this.target!.push(item);
            }
            if (Array.isArray(_data["modelIds"])) {
                this.modelIds = [] as any;
                for (let item of _data["modelIds"])
                    this.modelIds!.push(item);
            }
            this.exactModelMatch = _data["exactModelMatch"];
            this.locationId = _data["locationId"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.summaryDetails = _data["summaryDetails"] ? TwinValidationJobSummaryDetails.fromJS(_data["summaryDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TwinsValidationJob {
        data = typeof data === 'object' ? data : {};
        let result = new TwinsValidationJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userData"] = this.userData;
        if (Array.isArray(this.target)) {
            data["target"] = [];
            for (let item of this.target)
                data["target"].push(item);
        }
        if (Array.isArray(this.modelIds)) {
            data["modelIds"] = [];
            for (let item of this.modelIds)
                data["modelIds"].push(item);
        }
        data["exactModelMatch"] = this.exactModelMatch;
        data["locationId"] = this.locationId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["summaryDetails"] = this.summaryDetails ? this.summaryDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITwinsValidationJob {
    jobId?: string | undefined;
    details?: AsyncJobDetails;
    createTime?: Date;
    lastUpdateTime?: Date | undefined;
    userId?: string | undefined;
    userData?: string | undefined;
    target?: EntityType[] | undefined;
    modelIds?: string[] | undefined;
    exactModelMatch?: boolean | undefined;
    locationId?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    summaryDetails?: TwinValidationJobSummaryDetails;
}

export class UpdateDocumentResponse implements IUpdateDocumentResponse {
    fileName?: string | undefined;
    isSuccessful?: boolean;
    twinId?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IUpdateDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.isSuccessful = _data["isSuccessful"];
            this.twinId = _data["twinId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): UpdateDocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["isSuccessful"] = this.isSuccessful;
        data["twinId"] = this.twinId;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IUpdateDocumentResponse {
    fileName?: string | undefined;
    isSuccessful?: boolean;
    twinId?: string | undefined;
    errorMessage?: string | undefined;
}

export class UpdateMappedEntry implements IUpdateMappedEntry {
    mappedId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    willowId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;

    constructor(data?: IUpdateMappedEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappedId = _data["mappedId"];
            this.mappedModelId = _data["mappedModelId"];
            this.willowModelId = _data["willowModelId"];
            this.parentMappedId = _data["parentMappedId"];
            this.parentWillowId = _data["parentWillowId"];
            this.willowParentRel = _data["willowParentRel"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.modelInformation = _data["modelInformation"];
            this.statusNotes = _data["statusNotes"];
            this.status = _data["status"];
            this.auditInformation = _data["auditInformation"];
            this.connectorId = _data["connectorId"];
            this.buildingId = _data["buildingId"];
            this.willowId = _data["willowId"];
            this.isExistingTwin = _data["isExistingTwin"];
            this.unit = _data["unit"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): UpdateMappedEntry {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMappedEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappedId"] = this.mappedId;
        data["mappedModelId"] = this.mappedModelId;
        data["willowModelId"] = this.willowModelId;
        data["parentMappedId"] = this.parentMappedId;
        data["parentWillowId"] = this.parentWillowId;
        data["willowParentRel"] = this.willowParentRel;
        data["name"] = this.name;
        data["description"] = this.description;
        data["modelInformation"] = this.modelInformation;
        data["statusNotes"] = this.statusNotes;
        data["status"] = this.status;
        data["auditInformation"] = this.auditInformation;
        data["connectorId"] = this.connectorId;
        data["buildingId"] = this.buildingId;
        data["willowId"] = this.willowId;
        data["isExistingTwin"] = this.isExistingTwin;
        data["unit"] = this.unit;
        data["dataType"] = this.dataType;
        return data;
    }
}

export interface IUpdateMappedEntry {
    mappedId?: string | undefined;
    mappedModelId?: string | undefined;
    willowModelId?: string | undefined;
    parentMappedId?: string | undefined;
    parentWillowId?: string | undefined;
    willowParentRel?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    modelInformation?: string | undefined;
    statusNotes?: string | undefined;
    status?: Status;
    auditInformation?: string | undefined;
    connectorId?: string | undefined;
    buildingId?: string | undefined;
    willowId?: string | undefined;
    isExistingTwin?: boolean;
    unit?: string | undefined;
    dataType?: string | undefined;
}

export class UpdateMappedTwinRequest implements IUpdateMappedTwinRequest {
    id?: string;
    willowTwinId?: string | undefined;
    changedProperties?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;

    constructor(data?: IUpdateMappedTwinRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.willowTwinId = _data["willowTwinId"];
            this.changedProperties = _data["changedProperties"];
            this.timeCreated = _data["timeCreated"] ? new Date(_data["timeCreated"].toString()) : <any>undefined;
            this.timeLastUpdated = _data["timeLastUpdated"] ? new Date(_data["timeLastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMappedTwinRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMappedTwinRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["willowTwinId"] = this.willowTwinId;
        data["changedProperties"] = this.changedProperties;
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["timeLastUpdated"] = this.timeLastUpdated ? this.timeLastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateMappedTwinRequest {
    id?: string;
    willowTwinId?: string | undefined;
    changedProperties?: string | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
}

export class UpdateMappedTwinRequestResponse implements IUpdateMappedTwinRequestResponse {
    id?: string;
    willowTwinId?: string | undefined;
    changedProperties?: JsonPatchOperation[] | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;

    constructor(data?: IUpdateMappedTwinRequestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.willowTwinId = _data["willowTwinId"];
            if (Array.isArray(_data["changedProperties"])) {
                this.changedProperties = [] as any;
                for (let item of _data["changedProperties"])
                    this.changedProperties!.push(JsonPatchOperation.fromJS(item));
            }
            this.timeCreated = _data["timeCreated"] ? new Date(_data["timeCreated"].toString()) : <any>undefined;
            this.timeLastUpdated = _data["timeLastUpdated"] ? new Date(_data["timeLastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMappedTwinRequestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMappedTwinRequestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["willowTwinId"] = this.willowTwinId;
        if (Array.isArray(this.changedProperties)) {
            data["changedProperties"] = [];
            for (let item of this.changedProperties)
                data["changedProperties"].push(item.toJSON());
        }
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["timeLastUpdated"] = this.timeLastUpdated ? this.timeLastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateMappedTwinRequestResponse {
    id?: string;
    willowTwinId?: string | undefined;
    changedProperties?: JsonPatchOperation[] | undefined;
    timeCreated?: Date;
    timeLastUpdated?: Date;
}

export class ValidationResults implements IValidationResults {
    twinDtId?: string | undefined;
    twinIdentifiers?: any | undefined;
    modelId?: string | undefined;
    resultSource?: string | undefined;
    description?: string | undefined;
    resultType?: Result;
    checkType?: CheckType;
    resultInfo?: any | undefined;
    ruleScope?: any | undefined;
    ruleId?: string | undefined;
    runInfo?: any | undefined;
    twinInfo?: any | undefined;
    score?: number;

    constructor(data?: IValidationResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinDtId = _data["twinDtId"];
            this.twinIdentifiers = _data["twinIdentifiers"];
            this.modelId = _data["modelId"];
            this.resultSource = _data["resultSource"];
            this.description = _data["description"];
            this.resultType = _data["resultType"];
            this.checkType = _data["checkType"];
            this.resultInfo = _data["resultInfo"];
            this.ruleScope = _data["ruleScope"];
            this.ruleId = _data["ruleId"];
            this.runInfo = _data["runInfo"];
            this.twinInfo = _data["twinInfo"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ValidationResults {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinDtId"] = this.twinDtId;
        data["twinIdentifiers"] = this.twinIdentifiers;
        data["modelId"] = this.modelId;
        data["resultSource"] = this.resultSource;
        data["description"] = this.description;
        data["resultType"] = this.resultType;
        data["checkType"] = this.checkType;
        data["resultInfo"] = this.resultInfo;
        data["ruleScope"] = this.ruleScope;
        data["ruleId"] = this.ruleId;
        data["runInfo"] = this.runInfo;
        data["twinInfo"] = this.twinInfo;
        data["score"] = this.score;
        return data;
    }
}

export interface IValidationResults {
    twinDtId?: string | undefined;
    twinIdentifiers?: any | undefined;
    modelId?: string | undefined;
    resultSource?: string | undefined;
    description?: string | undefined;
    resultType?: Result;
    checkType?: CheckType;
    resultInfo?: any | undefined;
    ruleScope?: any | undefined;
    ruleId?: string | undefined;
    runInfo?: any | undefined;
    twinInfo?: any | undefined;
    score?: number;
}

export class ValidationResultsPage implements IValidationResultsPage {
    content?: ValidationResults[] | undefined;
    continuationToken?: string | undefined;

    constructor(data?: IValidationResultsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(ValidationResults.fromJS(item));
            }
            this.continuationToken = _data["continuationToken"];
        }
    }

    static fromJS(data: any): ValidationResultsPage {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResultsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["continuationToken"] = this.continuationToken;
        return data;
    }
}

export interface IValidationResultsPage {
    content?: ValidationResults[] | undefined;
    continuationToken?: string | undefined;
}

export class Body implements IBody {
    fileName!: string;
    blobPath!: string;
    siteId?: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fileName = _data["fileName"];
            this.blobPath = _data["blobPath"];
            this.siteId = _data["siteId"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fileName"] = this.fileName;
        data["blobPath"] = this.blobPath;
        data["siteId"] = this.siteId;
        return data;
    }
}

export interface IBody {
    fileName: string;
    blobPath: string;
    siteId?: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}