// Critical legacy code brought in from DigitalTwins.ImporterTool
// Marked as auto-generated to avoid StyleCop warnings as it can be dangerous to fix them
// <auto-generated/>

using System.Data;
using System.Globalization;
using System.Text.Json;
using System.Text.RegularExpressions;
using Azure.DigitalTwins.Core;
using DTDLParser;
using DTDLParser.Models;
using Willow.Exceptions.Exceptions;
using Willow.Model.Adt;
using static Willow.TwinLifecycleManagement.Web.Helpers.ImporterConstants;
using FileParseException = Willow.Exceptions.Exceptions.FileParseException;

namespace Willow.TwinLifecycleManagement.Web.Helpers.Converters
{
    public abstract class BaseFileConverter : IBaseFileConverter
    {
        private readonly IReadOnlyDictionary<Dtmi, DTEntityInfo> _modelData;
        private readonly List<string> _coreColumns;
        protected readonly Stream _stream;
        private BasicDigitalTwinWithRelationships _loadedData;
        private bool _isLoaded;
        protected string _fileStreamName;
        private readonly List<string> _twinIds;

        private readonly string _siteId;

        Regex columnNameRegex = new Regex(@"\b\w+_\d+\b");

        protected BaseFileConverter(Stream stream, IReadOnlyDictionary<Dtmi, DTEntityInfo> modelData, string siteId)
        {
            _stream = stream;
            _modelData = modelData;
            _siteId = siteId;
            _coreColumns = new List<string> { Columns.ModelColumn, Columns.IdColumn };
        }
        protected BaseFileConverter(Stream stream)
        {
            _stream = stream;
            _twinIds = new List<string>();
        }

        public List<string> GetTwinIds()
        {
            return ParseTwinIds(ReadDataTable());
        }

        public IEnumerable<BasicDigitalTwin> GetParsedTwins()
        {
            LoadData();
            return _loadedData.Twins;
        }
        public IEnumerable<BasicRelationship> GetParsedRelationships()
        {
            LoadData();
            return _loadedData.Relationships;
        }

        public BasicDigitalTwinWithRelationships GetParsedTwinsWithRelationships()
        {
            LoadData();
            return _loadedData;
        }

        // It's hard to tell what the intent is here -
        //  It's called "YieldReturn" and there's a return in the foreach,
        //  but there's no yield and this doesn't return an IEnum<>.
        // This is only called by unit tests.
        public BasicDigitalTwinWithRelationships YieldReturnParsedData()
        {
            foreach (BasicDigitalTwinWithRelationships parsedFile in ParseAndYieldReturnRelatedData(ReadDataTable()))
            {
                return parsedFile;
            }
            return new BasicDigitalTwinWithRelationships(null);
        }
        public abstract DataTable ReadDataTable();

        public List<string> ParseTwinIds(DataTable dataTable)
        {
            if (dataTable == null)
                return _twinIds;

            foreach (DataRow row in dataTable.Rows)
            {
                try
                {
                    var val = row[Columns.IdColumn].ToString();
                    if (!String.IsNullOrEmpty(val))
                        _twinIds.Add(val);
                }
                catch (Exception)
                {
                    throw new FileContentException($"DataTable '{dataTable}' not providing Id column.");
                }
            }
            return _twinIds;
        }

        protected BasicDigitalTwinWithRelationships ParseFile(DataTable dataTable)
        {
            var twinsAndRelationships = new BasicDigitalTwinWithRelationships(null);

            // The result of each spreadsheet is in result.Tables
            if (dataTable == null)
                return twinsAndRelationships;

            foreach (DataRow row in dataTable.Rows)
            {
                if (row.ItemArray.All(r => string.IsNullOrWhiteSpace(r?.ToString())))
                    // Skip empty rows
                    return twinsAndRelationships;

                var twin = ParseRow(dataTable, row);

                AddTwinSiteId(twin);
                twinsAndRelationships.Twins.Add(twin.Twin);
                twinsAndRelationships.Relationships.AddRange(twin.Relationships);
            }

            return twinsAndRelationships;
        }

        protected IEnumerable<BasicDigitalTwinWithRelationships> ParseAndYieldReturnRelatedData(DataTable dataTable)
        {
            var relatedTwins = new BasicDigitalTwinWithRelationships(null);

            if (dataTable == null)
                yield return relatedTwins;
            // Is there supposed to be a "yield break" here?

            foreach (DataRow row in dataTable.Rows)
            {
                var twin = ParseRow(dataTable, row);

                if (relatedTwins.Twins.Count == 0
                    || relatedTwins.Twins.FirstOrDefault()?.Metadata.ModelId == twin.Twin.Metadata.ModelId)
                {
                    AddTwinSiteId(twin);
                    relatedTwins.Twins.Add(twin.Twin);
                    relatedTwins.Relationships.AddRange(twin.Relationships);
                }
                else
                {
                    yield return relatedTwins;
                }

                if (relatedTwins.Twins.Count != 0
                    && relatedTwins.Twins.FirstOrDefault()?.Metadata.ModelId != twin.Twin.Metadata.ModelId)
                {
                    relatedTwins.Twins.Clear();
                    relatedTwins.Relationships.Clear();

                    AddTwinSiteId(twin);
                    relatedTwins.Twins.Add(twin.Twin);
                    relatedTwins.Relationships.AddRange(twin.Relationships);
                }
            }
            yield return relatedTwins;
        }

        private void LoadData()
        {
            if (!_isLoaded)
            {
                _loadedData = ParseFile(ReadDataTable());
                _isLoaded = true;
            }
        }

        private DTInterfaceInfo GetModelData(string id)
        {
            if(!Dtmi.TryCreateDtmi(id,out Dtmi dtmi))
            {
                throw new FileContentException($"Model : {id} is not valid. Ensure model conforms to Dtmi format [dtmi:com:domain:model-identifier;1].");
            }

            _modelData.TryGetValue(dtmi, out DTEntityInfo model);
            if (model == null)
            {
                throw new FileContentException($"Model : {id} is not configured");
            }
            return model as DTInterfaceInfo;
        }

        private BasicDigitalTwinWithRelationships ParseRow(DataTable table, DataRow row)
        {
            string model, id;
            try
            {
                model = row[Columns.ModelColumn].ToString();
                id = row[Columns.IdColumn].ToString();
                if (string.IsNullOrWhiteSpace(model) || string.IsNullOrWhiteSpace(id))
                    throw new FileContentException($"DataTable '{table}' missing Id or  model columns");
            }
            catch
            {
                throw new FileContentException($"DataTable '{table}' missing Id or  model columns");
            }

            var modelData = GetModelData(model);

            var twinWithRelationShips = new BasicDigitalTwinWithRelationships(new BasicDigitalTwin());
            twinWithRelationShips.Twin.Id = id;
            twinWithRelationShips.Twin.Metadata.ModelId = model;

            foreach (DataColumn column in table.Columns)
            {
                // Skip empty columns and token columns
                if (column == null || _coreColumns.Contains(column.ColumnName))
                    continue;
                var columnName = column.ColumnName;
                var value = row[column.ColumnName].ToString();
                if (string.IsNullOrWhiteSpace(value))
                {
                    continue;
                }

                try
                {
                    if (columnNameRegex.IsMatch(columnName))
                    {
                        columnName = columnName.Substring(0, columnName.LastIndexOf("_"));
                    }

                    if (columnName.Contains("."))
                    {
                        var parts = columnName.Split(".");
                        var propertyOrRelationshipName = parts[0];
                        var targetPropertyName = parts.Last();

                        if (IsTargetEntityKind(modelData, propertyOrRelationshipName, DTEntityKind.Property))
                        {
                            if (!twinWithRelationShips.Twin.Contents.ContainsKey(propertyOrRelationshipName))
                            {
                                twinWithRelationShips.Twin.Contents.Add(propertyOrRelationshipName, new Dictionary<string, object>());
                            }
                            var objectData = twinWithRelationShips.Twin.Contents[propertyOrRelationshipName] as Dictionary<string, object>;

                            // Meant to handle map of maps - needs more testing
                            if (parts.Length == 3)
                            {
                                var innerColumnName = parts[1];

                                if (!objectData.ContainsKey(innerColumnName))
                                    objectData.Add(innerColumnName, new Dictionary<string, object>());
                                var innerData = objectData[innerColumnName] as Dictionary<string, object>;
                                innerData.Add(targetPropertyName, GetPropertyValue(GetPropertyInfo(modelData, propertyOrRelationshipName), parts.Skip(1), row[column.ColumnName]));

                            }
                            else
                            {
                                objectData.Add(targetPropertyName, GetPropertyValue(GetPropertyInfo(modelData, propertyOrRelationshipName), new string[] { targetPropertyName }, row[column.ColumnName]));
                            }
                        }
                        else if (IsTargetEntityKind(modelData, propertyOrRelationshipName, DTEntityKind.Relationship))
                        {
                            if (parts.Length == 3)
                            {
                                var relationshipPropertyName = parts[1];
                                var relationshipPropertyValue = GetRelationShipName(parts[2]);

                                var relationship = new BasicRelationship
                                {
                                    Name = propertyOrRelationshipName,
                                    SourceId = id,
                                    TargetId = value,
                                    Properties = new Dictionary<string, object>()
                                };
                                relationship.Properties[relationshipPropertyName] = relationshipPropertyValue;
                                twinWithRelationShips.Relationships.Add(relationship);
                            }
                        }
                        else if (IsTargetEntityKind(modelData, propertyOrRelationshipName, DTEntityKind.Component))
                        {
                            var componentPropertyName = parts[1];
                            if (!twinWithRelationShips.Twin.Contents.ContainsKey(propertyOrRelationshipName))
                            {
                                var component = new Dictionary<string, object>();
                                var componentMetadata = new Dictionary<string, object>();
                                component.Add("$metadata", componentMetadata);
                                twinWithRelationShips.Twin.Contents.Add(propertyOrRelationshipName, component);
                            }

                            var componentData = twinWithRelationShips.Twin.Contents[propertyOrRelationshipName] as Dictionary<string, object>;

                            if (parts.Length == 3)
                            {
                                if (!componentData.ContainsKey(componentPropertyName))
                                {
                                    componentData.Add(componentPropertyName, new Dictionary<string, object>());

                                }
                                var subPropertyName = parts[2];
                                var subPropertyValue = GetPropertyValue(GetPropertyInfo(GetComponentInfo(modelData, propertyOrRelationshipName).Schema, componentPropertyName), new List<string> { subPropertyName }, row[column.ColumnName]);
                                var componentProperties = componentData[componentPropertyName] as Dictionary<string, object>;
                                componentProperties.Add(subPropertyName, subPropertyValue);

                                var metadataDictionary = componentData["$metadata"] as Dictionary<string, object>;

                                if (!metadataDictionary.ContainsKey(componentPropertyName))
                                {
                                    metadataDictionary[componentPropertyName] = new Dictionary<string, object>();
                                }

                                (metadataDictionary[componentPropertyName] as Dictionary<string, object>)[subPropertyName] = new Dictionary<string, object> { ["desiredValue"] = subPropertyValue };
                            }
                            else
                            {
                                var componentPropertyValue = GetComponentValue(modelData, propertyOrRelationshipName, componentPropertyName, row[column.ColumnName]);
                                componentData.Add(componentPropertyName, componentPropertyValue);
                                (componentData["$metadata"] as Dictionary<string, object>).Add(componentPropertyName, new Dictionary<string, object>(new KeyValuePair<string, object>[] { new KeyValuePair<string, object>("desiredValue", componentPropertyValue) }));
                            }
                        }
                        else
                        {
                            throw new FileContentException($"Row with model {model} does not include the attribute: {propertyOrRelationshipName}");
                        }
                    }
                    else
                    {
                        if (IsTargetEntityKind(modelData, columnName, DTEntityKind.Property))
                        {
                            twinWithRelationShips.Twin.Contents.Add(columnName, GetPropertyValue(GetPropertyInfo(modelData, columnName), Enumerable.Empty<string>(), row[column.ColumnName]));
                        }
                        else if (IsTargetEntityKind(modelData, GetRelationShipName(columnName), DTEntityKind.Relationship))
                        {
                            twinWithRelationShips.Relationships.Add(new BasicRelationship
                            {
                                Name = GetRelationShipName(columnName),
                                SourceId = id,
                                TargetId = value
                            });
                        }
                        else
                        {
                            throw new FileContentException($"Row with model {model} does not include the attribute: {columnName}");
                        }
                    }

                }
                catch (Exception ex)
                {
                    throw new FileParseException(table.Rows.IndexOf(row), column.ColumnName, ex.Message, ex);
                }

            }

            //Add empty components for all components that are not set in data row
            foreach (var componentInfo in modelData.Contents.Values.OfType<DTComponentInfo>())
            {
                if (!twinWithRelationShips.Twin.Contents.ContainsKey(componentInfo.Name))
                {
                    var component = new Dictionary<string, object>();
                    var componentMetadata = new Dictionary<string, object>();
                    component.Add("$metadata", componentMetadata);
                    twinWithRelationShips.Twin.Contents.Add(componentInfo.Name, component);
                }
            }

            return twinWithRelationShips;
        }


        private string GetRelationShipName(string columnName)
        {
            var updated = true;
            var name = columnName;
            while (updated)
            {
                var previousName = name;
                name = previousName.Length > 1 && char.IsDigit(previousName[^1]) ?
                    previousName.Remove(previousName.Length - 1, 1) :
                    previousName;
                updated = name != previousName;
            }
            return name;
        }

        private DTPropertyInfo GetPropertyInfo(DTInterfaceInfo modelData, string propertyName) => modelData.Contents[propertyName] as DTPropertyInfo;
        private DTComponentInfo GetComponentInfo(DTInterfaceInfo modelData, string componentName) => modelData.Contents[componentName] as DTComponentInfo;

        private object GetPropertyValue(DTPropertyInfo propertyInfo, IEnumerable<string> columnPaths, object value)
        {
            DTSchemaInfo schema = propertyInfo.Schema;

            foreach (var path in columnPaths)
            {
                if (schema.EntityKind == DTEntityKind.Object)
                {
                    var objectInfo = schema as DTObjectInfo;
                    var fieldInfo = objectInfo?.Fields.SingleOrDefault(f => f.Name == path);

                    if (fieldInfo is null)
                        throw new FileContentException(
                            $"Invalid value provided in '{path}' column: expected object with correct properties");

                    schema = fieldInfo.Schema;
                }
                else if (schema.EntityKind == DTEntityKind.Map)
                {
                    var mapInfo = schema as DTMapInfo;


                    schema = mapInfo.MapValue.Schema;
                }
            }

            return ConvertValueToMatchEntityKind(value, schema, propertyInfo.Schema);
        }

        private static object ConvertToGuidIfNeeded(string value)
        {
            if (Guid.TryParse(value.Trim(), out Guid id))
                return id.ToString().ToLower();
            return value;
        }

        private static object ConvertValueToMatchEntityKind(object value, DTSchemaInfo schemaInfo, DTSchemaInfo primaryParentSchemaInfo = null)
        {
            switch (schemaInfo.EntityKind)
            {
                case DTEntityKind.String:
                    return primaryParentSchemaInfo?.EntityKind == DTEntityKind.String ? // If parent property schema is string
                           ConvertToGuidIfNeeded(value.ToString()) : // For simple props try converting to guid format if need
                           value.ToString() ; // For complex props, just return the string

                case DTEntityKind.Duration:
                    // This is an ISO-8601 duration string such as "P16M" which ADT will parse.
                    // See: https://en.wikipedia.org/wiki/ISO_8601#Durations
                    return value.ToString();

                case DTEntityKind.Time:
                    return value switch
                    {
                        TimeSpan span => span.ToString("HH:mm"),
                        string => value,
                        DateTime time => time.TimeOfDay.ToString("HH:mm"),
                        _ => TimeSpan.FromSeconds((double)value).ToString("HH:mm")
                    };

                case DTEntityKind.Date:
                    if (value is DateTime date)
                        return date.ToString("yyyy-MM-dd");
                    else if (value is string stringValue)
                    {
                        if (DateTime.TryParseExact(stringValue, new string[] { "yyyy-MM-dd", "MM/dd/yyyy", "dd/MM/yyyy" }, CultureInfo.InvariantCulture, DateTimeStyles.None, out var dateValue))
                            return dateValue.ToString("yyyy-MM-dd");
                        else if (DateTime.TryParse(stringValue, out dateValue))
                            return dateValue.ToString("yyyy-MM-dd");
                    }
                    return value.ToString();

                case DTEntityKind.Integer:
                    return (value is string) ? int.Parse((string)value) : Convert.ToInt32(value);

                case DTEntityKind.Long:
                    return value is string ? long.Parse((string)value) : Convert.ToInt64(value);

                case DTEntityKind.Boolean:
                    return value is string ? bool.Parse((string)value) : Convert.ToBoolean(value);

                case DTEntityKind.Float:
                    return value is string ? float.Parse((string)value) : Convert.ToSingle(value);

                case DTEntityKind.Double:
                    return value is string ? double.Parse((string)value) : Convert.ToDouble(value);

                case DTEntityKind.Map:
                    var mapInfo = schemaInfo as DTMapInfo;
                    if (value is string s1 && mapInfo?.MapValue.Schema.EntityKind == DTEntityKind.Boolean)
                    {
                        var output = new Dictionary<string, bool>();
                        var items = s1.Split(',', StringSplitOptions.RemoveEmptyEntries);
                        return items.Length == 1 ? Boolean.Parse(s1) : items.ToDictionary(i => i, i => true);
                    }
                    return value.ToString();
                case DTEntityKind.Array:
                    return JsonSerializer.Deserialize<object[]>(value.ToString());
                case DTEntityKind.Enum:

                    DTEnumInfo enumInfo = schemaInfo as DTEnumInfo;
                    var enumValueInfo = enumInfo.EnumValues.Where(x => x.EnumValue.ToString() == value.ToString()).SingleOrDefault();
                    if (enumValueInfo is null)
                    {
                        throw new FileContentException($"Invalid value provided in '{schemaInfo.DisplayName}' column, allowed values for property are: {string.Join(", ", enumInfo.EnumValues.Select(x => x.EnumValue.ToString()).ToArray())}");
                    }
                    return enumValueInfo.EnumValue;
                default:
                    return value;
            }
        }

        private object GetComponentValue(DTInterfaceInfo modelData, string componentName, string columnName, object value)
        {
            var componentInfo = GetComponentInfo(modelData, componentName);
            var interfaceInfo = componentInfo.Schema;
            var propertyInfo = interfaceInfo.Contents.SingleOrDefault(f => f.Key == columnName).Value as DTPropertyInfo;

            if (propertyInfo is null)
                throw new FileContentException(
                    $"Invalid value provided in '{columnName}' column with value '{value}': expected component with correct properties");

            return GetPropertyValue(propertyInfo, Enumerable.Empty<string>(), value);
        }

        private bool IsTargetEntityKind(DTInterfaceInfo modelData, string columnName, DTEntityKind entityKind)
        {
            if (modelData.Contents.ContainsKey(columnName))
            {
                var modelDefinitionContent = modelData.Contents[columnName];
                return modelDefinitionContent.EntityKind == entityKind;
            }
            return false;
        }

        private void AddTwinSiteId(BasicDigitalTwinWithRelationships twin)
        {
            if (string.IsNullOrWhiteSpace(_siteId))
                return;

            if (!twin.Twin.Contents.Any(x => string.Equals(x.Key, Columns.SiteIdColumn, StringComparison.InvariantCultureIgnoreCase)))
                twin.Twin.Contents.Add(Columns.SiteIdColumn, _siteId);
        }

    }
}
