//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get activity logs
     * @return OK
     */
    activityLogs(body: ActivityLogsRequestDto, cancelToken?: CancelToken): Promise<ActivityLogsResponseDtoBatchDto> {
        let url_ = this.baseUrl + "/api/activity-logs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivityLogs(_response);
        });
    }

    protected processActivityLogs(response: AxiosResponse): Promise<ActivityLogsResponseDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActivityLogsResponseDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<ActivityLogsResponseDtoBatchDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogsResponseDtoBatchDto>(null as any);
    }

    /**
     * Export activity logs
     * @param format (optional) 
     * @return OK
     */
    exportActivityLogs(format: string | undefined, body: DownloadActivityLogsRequestDto, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/activity-logs/export/{format}";
        if (format !== null && format !== undefined)
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        else
            url_ = url_.replace("/{format}", "");
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportActivityLogs(_response);
        });
    }

    protected processExportActivityLogs(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get the application configuration
     * @return OK
     */
    getConfig( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Contact us
     * @return No Content
     */
    contactUs(body: PostContactUsDto, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/contact-us";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContactUs(_response);
        });
    }

    protected processContactUs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all conflicting requested commands
     * @return OK
     */
    getRequestedCommands(body: GetConflictingCommandsRequestDto, cancelToken?: CancelToken): Promise<ConflictingCommandsResponseDtoBatchDto> {
        let url_ = this.baseUrl + "/api/requested-commands/conflicts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequestedCommands(_response);
        });
    }

    protected processGetRequestedCommands(response: AxiosResponse): Promise<ConflictingCommandsResponseDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConflictingCommandsResponseDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<ConflictingCommandsResponseDtoBatchDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConflictingCommandsResponseDtoBatchDto>(null as any);
    }

    /**
     * Get conflicting requested commands by Twin ID
     * @return OK
     */
    getRequestedCommandsByTwinid(connectorId: string, twinId: string, cancelToken?: CancelToken): Promise<ConflictingCommandsResponseDto> {
        let url_ = this.baseUrl + "/api/requested-commands/conflicts/{connectorId}/{twinId}";
        if (connectorId === undefined || connectorId === null)
            throw new Error("The parameter 'connectorId' must be defined.");
        url_ = url_.replace("{connectorId}", encodeURIComponent("" + connectorId));
        if (twinId === undefined || twinId === null)
            throw new Error("The parameter 'twinId' must be defined.");
        url_ = url_.replace("{twinId}", encodeURIComponent("" + twinId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequestedCommandsByTwinid(_response);
        });
    }

    protected processGetRequestedCommandsByTwinid(response: AxiosResponse): Promise<ConflictingCommandsResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConflictingCommandsResponseDto.fromJS(resultData200);
            return Promise.resolve<ConflictingCommandsResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConflictingCommandsResponseDto>(null as any);
    }

    /**
     * Get a requested command by ID
     * @return OK
     */
    getRequestedCommandById(id: string, cancelToken?: CancelToken): Promise<RequestedCommandResponseDto> {
        let url_ = this.baseUrl + "/api/requested-commands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequestedCommandById(_response);
        });
    }

    protected processGetRequestedCommandById(response: AxiosResponse): Promise<RequestedCommandResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequestedCommandResponseDto.fromJS(resultData200);
            return Promise.resolve<RequestedCommandResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequestedCommandResponseDto>(null as any);
    }

    /**
     * Get present values for requested commands by externalIds
     * @return OK
     */
    getRequestedCommandsPresentValues(body: GetConflictingCommandPresentValuesRequestDto, cancelToken?: CancelToken): Promise<GetConflictingCommandPresentValuesResponseDto> {
        let url_ = this.baseUrl + "/api/requested-commands/present-values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequestedCommandsPresentValues(_response);
        });
    }

    protected processGetRequestedCommandsPresentValues(response: AxiosResponse): Promise<GetConflictingCommandPresentValuesResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetConflictingCommandPresentValuesResponseDto.fromJS(resultData200);
            return Promise.resolve<GetConflictingCommandPresentValuesResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetConflictingCommandPresentValuesResponseDto>(null as any);
    }

    /**
     * Update the status of a single requested command
     * @return No Content
     */
    updateRequestedCommandStatus(id: string, body: UpdateRequestedCommandStatusDto, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/requested-commands/status?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRequestedCommandStatus(_response);
        });
    }

    protected processUpdateRequestedCommandStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the status of many requested commands
     * @return No Content
     */
    updateRequestedCommandsStatus(body: UpdateRequestedCommandsStatusDto, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/requested-commands/statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRequestedCommandsStatus(_response);
        });
    }

    protected processUpdateRequestedCommandsStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a requested command
     * @return No Content
     */
    createRequestedCommands(body: PostRequestedCommandsDto, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/requested-commands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRequestedCommands(_response);
        });
    }

    protected processCreateRequestedCommands(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a count of all conflicting requested commands
     * @return OK
     */
    getRequestedCommandsCount(body: GetRequestedCommandsCountDto, cancelToken?: CancelToken): Promise<number> {
        let url_ = this.baseUrl + "/api/requested-commands/count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequestedCommandsCount(_response);
        });
    }

    protected processGetRequestedCommandsCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get all resolved commands
     * @return OK
     */
    getResolvedCommands(body: GetResolvedCommandsDto, cancelToken?: CancelToken): Promise<ResolvedCommandResponseDtoBatchDto> {
        let url_ = this.baseUrl + "/api/resolved-commands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResolvedCommands(_response);
        });
    }

    protected processGetResolvedCommands(response: AxiosResponse): Promise<ResolvedCommandResponseDtoBatchDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResolvedCommandResponseDtoBatchDto.fromJS(resultData200);
            return Promise.resolve<ResolvedCommandResponseDtoBatchDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResolvedCommandResponseDtoBatchDto>(null as any);
    }

    /**
     * Get a resolved command by ID
     * @return OK
     */
    getResolvedCommandById(id: string, cancelToken?: CancelToken): Promise<ResolvedCommandResponseDto> {
        let url_ = this.baseUrl + "/api/resolved-commands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResolvedCommandById(_response);
        });
    }

    protected processGetResolvedCommandById(response: AxiosResponse): Promise<ResolvedCommandResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResolvedCommandResponseDto.fromJS(resultData200);
            return Promise.resolve<ResolvedCommandResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResolvedCommandResponseDto>(null as any);
    }

    /**
     * Update the status of a resolved command
     * @return OK
     */
    updateResolvedCommandStatus(id: string, body: UpdateResolvedCommandStatusDto, cancelToken?: CancelToken): Promise<UpdateResolvedCommandStatusResponseDto> {
        let url_ = this.baseUrl + "/api/resolved-commands/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateResolvedCommandStatus(_response);
        });
    }

    protected processUpdateResolvedCommandStatus(response: AxiosResponse): Promise<UpdateResolvedCommandStatusResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateResolvedCommandStatusResponseDto.fromJS(resultData200);
            return Promise.resolve<UpdateResolvedCommandStatusResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateResolvedCommandStatusResponseDto>(null as any);
    }

    /**
     * Get all sites
     * @return OK
     */
    getAllSites( cancelToken?: CancelToken): Promise<SiteDto[]> {
        let url_ = this.baseUrl + "/api/sites";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSites(_response);
        });
    }

    protected processGetAllSites(response: AxiosResponse): Promise<SiteDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SiteDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SiteDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SiteDto[]>(null as any);
    }

    /**
     * Get statistics
     * @return OK
     */
    getStatistics(body: GetStatisticsRequestDto, cancelToken?: CancelToken): Promise<GetStatisticsResponseDto> {
        let url_ = this.baseUrl + "/api/statistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: AxiosResponse): Promise<GetStatisticsResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetStatisticsResponseDto.fromJS(resultData200);
            return Promise.resolve<GetStatisticsResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetStatisticsResponseDto>(null as any);
    }

    /**
     * Get user's permissions
     * @return OK
     */
    getUserPermissions( cancelToken?: CancelToken): Promise<UserPermissionsResponseDto> {
        let url_ = this.baseUrl + "/api/user/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: AxiosResponse): Promise<UserPermissionsResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserPermissionsResponseDto.fromJS(resultData200);
            return Promise.resolve<UserPermissionsResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserPermissionsResponseDto>(null as any);
    }
}

/** Get Activity Log Feeds Request DTO. */
export class ActivityLogsRequestDto implements IActivityLogsRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IActivityLogsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ActivityLogsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

/** Get Activity Log Feeds Request DTO. */
export interface IActivityLogsRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
}

/** Get Activity Log Feeds. */
export class ActivityLogsResponseDto implements IActivityLogsResponseDto {
    /** Gets or sets the Id of the activity log entry. */
    id?: string;
    /** Gets or sets the Id of the resolved command. */
    requestedCommandId?: string;
    /** Gets or sets the Id of the resolved command. */
    resolvedCommandId?: string | undefined;
    /** Gets or sets the requested command's name. */
    commandName?: string | undefined;
    /** Gets or sets the date when the activity was logged. */
    timestamp?: Date;
    type?: ActivityType;
    /** Gets or sets the set value of the command. */
    value?: number | undefined;
    /** Gets or sets the unit of the value. */
    unit?: string | undefined;
    /** Gets or sets the requested command's start time. */
    startTime?: Date | undefined;
    /** Gets or sets the requested command's end time. */
    endTime?: Date | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the rule ID. */
    ruleId?: string | undefined;
    /** Gets or sets the twin ID. */
    twinId?: string | undefined;
    /** Gets or sets the external ID. */
    externalId?: string | undefined;
    /** Gets or sets the connector ID. */
    connectorId?: string | undefined;
    /** Gets or sets the location of the twin. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    updatedBy?: User;
    /** Gets or sets any extra information logged as part of the activity. */
    extraInfo?: string | undefined;

    constructor(data?: IActivityLogsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestedCommandId = _data["requestedCommandId"];
            this.resolvedCommandId = _data["resolvedCommandId"];
            this.commandName = _data["commandName"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.siteId = _data["siteId"];
            this.ruleId = _data["ruleId"];
            this.twinId = _data["twinId"];
            this.externalId = _data["externalId"];
            this.connectorId = _data["connectorId"];
            this.location = _data["location"];
            this.isCapabilityOf = _data["isCapabilityOf"];
            this.isHostedBy = _data["isHostedBy"];
            this.updatedBy = _data["updatedBy"] ? User.fromJS(_data["updatedBy"]) : <any>undefined;
            this.extraInfo = _data["extraInfo"];
        }
    }

    static fromJS(data: any): ActivityLogsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestedCommandId"] = this.requestedCommandId;
        data["resolvedCommandId"] = this.resolvedCommandId;
        data["commandName"] = this.commandName;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["siteId"] = this.siteId;
        data["ruleId"] = this.ruleId;
        data["twinId"] = this.twinId;
        data["externalId"] = this.externalId;
        data["connectorId"] = this.connectorId;
        data["location"] = this.location;
        data["isCapabilityOf"] = this.isCapabilityOf;
        data["isHostedBy"] = this.isHostedBy;
        data["updatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["extraInfo"] = this.extraInfo;
        return data;
    }
}

/** Get Activity Log Feeds. */
export interface IActivityLogsResponseDto {
    /** Gets or sets the Id of the activity log entry. */
    id?: string;
    /** Gets or sets the Id of the resolved command. */
    requestedCommandId?: string;
    /** Gets or sets the Id of the resolved command. */
    resolvedCommandId?: string | undefined;
    /** Gets or sets the requested command's name. */
    commandName?: string | undefined;
    /** Gets or sets the date when the activity was logged. */
    timestamp?: Date;
    type?: ActivityType;
    /** Gets or sets the set value of the command. */
    value?: number | undefined;
    /** Gets or sets the unit of the value. */
    unit?: string | undefined;
    /** Gets or sets the requested command's start time. */
    startTime?: Date | undefined;
    /** Gets or sets the requested command's end time. */
    endTime?: Date | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the rule ID. */
    ruleId?: string | undefined;
    /** Gets or sets the twin ID. */
    twinId?: string | undefined;
    /** Gets or sets the external ID. */
    externalId?: string | undefined;
    /** Gets or sets the connector ID. */
    connectorId?: string | undefined;
    /** Gets or sets the location of the twin. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    updatedBy?: User;
    /** Gets or sets any extra information logged as part of the activity. */
    extraInfo?: string | undefined;
}

export class ActivityLogsResponseDtoBatchDto implements IActivityLogsResponseDtoBatchDto {
    total?: number;
    items?: ActivityLogsResponseDto[] | undefined;

    constructor(data?: IActivityLogsResponseDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityLogsResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityLogsResponseDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogsResponseDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActivityLogsResponseDtoBatchDto {
    total?: number;
    items?: ActivityLogsResponseDto[] | undefined;
}

/** Type of user command. */
export enum ActivityType {
    Received = "Received",
    Approved = "Approved",
    Retracted = "Retracted",
    Executed = "Executed",
    Failed = "Failed",
    Cancelled = "Cancelled",
    Suspended = "Suspended",
    MessageSent = "MessageSent",
    MessageReceivedSuccess = "MessageReceivedSuccess",
    MessageReceivedFailed = "MessageReceivedFailed",
    Completed = "Completed",
    Retried = "Retried",
}

/** Command Trends DTO. */
export class CommandTrendsDto implements ICommandTrendsDto {
    /** Gets or sets the categories for the chart. */
    categories?: string[] | undefined;
    /** Gets or sets the data sets for the chart. */
    dataset?: { [key: string]: CommandsTrendDataSetDto; } | undefined;

    constructor(data?: ICommandTrendsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            if (_data["dataset"]) {
                this.dataset = {} as any;
                for (let key in _data["dataset"]) {
                    if (_data["dataset"].hasOwnProperty(key))
                        (<any>this.dataset)![key] = _data["dataset"][key] ? CommandsTrendDataSetDto.fromJS(_data["dataset"][key]) : new CommandsTrendDataSetDto();
                }
            }
        }
    }

    static fromJS(data: any): CommandTrendsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandTrendsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        if (this.dataset) {
            data["dataset"] = {};
            for (let key in this.dataset) {
                if (this.dataset.hasOwnProperty(key))
                    (<any>data["dataset"])[key] = this.dataset[key] ? this.dataset[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Command Trends DTO. */
export interface ICommandTrendsDto {
    /** Gets or sets the categories for the chart. */
    categories?: string[] | undefined;
    /** Gets or sets the data sets for the chart. */
    dataset?: { [key: string]: CommandsTrendDataSetDto; } | undefined;
}

/** Statistics counts for commands. */
export class CommandsCountStatisticsDto implements ICommandsCountStatisticsDto {
    /** Gets the total number of requested commands received. */
    totalRequestedCommands?: number;
    /** Gets the total number of approved commands. */
    totalApprovedCommands?: number;
    /** Gets the total number of resolved commands that have been executed. */
    totalExecutedCommands?: number;
    /** Gets the total number of resolved commands that have been cancelled. */
    totalCancelledCommands?: number;
    /** Gets the total number of currently suspended commands. */
    totalSuspendedCommands?: number;
    /** Gets ttotal number of failed commands. */
    totalFailedCommands?: number;

    constructor(data?: ICommandsCountStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRequestedCommands = _data["totalRequestedCommands"];
            this.totalApprovedCommands = _data["totalApprovedCommands"];
            this.totalExecutedCommands = _data["totalExecutedCommands"];
            this.totalCancelledCommands = _data["totalCancelledCommands"];
            this.totalSuspendedCommands = _data["totalSuspendedCommands"];
            this.totalFailedCommands = _data["totalFailedCommands"];
        }
    }

    static fromJS(data: any): CommandsCountStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandsCountStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRequestedCommands"] = this.totalRequestedCommands;
        data["totalApprovedCommands"] = this.totalApprovedCommands;
        data["totalExecutedCommands"] = this.totalExecutedCommands;
        data["totalCancelledCommands"] = this.totalCancelledCommands;
        data["totalSuspendedCommands"] = this.totalSuspendedCommands;
        data["totalFailedCommands"] = this.totalFailedCommands;
        return data;
    }
}

/** Statistics counts for commands. */
export interface ICommandsCountStatisticsDto {
    /** Gets the total number of requested commands received. */
    totalRequestedCommands?: number;
    /** Gets the total number of approved commands. */
    totalApprovedCommands?: number;
    /** Gets the total number of resolved commands that have been executed. */
    totalExecutedCommands?: number;
    /** Gets the total number of resolved commands that have been cancelled. */
    totalCancelledCommands?: number;
    /** Gets the total number of currently suspended commands. */
    totalSuspendedCommands?: number;
    /** Gets ttotal number of failed commands. */
    totalFailedCommands?: number;
}

/** Command Trend Data Set. */
export class CommandsTrendDataSetDto implements ICommandsTrendDataSetDto {
    /** Gets or sets the name of the data set. */
    name?: string | undefined;
    /** Gets or sets the list of data. */
    data?: number[] | undefined;

    constructor(data?: ICommandsTrendDataSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CommandsTrendDataSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommandsTrendDataSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

/** Command Trend Data Set. */
export interface ICommandsTrendDataSetDto {
    /** Gets or sets the name of the data set. */
    name?: string | undefined;
    /** Gets or sets the list of data. */
    data?: number[] | undefined;
}

/** Conflicting Commands Response Dto. */
export class ConflictingCommandsResponseDto implements IConflictingCommandsResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the connector ID. */
    connectorId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets a deterministic key of the conflicting command. */
    readonly key?: string | undefined;
    /** Gets the date of the earliest received command. */
    receivedDate?: Date;
    /** Gets the number of commands. */
    commands?: number;
    /** Gets the number of approved commands. */
    approvedCommands?: number;
    /** Gets or sets the ist of Requested Commands. */
    requests?: RequestedCommandResponseDto[] | undefined;

    constructor(data?: IConflictingCommandsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.externalId = _data["externalId"];
            this.presentValue = _data["presentValue"];
            this.siteId = _data["siteId"];
            this.connectorId = _data["connectorId"];
            this.location = _data["location"];
            this.isHostedBy = _data["isHostedBy"];
            this.isCapabilityOf = _data["isCapabilityOf"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(LocationTwin.fromJS(item));
            }
            (<any>this).key = _data["key"];
            this.receivedDate = _data["receivedDate"] ? new Date(_data["receivedDate"].toString()) : <any>undefined;
            this.commands = _data["commands"];
            this.approvedCommands = _data["approvedCommands"];
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(RequestedCommandResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConflictingCommandsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictingCommandsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["externalId"] = this.externalId;
        data["presentValue"] = this.presentValue;
        data["siteId"] = this.siteId;
        data["connectorId"] = this.connectorId;
        data["location"] = this.location;
        data["isHostedBy"] = this.isHostedBy;
        data["isCapabilityOf"] = this.isCapabilityOf;
        data["unit"] = this.unit;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toISOString() : <any>undefined;
        data["commands"] = this.commands;
        data["approvedCommands"] = this.approvedCommands;
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data;
    }
}

/** Conflicting Commands Response Dto. */
export interface IConflictingCommandsResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the connector ID. */
    connectorId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets a deterministic key of the conflicting command. */
    key?: string | undefined;
    /** Gets the date of the earliest received command. */
    receivedDate?: Date;
    /** Gets the number of commands. */
    commands?: number;
    /** Gets the number of approved commands. */
    approvedCommands?: number;
    /** Gets or sets the ist of Requested Commands. */
    requests?: RequestedCommandResponseDto[] | undefined;
}

export class ConflictingCommandsResponseDtoBatchDto implements IConflictingCommandsResponseDtoBatchDto {
    total?: number;
    items?: ConflictingCommandsResponseDto[] | undefined;

    constructor(data?: IConflictingCommandsResponseDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConflictingCommandsResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConflictingCommandsResponseDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictingCommandsResponseDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConflictingCommandsResponseDtoBatchDto {
    total?: number;
    items?: ConflictingCommandsResponseDto[] | undefined;
}

/** Request to download activity logs. */
export class DownloadActivityLogsRequestDto implements IDownloadActivityLogsRequestDto {
    /** Gets the specifications on how to sort the batch. */
    sortSpecifications?: SortSpecificationDto[] | undefined;
    /** Gets the specifications on how to filter the batch. */
    filterSpecifications?: FilterSpecificationDto[] | undefined;

    constructor(data?: IDownloadActivityLogsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DownloadActivityLogsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadActivityLogsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to download activity logs. */
export interface IDownloadActivityLogsRequestDto {
    /** Gets the specifications on how to sort the batch. */
    sortSpecifications?: SortSpecificationDto[] | undefined;
    /** Gets the specifications on how to filter the batch. */
    filterSpecifications?: FilterSpecificationDto[] | undefined;
}

export class FilterSpecificationDto implements IFilterSpecificationDto {
    field!: string;
    operator!: string;
    logicalOperator?: string | undefined;
    value?: any | undefined;

    constructor(data?: IFilterSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.operator = _data["operator"];
            this.logicalOperator = _data["logicalOperator"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["operator"] = this.operator;
        data["logicalOperator"] = this.logicalOperator;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilterSpecificationDto {
    field: string;
    operator: string;
    logicalOperator?: string | undefined;
    value?: any | undefined;
}

/** Get Conflicting Commands. */
export class GetConflictingCommandPresentValuesRequestDto implements IGetConflictingCommandPresentValuesRequestDto {
    /** Gets or sets external Ids. */
    externalIds?: string[] | undefined;

    constructor(data?: IGetConflictingCommandPresentValuesRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["externalIds"])) {
                this.externalIds = [] as any;
                for (let item of _data["externalIds"])
                    this.externalIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetConflictingCommandPresentValuesRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConflictingCommandPresentValuesRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.externalIds)) {
            data["externalIds"] = [];
            for (let item of this.externalIds)
                data["externalIds"].push(item);
        }
        return data;
    }
}

/** Get Conflicting Commands. */
export interface IGetConflictingCommandPresentValuesRequestDto {
    /** Gets or sets external Ids. */
    externalIds?: string[] | undefined;
}

/** Conflicting Commands Response Dto. */
export class GetConflictingCommandPresentValuesResponseDto implements IGetConflictingCommandPresentValuesResponseDto {
    /** Gets or Sets PresentValues. */
    presentValues?: { [key: string]: number; } | undefined;

    constructor(data?: IGetConflictingCommandPresentValuesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["presentValues"]) {
                this.presentValues = {} as any;
                for (let key in _data["presentValues"]) {
                    if (_data["presentValues"].hasOwnProperty(key))
                        (<any>this.presentValues)![key] = _data["presentValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetConflictingCommandPresentValuesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConflictingCommandPresentValuesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.presentValues) {
            data["presentValues"] = {};
            for (let key in this.presentValues) {
                if (this.presentValues.hasOwnProperty(key))
                    (<any>data["presentValues"])[key] = (<any>this.presentValues)[key];
            }
        }
        return data;
    }
}

/** Conflicting Commands Response Dto. */
export interface IGetConflictingCommandPresentValuesResponseDto {
    /** Gets or Sets PresentValues. */
    presentValues?: { [key: string]: number; } | undefined;
}

/** Get Conflicting Commands. */
export class GetConflictingCommandsRequestDto implements IGetConflictingCommandsRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IGetConflictingCommandsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GetConflictingCommandsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConflictingCommandsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

/** Get Conflicting Commands. */
export interface IGetConflictingCommandsRequestDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
}

/** Get count of Requested Commands. */
export class GetRequestedCommandsCountDto implements IGetRequestedCommandsCountDto {
    status?: RequestedCommandStatus;
    /** Gets the filter specifications. */
    filterSpecifications?: FilterSpecificationDto[] | undefined;

    constructor(data?: IGetRequestedCommandsCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRequestedCommandsCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequestedCommandsCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        return data;
    }
}

/** Get count of Requested Commands. */
export interface IGetRequestedCommandsCountDto {
    status?: RequestedCommandStatus;
    /** Gets the filter specifications. */
    filterSpecifications?: FilterSpecificationDto[] | undefined;
}

/** Get Resolved Commands. */
export class GetResolvedCommandsDto implements IGetResolvedCommandsDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IGetResolvedCommandsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortSpecifications"])) {
                this.sortSpecifications = [] as any;
                for (let item of _data["sortSpecifications"])
                    this.sortSpecifications!.push(SortSpecificationDto.fromJS(item));
            }
            if (Array.isArray(_data["filterSpecifications"])) {
                this.filterSpecifications = [] as any;
                for (let item of _data["filterSpecifications"])
                    this.filterSpecifications!.push(FilterSpecificationDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GetResolvedCommandsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetResolvedCommandsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortSpecifications)) {
            data["sortSpecifications"] = [];
            for (let item of this.sortSpecifications)
                data["sortSpecifications"].push(item.toJSON());
        }
        if (Array.isArray(this.filterSpecifications)) {
            data["filterSpecifications"] = [];
            for (let item of this.filterSpecifications)
                data["filterSpecifications"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

/** Get Resolved Commands. */
export interface IGetResolvedCommandsDto {
    sortSpecifications?: SortSpecificationDto[] | undefined;
    filterSpecifications?: FilterSpecificationDto[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
}

/** Get Statistics Request DTO. */
export class GetStatisticsRequestDto implements IGetStatisticsRequestDto {
    /** Gets or sets the site ID for search. */
    siteId?: string | undefined;
    /** Gets or sets the start date for the search. */
    startDate?: Date | undefined;
    /** Gets or sets the end date for the search. */
    endDate?: Date | undefined;

    constructor(data?: IGetStatisticsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStatisticsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatisticsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Get Statistics Request DTO. */
export interface IGetStatisticsRequestDto {
    /** Gets or sets the site ID for search. */
    siteId?: string | undefined;
    /** Gets or sets the start date for the search. */
    startDate?: Date | undefined;
    /** Gets or sets the end date for the search. */
    endDate?: Date | undefined;
}

/** Statistics for commands. */
export class GetStatisticsResponseDto implements IGetStatisticsResponseDto {
    commandsCount?: CommandsCountStatisticsDto;
    /** Gets or sets the list of most Recent Activities. */
    recentActivities?: ActivityLogsResponseDto[] | undefined;
    commandTrends?: CommandTrendsDto;

    constructor(data?: IGetStatisticsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandsCount = _data["commandsCount"] ? CommandsCountStatisticsDto.fromJS(_data["commandsCount"]) : <any>undefined;
            if (Array.isArray(_data["recentActivities"])) {
                this.recentActivities = [] as any;
                for (let item of _data["recentActivities"])
                    this.recentActivities!.push(ActivityLogsResponseDto.fromJS(item));
            }
            this.commandTrends = _data["commandTrends"] ? CommandTrendsDto.fromJS(_data["commandTrends"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStatisticsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatisticsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandsCount"] = this.commandsCount ? this.commandsCount.toJSON() : <any>undefined;
        if (Array.isArray(this.recentActivities)) {
            data["recentActivities"] = [];
            for (let item of this.recentActivities)
                data["recentActivities"].push(item.toJSON());
        }
        data["commandTrends"] = this.commandTrends ? this.commandTrends.toJSON() : <any>undefined;
        return data;
    }
}

/** Statistics for commands. */
export interface IGetStatisticsResponseDto {
    commandsCount?: CommandsCountStatisticsDto;
    /** Gets or sets the list of most Recent Activities. */
    recentActivities?: ActivityLogsResponseDto[] | undefined;
    commandTrends?: CommandTrendsDto;
}

/** Represents a location twin. */
export class LocationTwin implements ILocationTwin {
    /** Gets the twin ID. */
    twinId?: string | undefined;
    /** Gets the location model ID. */
    locationModelId?: string | undefined;
    /** Gets the location twin ID. */
    locationTwinId?: string | undefined;
    /** Gets the location order. */
    order?: number;
    /** Gets the last part of the model name. */
    readonly model?: string | undefined;

    constructor(data?: ILocationTwin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["TwinId"];
            this.locationModelId = _data["LocationModelId"];
            this.locationTwinId = _data["LocationTwinId"];
            this.order = _data["order"];
            (<any>this).model = _data["model"];
        }
    }

    static fromJS(data: any): LocationTwin {
        data = typeof data === 'object' ? data : {};
        let result = new LocationTwin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TwinId"] = this.twinId;
        data["LocationModelId"] = this.locationModelId;
        data["LocationTwinId"] = this.locationTwinId;
        data["order"] = this.order;
        data["model"] = this.model;
        return data;
    }
}

/** Represents a location twin. */
export interface ILocationTwin {
    /** Gets the twin ID. */
    twinId?: string | undefined;
    /** Gets the location model ID. */
    locationModelId?: string | undefined;
    /** Gets the location twin ID. */
    locationTwinId?: string | undefined;
    /** Gets the location order. */
    order?: number;
    /** Gets the last part of the model name. */
    model?: string | undefined;
}

/** Contact us. */
export class PostContactUsDto implements IPostContactUsDto {
    /** Gets the requester's name. */
    requestersName?: string | undefined;
    /** Gets the requester's email. */
    requestersEmail?: string | undefined;
    /** Gets the comment. */
    comment?: string | undefined;
    /** Gets the URL of the page the user was on. */
    url?: string | undefined;

    constructor(data?: IPostContactUsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestersName = _data["requestersName"];
            this.requestersEmail = _data["requestersEmail"];
            this.comment = _data["comment"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PostContactUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostContactUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestersName"] = this.requestersName;
        data["requestersEmail"] = this.requestersEmail;
        data["comment"] = this.comment;
        data["url"] = this.url;
        return data;
    }
}

/** Contact us. */
export interface IPostContactUsDto {
    /** Gets the requester's name. */
    requestersName?: string | undefined;
    /** Gets the requester's email. */
    requestersEmail?: string | undefined;
    /** Gets the comment. */
    comment?: string | undefined;
    /** Gets the URL of the page the user was on. */
    url?: string | undefined;
}

/** Creates new command. */
export class PostRequestedCommandsDto implements IPostRequestedCommandsDto {
    /** List of commands. */
    commands?: RequestedCommandDto[] | undefined;

    constructor(data?: IPostRequestedCommandsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["commands"])) {
                this.commands = [] as any;
                for (let item of _data["commands"])
                    this.commands!.push(RequestedCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostRequestedCommandsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostRequestedCommandsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.commands)) {
            data["commands"] = [];
            for (let item of this.commands)
                data["commands"].push(item.toJSON());
        }
        return data;
    }
}

/** Creates new command. */
export interface IPostRequestedCommandsDto {
    /** List of commands. */
    commands?: RequestedCommandDto[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Represents a relationship twin. */
export class RelationshipDto implements IRelationshipDto {
    /** The ID of the twin at the other end of the relationship. */
    twinId?: string | undefined;
    /** The name of the twin at the other end of the relationship. */
    twinName?: string | undefined;
    /** The ID of the model at the other end of the relationship. */
    modelId?: string | undefined;
    /** The type of the relationship. */
    relationshipType?: string | undefined;

    constructor(data?: IRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.twinName = _data["twinName"];
            this.modelId = _data["modelId"];
            this.relationshipType = _data["relationshipType"];
        }
    }

    static fromJS(data: any): RelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["twinName"] = this.twinName;
        data["modelId"] = this.modelId;
        data["relationshipType"] = this.relationshipType;
        return data;
    }
}

/** Represents a relationship twin. */
export interface IRelationshipDto {
    /** The ID of the twin at the other end of the relationship. */
    twinId?: string | undefined;
    /** The name of the twin at the other end of the relationship. */
    twinName?: string | undefined;
    /** The ID of the model at the other end of the relationship. */
    modelId?: string | undefined;
    /** The type of the relationship. */
    relationshipType?: string | undefined;
}

/** Post command detail. */
export class RequestedCommandDto implements IRequestedCommandDto {
    /** Connector Id. */
    connectorId?: string | undefined;
    /** Name of Command. */
    commandName?: string | undefined;
    /** Type of Command. */
    type?: string | undefined;
    /** Twin Id. */
    twinId?: string | undefined;
    /** External Id from Mapped. */
    externalId?: string | undefined;
    /** RulesEngine Rule Id with which the command was generated. */
    ruleId?: string | undefined;
    /** Value. */
    value?: number;
    /** Unit of given value. */
    unit?: string | undefined;
    /** Desired time to apply given value. */
    startTime?: Date;
    /** Desired end time. */
    endTime?: Date | undefined;
    /** This twin's relationships and ancestors. */
    relationships?: RelationshipDto[] | undefined;

    constructor(data?: IRequestedCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectorId = _data["connectorId"];
            this.commandName = _data["commandName"];
            this.type = _data["type"];
            this.twinId = _data["twinId"];
            this.externalId = _data["externalId"];
            this.ruleId = _data["ruleId"];
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["relationships"])) {
                this.relationships = [] as any;
                for (let item of _data["relationships"])
                    this.relationships!.push(RelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestedCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectorId"] = this.connectorId;
        data["commandName"] = this.commandName;
        data["type"] = this.type;
        data["twinId"] = this.twinId;
        data["externalId"] = this.externalId;
        data["ruleId"] = this.ruleId;
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.relationships)) {
            data["relationships"] = [];
            for (let item of this.relationships)
                data["relationships"].push(item.toJSON());
        }
        return data;
    }
}

/** Post command detail. */
export interface IRequestedCommandDto {
    /** Connector Id. */
    connectorId?: string | undefined;
    /** Name of Command. */
    commandName?: string | undefined;
    /** Type of Command. */
    type?: string | undefined;
    /** Twin Id. */
    twinId?: string | undefined;
    /** External Id from Mapped. */
    externalId?: string | undefined;
    /** RulesEngine Rule Id with which the command was generated. */
    ruleId?: string | undefined;
    /** Value. */
    value?: number;
    /** Unit of given value. */
    unit?: string | undefined;
    /** Desired time to apply given value. */
    startTime?: Date;
    /** Desired end time. */
    endTime?: Date | undefined;
    /** This twin's relationships and ancestors. */
    relationships?: RelationshipDto[] | undefined;
}

/** Response Dto for Requested Commands. */
export class RequestedCommandResponseDto implements IRequestedCommandResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets the ID. */
    id?: string;
    /** Gets or sets the requested command can be Pending when entered, approved to be resolved, and rejected. */
    status?: string | undefined;
    /** Gets a uniquely identifiable ID of the Rules Engine rule. */
    ruleId?: string | undefined;
    /** Gets the command name. */
    commandName?: string | undefined;
    /** Gets the command type. */
    type?: string | undefined;
    /** Gets the Connector ID. */
    connectorId?: string | undefined;
    /** Gets the value for the command. */
    value?: number;
    /** Gets the time from which the value should be applied. This may correspond to an actual start time for an executed command but it might not if conflict resolution decides otherwise. */
    startTime?: Date;
    /** Gets the command end time. */
    endTime?: Date | undefined;
    /** Gets the command created date. */
    createdDate?: Date;
    /** Gets the received date of the command. */
    receivedDate?: Date;
    statusUpdatedBy?: User;
    /** Gets the command last updated date. */
    lastUpdated?: Date;

    constructor(data?: IRequestedCommandResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.externalId = _data["externalId"];
            this.presentValue = _data["presentValue"];
            this.siteId = _data["siteId"];
            this.location = _data["location"];
            this.isHostedBy = _data["isHostedBy"];
            this.isCapabilityOf = _data["isCapabilityOf"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(LocationTwin.fromJS(item));
            }
            this.id = _data["id"];
            this.status = _data["status"];
            this.ruleId = _data["ruleId"];
            this.commandName = _data["commandName"];
            this.type = _data["type"];
            this.connectorId = _data["connectorId"];
            this.value = _data["value"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.receivedDate = _data["receivedDate"] ? new Date(_data["receivedDate"].toString()) : <any>undefined;
            this.statusUpdatedBy = _data["statusUpdatedBy"] ? User.fromJS(_data["statusUpdatedBy"]) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestedCommandResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedCommandResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["externalId"] = this.externalId;
        data["presentValue"] = this.presentValue;
        data["siteId"] = this.siteId;
        data["location"] = this.location;
        data["isHostedBy"] = this.isHostedBy;
        data["isCapabilityOf"] = this.isCapabilityOf;
        data["unit"] = this.unit;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["status"] = this.status;
        data["ruleId"] = this.ruleId;
        data["commandName"] = this.commandName;
        data["type"] = this.type;
        data["connectorId"] = this.connectorId;
        data["value"] = this.value;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toISOString() : <any>undefined;
        data["statusUpdatedBy"] = this.statusUpdatedBy ? this.statusUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

/** Response Dto for Requested Commands. */
export interface IRequestedCommandResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets the ID. */
    id?: string;
    /** Gets or sets the requested command can be Pending when entered, approved to be resolved, and rejected. */
    status?: string | undefined;
    /** Gets a uniquely identifiable ID of the Rules Engine rule. */
    ruleId?: string | undefined;
    /** Gets the command name. */
    commandName?: string | undefined;
    /** Gets the command type. */
    type?: string | undefined;
    /** Gets the Connector ID. */
    connectorId?: string | undefined;
    /** Gets the value for the command. */
    value?: number;
    /** Gets the time from which the value should be applied. This may correspond to an actual start time for an executed command but it might not if conflict resolution decides otherwise. */
    startTime?: Date;
    /** Gets the command end time. */
    endTime?: Date | undefined;
    /** Gets the command created date. */
    createdDate?: Date;
    /** Gets the received date of the command. */
    receivedDate?: Date;
    statusUpdatedBy?: User;
    /** Gets the command last updated date. */
    lastUpdated?: Date;
}

/** Requested Command Status. */
export enum RequestedCommandStatus {
    Pending = "Pending",
    Approved = "Approved",
    Rejected = "Rejected",
}

/** Actions for resolved commands. */
export enum ResolvedCommandAction {
    Cancel = "Cancel",
    Execute = "Execute",
    Suspend = "Suspend",
    Unsuspend = "Unsuspend",
    Retry = "Retry",
}

/** Response Dto for Resolved Commands. */
export class ResolvedCommandResponseDto implements IResolvedCommandResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets the ID. */
    id?: string;
    /** Gets or sets the command name. */
    commandName?: string | undefined;
    /** Gets or sets the command type. */
    type?: string | undefined;
    /** Gets a uniquely identifiable ID of RulesEngine rule. */
    ruleId?: string | undefined;
    status?: ResolvedCommandStatus;
    /** Gets the connector ID. */
    connectorId?: string | undefined;
    /** Gets the value for the command. */
    value?: number;
    /** Gets the actual time from which the value should be applied. */
    startTime?: Date;
    /** Gets the time until other values cannot be applied. */
    endTime?: Date | undefined;
    /** Gets or sets the comment provided during the last status update. */
    comment?: string | undefined;
    /** Gets the command created date. */
    createdDate?: Date;
    statusUpdatedBy?: User;
    /** Gets the command last updated date. */
    lastUpdated?: Date;
    /** Gets the requested command ID. */
    requestId?: string;
    /** Gets or sets the list of allowed actions. */
    actions?: string[] | undefined;

    constructor(data?: IResolvedCommandResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twinId = _data["twinId"];
            this.externalId = _data["externalId"];
            this.presentValue = _data["presentValue"];
            this.siteId = _data["siteId"];
            this.location = _data["location"];
            this.isHostedBy = _data["isHostedBy"];
            this.isCapabilityOf = _data["isCapabilityOf"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(LocationTwin.fromJS(item));
            }
            this.id = _data["id"];
            this.commandName = _data["commandName"];
            this.type = _data["type"];
            this.ruleId = _data["ruleId"];
            this.status = _data["status"];
            this.connectorId = _data["connectorId"];
            this.value = _data["value"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.statusUpdatedBy = _data["statusUpdatedBy"] ? User.fromJS(_data["statusUpdatedBy"]) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): ResolvedCommandResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResolvedCommandResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twinId"] = this.twinId;
        data["externalId"] = this.externalId;
        data["presentValue"] = this.presentValue;
        data["siteId"] = this.siteId;
        data["location"] = this.location;
        data["isHostedBy"] = this.isHostedBy;
        data["isCapabilityOf"] = this.isCapabilityOf;
        data["unit"] = this.unit;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["commandName"] = this.commandName;
        data["type"] = this.type;
        data["ruleId"] = this.ruleId;
        data["status"] = this.status;
        data["connectorId"] = this.connectorId;
        data["value"] = this.value;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["statusUpdatedBy"] = this.statusUpdatedBy ? this.statusUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["requestId"] = this.requestId;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data;
    }
}

/** Response Dto for Resolved Commands. */
export interface IResolvedCommandResponseDto {
    /** Gets or sets the Twin ID or Sensor ID. */
    twinId?: string | undefined;
    /** Gets or sets the External ID. */
    externalId?: string | undefined;
    /** Gets or sets the present value of Twin. */
    presentValue?: number | undefined;
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the location name. */
    location?: string | undefined;
    /** Gets or sets the asset that hosts the twin. */
    isHostedBy?: string | undefined;
    /** Gets or sets the asset which has this capability. */
    isCapabilityOf?: string | undefined;
    /** Gets or sets the unit of the twin's value. */
    unit?: string | undefined;
    /** Gets or sets the location hierarchy of the twin. */
    locations?: LocationTwin[] | undefined;
    /** Gets the ID. */
    id?: string;
    /** Gets or sets the command name. */
    commandName?: string | undefined;
    /** Gets or sets the command type. */
    type?: string | undefined;
    /** Gets a uniquely identifiable ID of RulesEngine rule. */
    ruleId?: string | undefined;
    status?: ResolvedCommandStatus;
    /** Gets the connector ID. */
    connectorId?: string | undefined;
    /** Gets the value for the command. */
    value?: number;
    /** Gets the actual time from which the value should be applied. */
    startTime?: Date;
    /** Gets the time until other values cannot be applied. */
    endTime?: Date | undefined;
    /** Gets or sets the comment provided during the last status update. */
    comment?: string | undefined;
    /** Gets the command created date. */
    createdDate?: Date;
    statusUpdatedBy?: User;
    /** Gets the command last updated date. */
    lastUpdated?: Date;
    /** Gets the requested command ID. */
    requestId?: string;
    /** Gets or sets the list of allowed actions. */
    actions?: string[] | undefined;
}

export class ResolvedCommandResponseDtoBatchDto implements IResolvedCommandResponseDtoBatchDto {
    total?: number;
    items?: ResolvedCommandResponseDto[] | undefined;

    constructor(data?: IResolvedCommandResponseDtoBatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResolvedCommandResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResolvedCommandResponseDtoBatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResolvedCommandResponseDtoBatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResolvedCommandResponseDtoBatchDto {
    total?: number;
    items?: ResolvedCommandResponseDto[] | undefined;
}

/** Resolved Command Status. */
export enum ResolvedCommandStatus {
    Scheduled = "Scheduled",
    Suspended = "Suspended",
    Failed = "Failed",
    Executing = "Executing",
    Cancelled = "Cancelled",
    Executed = "Executed",
    Approved = "Approved",
}

/** Site Information. */
export class SiteDto implements ISiteDto {
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the site name or address of the site. */
    siteName?: string | undefined;

    constructor(data?: ISiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.siteName = _data["siteName"];
        }
    }

    static fromJS(data: any): SiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new SiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["siteName"] = this.siteName;
        return data;
    }
}

/** Site Information. */
export interface ISiteDto {
    /** Gets or sets the site ID. */
    siteId?: string | undefined;
    /** Gets or sets the site name or address of the site. */
    siteName?: string | undefined;
}

export class SortSpecificationDto implements ISortSpecificationDto {
    field?: string | undefined;
    sort?: string | undefined;

    constructor(data?: ISortSpecificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): SortSpecificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SortSpecificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["sort"] = this.sort;
        return data;
    }
}

export interface ISortSpecificationDto {
    field?: string | undefined;
    sort?: string | undefined;
}

/** Update RequestedCommand Status as Approved or Rejected. */
export class UpdateRequestedCommandStatusDto implements IUpdateRequestedCommandStatusDto {
    /** Requested Command can only be Approve or Reject. */
    action?: string | undefined;

    constructor(data?: IUpdateRequestedCommandStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): UpdateRequestedCommandStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestedCommandStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        return data;
    }
}

/** Update RequestedCommand Status as Approved or Rejected. */
export interface IUpdateRequestedCommandStatusDto {
    /** Requested Command can only be Approve or Reject. */
    action?: string | undefined;
}

/** Update RequestedCommand Status as Approved or Rejected. */
export class UpdateRequestedCommandsStatusDto implements IUpdateRequestedCommandsStatusDto {
    /** The ids of the approved commands. */
    approveIds?: string[] | undefined;
    /** The ids of the rejected commands. */
    rejectIds?: string[] | undefined;

    constructor(data?: IUpdateRequestedCommandsStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["approveIds"])) {
                this.approveIds = [] as any;
                for (let item of _data["approveIds"])
                    this.approveIds!.push(item);
            }
            if (Array.isArray(_data["rejectIds"])) {
                this.rejectIds = [] as any;
                for (let item of _data["rejectIds"])
                    this.rejectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRequestedCommandsStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestedCommandsStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.approveIds)) {
            data["approveIds"] = [];
            for (let item of this.approveIds)
                data["approveIds"].push(item);
        }
        if (Array.isArray(this.rejectIds)) {
            data["rejectIds"] = [];
            for (let item of this.rejectIds)
                data["rejectIds"].push(item);
        }
        return data;
    }
}

/** Update RequestedCommand Status as Approved or Rejected. */
export interface IUpdateRequestedCommandsStatusDto {
    /** The ids of the approved commands. */
    approveIds?: string[] | undefined;
    /** The ids of the rejected commands. */
    rejectIds?: string[] | undefined;
}

/** Update ResolvedCommand Status. */
export class UpdateResolvedCommandStatusDto implements IUpdateResolvedCommandStatusDto {
    action?: ResolvedCommandAction;
    /** Gets any comment provided with the status update. */
    comment?: string | undefined;

    constructor(data?: IUpdateResolvedCommandStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): UpdateResolvedCommandStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResolvedCommandStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        return data;
    }
}

/** Update ResolvedCommand Status. */
export interface IUpdateResolvedCommandStatusDto {
    action?: ResolvedCommandAction;
    /** Gets any comment provided with the status update. */
    comment?: string | undefined;
}

/** Approved Command Response. */
export class UpdateResolvedCommandStatusResponseDto implements IUpdateResolvedCommandStatusResponseDto {
    /** Id of Resolved Command. */
    id?: string;

    constructor(data?: IUpdateResolvedCommandStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateResolvedCommandStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResolvedCommandStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** Approved Command Response. */
export interface IUpdateResolvedCommandStatusResponseDto {
    /** Id of Resolved Command. */
    id?: string;
}

/** Application User. */
export class User implements IUser {
    /** Gets or sets the full name. */
    name?: string | undefined;
    /** Gets or sets the email address. */
    email?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

/** Application User. */
export interface IUser {
    /** Gets or sets the full name. */
    name?: string | undefined;
    /** Gets or sets the email address. */
    email?: string | undefined;
}

/** User Management Authorization Response . */
export class UserPermissionsResponseDto implements IUserPermissionsResponseDto {
    /** Gets or sets the list of user's permissions. */
    permissions?: string[] | undefined;
    /** Gets or sets a value indicating whether the user has admin privileges. */
    isAdminUser?: boolean;

    constructor(data?: IUserPermissionsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.isAdminUser = _data["isAdminUser"];
        }
    }

    static fromJS(data: any): UserPermissionsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isAdminUser"] = this.isAdminUser;
        return data;
    }
}

/** User Management Authorization Response . */
export interface IUserPermissionsResponseDto {
    /** Gets or sets the list of user's permissions. */
    permissions?: string[] | undefined;
    /** Gets or sets a value indicating whether the user has admin privileges. */
    isAdminUser?: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}