import _ from 'lodash'
import { useRef } from 'react'
import { api } from '@willow/ui'
import { UseQueryOptions, useQuery } from 'react-query'

/**
 * To be used in classic viewer to get insights/tickets statistics for a given floor;
 * Note: This hook is used different specifically for Walmart as they will
 * generate their own Insights which have ruleId of "walmart_alert", so the
 * combination of includeRuleId and excludeRuleId is used to filter out/ include
 * the insights generated by Walmart.
 */
const useStatistics = (
  {
    floorId,
    siteId,
    moduleTypeNamePaths,
    includeRuleId,
    excludeRuleId,
    ticketSourceTypes,
  }: {
    floorId: string
    siteId: string
    moduleTypeNamePaths: string[]
    includeRuleId?: string
    excludeRuleId?: string
    ticketSourceTypes?: string[]
  },
  options: UseQueryOptions<Statistic[]>
) => {
  const { enabled: externalEnabled, ...rest } = options
  // We need to use a ref here to avoid re-fetching the data when the moduleTypeNamePaths change
  // so that if we had fetched data for ['Mechanical', 'Electrical', 'Plumbing'], then
  // we don't want to re-fetch the data if the order changes to ['Electrical', 'Mechanical', 'Plumbing']
  // nor if moduleTypeNamePaths change to ['Electrical', 'Mechanical']
  const moduleTypeNamePathsRef = useRef<string[]>([])
  if (
    moduleTypeNamePaths.every((path) =>
      moduleTypeNamePathsRef.current.includes(path)
    )
  ) {
    // pass
  } else {
    // add every namePath from moduleTypeNamePaths that is not in moduleTypeNamePathsRef.current
    moduleTypeNamePathsRef.current = _.union(
      moduleTypeNamePathsRef.current,
      moduleTypeNamePaths
    )
  }

  return useQuery<Statistic[]>(
    [
      '3d-statistics',
      floorId,
      siteId,
      moduleTypeNamePathsRef.current,
      includeRuleId,
      excludeRuleId,
      ticketSourceTypes,
    ],
    async () => {
      const queryBody = {
        siteId,
        floorId,
        moduleTypeNamePaths,
      }

      const [insightStats, ticketStats] = await Promise.all([
        api.post<Statistic[]>('/statistics/assets/insight', {
          ...queryBody,
          ...(includeRuleId ? { includeRuleId } : {}),
          ...(excludeRuleId ? { excludeRuleId } : {}),
        }),
        api.post<TicketStatistics[]>('/statistics/assets/tickets', {
          ...queryBody,
          ...(ticketSourceTypes ? { sourceTypes: ticketSourceTypes } : {}),
        }),
      ])

      // Converts the data to a map for easier lookup
      const insightStatsMap = new Map(
        insightStats.data.map((item) => [item.uniqueId, item])
      )
      const ticketStatsMap = new Map(
        ticketStats.data.map((item) => [item.uniqueId, item])
      )

      // Combine the Insight and Ticket stats as they share the same uniqueId
      const combinedStats = Array.from(insightStatsMap).map(
        ([uniqueId, insightStat]) => {
          const ticketStat = ticketStatsMap.get(uniqueId)
          return {
            ...insightStat,
            ticketCount: ticketStat ? ticketStat.ticketCount : 0,
            insightHighestPriority: insightStat.highestPriority,
            ticketHighestPriority: ticketStat ? ticketStat.highestPriority : 0,
          }
        }
      )

      return combinedStats
    },
    {
      enabled:
        !!floorId &&
        !!siteId &&
        !!moduleTypeNamePathsRef.current.length &&
        externalEnabled !== false,
      ...rest,
    }
  )
}

export default useStatistics

export type InsightStatistics = Omit<
  Statistic,
  'ticketCount' | 'insightHighestPriority' | 'ticketHighestPriority'
>
export type TicketStatistics = Omit<
  Statistic,
  'insightCount' | 'insightHighestPriority' | 'ticketHighestPriority'
>

export type Statistic = {
  uniqueId: string
  geometryViewerId: string
  twinId?: string
  insightCount: number
  ticketCount: number
  highestPriority: number
  insightHighestPriority: number
  ticketHighestPriority: number
  ruleIds?: string[]
}
