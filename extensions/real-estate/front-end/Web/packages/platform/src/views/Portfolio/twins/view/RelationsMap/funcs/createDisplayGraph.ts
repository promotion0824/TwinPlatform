import _ from 'lodash'

import {
  APIEdge,
  APIGraph,
  APINode,
  DisplayGraph,
  DisplayNode,
  GraphState,
  RelationshipDirection,
  RelationshipGroup,
} from '../types'

// DTDLv2 relationship names cannot contain the # character, so let's use this
// to designate the relationship between a node and its expand node.
export const expandEdgeName = '#expand#'

/**
 * From
 * https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier
 * we can see that Digital Twin IDs can only contain letters, digits,
 * underscores, colons and semicolons. So if we use a character not in this set (we've chosen "#") then we
 * can be sure we won't collide with real IDs.
 */
function joinId(segments: string[]): string {
  return segments.join('#')
}

function splitId(id: string): string[] {
  return id.split('#')
}

export function getTwinLookup(graph: APIGraph): {
  [key: string]: APINode
} {
  return Object.fromEntries(graph.nodes.map((n) => [n.id, n]))
}

/**
 * Get all the edges in or out (according to `direction`) from the twin with id
 * `twinId`, grouped by the relationship name and the model ID of the twin at
 * the other end of the edge.
 */
export function getEdgeGroups(
  graph: APIGraph,
  twinLookup: { [key: string]: APINode },
  twinId: string,
  direction: RelationshipDirection
): Array<{ group: RelationshipGroup; edges: APIEdge[] }> {
  const left = direction === RelationshipDirection.out ? 'sourceId' : 'targetId'
  const right =
    direction === RelationshipDirection.out ? 'targetId' : 'sourceId'
  const edges = graph.edges.filter((e) => e[left] === twinId)
  const edgeGroups = _.groupBy(edges, (e) =>
    joinId([e.name, twinLookup[e[right]].modelId])
  )
  return Object.entries(edgeGroups).map(([key, groupEdges]) => {
    const [relationshipName, modelId] = splitId(key)
    return {
      group: {
        twinId,
        direction,
        relationshipName,
        modelId,
      },
      edges: groupEdges,
    }
  })
}

class EdgeCollection {
  edgeLookup: {
    [id: string]: {
      id: string
      name: string
      sourceId: string
      targetId: string
    }
  }

  constructor() {
    this.edgeLookup = {}
  }

  add(
    id: string,
    name: string,
    leftId: string,
    rightId: string,
    reverse: boolean
  ) {
    if (this.edgeLookup[id] == null) {
      if (reverse) {
        this.edgeLookup[id] = { id, name, targetId: leftId, sourceId: rightId }
      } else {
        this.edgeLookup[id] = { id, name, sourceId: leftId, targetId: rightId }
      }
    }
  }

  get edges() {
    return Object.values(this.edgeLookup)
  }
}

/**
 * Takes a downloaded graph and selects the nodes we want to display
 *
 * This means doing two things:
 *
 * - Collapsing groups of nodes into a single `model` node
 * - Collapsing entire subgraphs into a single `expand` node
 *
 * The selected graph is generated by traversing the downloaded data starting from
 * the `rootNodeId`. The `nodeStates` are used to determine whether nodes
 * should be collapsed (and if so, into what), or traversed.
 */
export default function createDisplayGraph(
  graph: APIGraph,
  rootNodeId: string,
  state: GraphState,
  selectedTwinId?: string
): DisplayGraph {
  const twins = getTwinLookup(graph)
  const traversedNodeIds = new Set()

  const outNodes: DisplayNode[] = []
  const outEdges = new EdgeCollection()

  function traverse(nodeId: string) {
    if (traversedNodeIds.has(nodeId)) {
      return
    }
    traversedNodeIds.add(nodeId)

    const twin = twins[nodeId]
    const twinNode = {
      ...twin,
      type: 'twin' as const,
      displayedEdges: {
        in: [] as APIEdge[],
        out: [] as APIEdge[],
      },
      state: state.nodes[nodeId] ?? { in: false, out: false },
      selected: twin.id === selectedTwinId,
    }

    // We want to traverse nodes going in and out of the current node, so we do
    // everything twice. First we look for `sourceId`s matching the current
    // node id and process their targets, then we look for `targetId`s matching
    // the current node and process their sources.
    for (const direction of Object.values(RelationshipDirection)) {
      const left =
        direction === RelationshipDirection.out ? 'sourceId' : 'targetId'
      const right =
        direction === RelationshipDirection.out ? 'targetId' : 'sourceId'

      for (const { group, edges } of getEdgeGroups(
        graph,
        twins,
        nodeId,
        direction
      )) {
        twinNode.displayedEdges[direction].push(...edges)
        const expandState = state.nodes[nodeId]?.[direction]

        if (expandState) {
          let outNodeId: string | undefined

          const modelNodeId = joinId([
            left,
            nodeId,
            group.relationshipName,
            group.modelId,
          ])
          // How many of the nodes in the group have we not encountered before?
          const numNewItems = edges.filter(
            (e) => !traversedNodeIds.has(e[right])
          ).length

          if (numNewItems > 1) {
            // If we have multiple nodes matching the relationship + model, and
            // we haven't expanded them, collapse them into a `model` node.
            outNodes.push({
              type: 'model',
              id: modelNodeId,
              modelId: group.modelId,
              twinId: nodeId,
              direction,
              relationshipName: group.relationshipName,
              count: edges.length,
            })
            outEdges.add(
              modelNodeId,
              group.relationshipName,
              nodeId,
              modelNodeId,
              direction === 'in'
            )
            // Further nodes come out of the model node.
            outNodeId = modelNodeId
          } else {
            // Otherwise, further nodes come directly out of the current node.
            outNodeId = nodeId
          }

          if (
            numNewItems < edges.length ||
            edges.length === 1 ||
            state.expandedGroups.find((g) => _.isEqual(g, group))
          ) {
            for (const edge of edges) {
              outEdges.add(
                edge.id,
                group.relationshipName,
                outNodeId,
                edge[right],
                direction === 'in'
              )
              traverse(edge[right])
            }
          }
        }
      }
    }

    outNodes.push(twinNode)
  }

  traverse(rootNodeId)

  return {
    nodes: outNodes,
    edges: outEdges.edges,
  }
}
