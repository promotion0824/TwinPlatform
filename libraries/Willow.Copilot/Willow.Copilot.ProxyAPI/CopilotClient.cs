//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace Willow.Copilot.ProxyAPI
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ICopilotClient
    {
        /// <returns>A HealthCheckStatus object</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HealthResponse> HealthzAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A HealthCheckStatus object</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HealthResponse> HealthzAsync(System.Threading.CancellationToken cancellationToken);

        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ChatResponse> ChatAsync(ChatRequest chatRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ChatResponse> ChatAsync(ChatRequest chatRequest, System.Threading.CancellationToken cancellationToken);

        /// <returns>Requested rebuild opertion has completed sucessfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IndexRebuildResponse> RebuildAsync(IndexRebuildRequest indexRebuildRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Requested rebuild opertion has completed sucessfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IndexRebuildResponse> RebuildAsync(IndexRebuildRequest indexRebuildRequest, System.Threading.CancellationToken cancellationToken);

        /// <returns>Succesful document indexing request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IndexDocumentResponse> AddDocAsync(IndexDocumentRequest indexDocumentRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Succesful document indexing request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<IndexDocumentResponse> AddDocAsync(IndexDocumentRequest indexDocumentRequest, System.Threading.CancellationToken cancellationToken);

        /// <remarks>
        /// Get information from index regarding a list of files
        /// </remarks>
        /// <returns>Information from index for each file.  If a file is not found in the index, then null will be returned in the array for that file - a NotFound error will not be generated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetIndexDocumentInfoDocInfo>> DocInfoAsync(GetIndexDocumentInfoRequest getIndexDocumentInfoRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Get information from index regarding a list of files
        /// </remarks>
        /// <returns>Information from index for each file.  If a file is not found in the index, then null will be returned in the array for that file - a NotFound error will not be generated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetIndexDocumentInfoDocInfo>> DocInfoAsync(GetIndexDocumentInfoRequest getIndexDocumentInfoRequest, System.Threading.CancellationToken cancellationToken);

        /// <remarks>
        /// Find index documents based on index document type and update time
        /// </remarks>
        /// <returns>List of index documents matching request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FindIndexDocumentResponse> FindIndexDocsAsync(FindIndexDocumentsRequest findIndexDocumentsRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Find index documents based on index document type and update time
        /// </remarks>
        /// <returns>List of index documents matching request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FindIndexDocumentResponse> FindIndexDocsAsync(FindIndexDocumentsRequest findIndexDocumentsRequest, System.Threading.CancellationToken cancellationToken);

        /// <remarks>
        /// Delete all the index document chunks related to a blob file
        /// </remarks>
        /// <returns>Idempotent delete always returns 200.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteDocumentResponse> DeleteDocAsync(DeleteDocumentRequest deleteDocumentRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Delete all the index document chunks related to a blob file
        /// </remarks>
        /// <returns>Idempotent delete always returns 200.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteDocumentResponse> DeleteDocAsync(DeleteDocumentRequest deleteDocumentRequest, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CopilotClient : ICopilotClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public CopilotClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <returns>A HealthCheckStatus object</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<HealthResponse> HealthzAsync()
        {
            return HealthzAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A HealthCheckStatus object</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<HealthResponse> HealthzAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "healthz"
                    urlBuilder_.Append("healthz");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HealthResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ChatResponse> ChatAsync(ChatRequest chatRequest)
        {
            return ChatAsync(chatRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ChatResponse> ChatAsync(ChatRequest chatRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(chatRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "chat"
                    urlBuilder_.Append("chat");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ChatResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EmptyChatResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<EmptyChatResponse>("Successful empty response to empty chat request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>Requested rebuild opertion has completed sucessfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IndexRebuildResponse> RebuildAsync(IndexRebuildRequest indexRebuildRequest)
        {
            return RebuildAsync(indexRebuildRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Requested rebuild opertion has completed sucessfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IndexRebuildResponse> RebuildAsync(IndexRebuildRequest indexRebuildRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(indexRebuildRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "index/rebuild"
                    urlBuilder_.Append("index/rebuild");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IndexRebuildResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IndexRebuildResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>Succesful document indexing request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IndexDocumentResponse> AddDocAsync(IndexDocumentRequest indexDocumentRequest)
        {
            return AddDocAsync(indexDocumentRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>Succesful document indexing request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IndexDocumentResponse> AddDocAsync(IndexDocumentRequest indexDocumentRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(indexDocumentRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "index/add-doc"
                    urlBuilder_.Append("index/add-doc");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IndexDocumentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IndexDocumentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <remarks>
        /// Get information from index regarding a list of files
        /// </remarks>
        /// <returns>Information from index for each file.  If a file is not found in the index, then null will be returned in the array for that file - a NotFound error will not be generated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetIndexDocumentInfoDocInfo>> DocInfoAsync(GetIndexDocumentInfoRequest getIndexDocumentInfoRequest)
        {
            return DocInfoAsync(getIndexDocumentInfoRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Get information from index regarding a list of files
        /// </remarks>
        /// <returns>Information from index for each file.  If a file is not found in the index, then null will be returned in the array for that file - a NotFound error will not be generated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GetIndexDocumentInfoDocInfo>> DocInfoAsync(GetIndexDocumentInfoRequest getIndexDocumentInfoRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(getIndexDocumentInfoRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "index/doc-info"
                    urlBuilder_.Append("index/doc-info");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<GetIndexDocumentInfoDocInfo>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <remarks>
        /// Find index documents based on index document type and update time
        /// </remarks>
        /// <returns>List of index documents matching request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FindIndexDocumentResponse> FindIndexDocsAsync(FindIndexDocumentsRequest findIndexDocumentsRequest)
        {
            return FindIndexDocsAsync(findIndexDocumentsRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Find index documents based on index document type and update time
        /// </remarks>
        /// <returns>List of index documents matching request</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FindIndexDocumentResponse> FindIndexDocsAsync(FindIndexDocumentsRequest findIndexDocumentsRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(findIndexDocumentsRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "index/find-index-docs"
                    urlBuilder_.Append("index/find-index-docs");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FindIndexDocumentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No info found in the index for blob_file", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <remarks>
        /// Delete all the index document chunks related to a blob file
        /// </remarks>
        /// <returns>Idempotent delete always returns 200.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DeleteDocumentResponse> DeleteDocAsync(DeleteDocumentRequest deleteDocumentRequest)
        {
            return DeleteDocAsync(deleteDocumentRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <remarks>
        /// Delete all the index document chunks related to a blob file
        /// </remarks>
        /// <returns>Idempotent delete always returns 200.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DeleteDocumentResponse> DeleteDocAsync(DeleteDocumentRequest deleteDocumentRequest, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(deleteDocumentRequest, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "index/delete-doc"
                    urlBuilder_.Append("index/delete-doc");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteDocumentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Bad request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Internal server error", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthResponse
    {
        /// <summary>
        /// The key of the HealthCheckStatus object
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Key")]
        public string Key { get; set; }

        /// <summary>
        /// The current status of the HealthCheckStatus object
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        public string Status { get; set; }

        /// <summary>
        /// The description of the HealthCheckStatus object
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        public string Description { get; set; }

        /// <summary>
        /// The version of the HealthCheckStatus object
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public string Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Entries")]
        public Entries Entries { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChatRequestOptions
    {
        /// <summary>
        /// A hint to help choose the proper LLM
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("model_hint")]
        public string Model_hint { get; set; }

        /// <summary>
        /// A list of prompt hint to use to create the LLM prompt template
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("prompt_hints")]
        public System.Collections.Generic.ICollection<string> Prompt_hints { get; set; }

        /// <summary>
        /// A list of flags to control the behavior of the chat request.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("run_flags")]
        public System.Collections.Generic.ICollection<string> Run_flags { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChatResponseCitation
    {

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("pages")]
        public System.Collections.Generic.ICollection<string> Pages { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChatResponseDebugInfoDocument
    {

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("page")]
        public double? Page { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public string Content { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("score")]
        public double? Score { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChatRequest
    {
        /// <summary>
        /// The text to process.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_input")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string User_input { get; set; }

        /// <summary>
        /// Options for the chat request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("options")]
        public ChatRequestOptions Options { get; set; }

        /// <summary>
        /// Information about the context of the chat request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("context")]
        public Context Context { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChatResponse
    {
        /// <summary>
        /// The response from the chat processor.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("responseText")]
        public string ResponseText { get; set; }

        /// <summary>
        /// The format of the response (e.g., text/plain)
        /// <br/>May not be limited to MIME types (e.g., text/markup)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("response_format")]
        public string Response_format { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("citations")]
        public System.Collections.Generic.ICollection<ChatResponseCitation> Citations { get; set; }

        /// <summary>
        /// Debugging information (if reqeusted in request run_flags)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("debug_info")]
        public Debug_info Debug_info { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EmptyChatResponse
    {
        /// <summary>
        /// The empty string
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("responseText")]
        public string ResponseText { get; set; }

        /// <summary>
        /// text
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("response_format")]
        public string Response_format { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndexRebuildRequest
    {
        /// <summary>
        /// If the entire index shuold be dropped and recreated (Default = True)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("delete_and_recreate_index")]
        public bool? Delete_and_recreate_index { get; set; }

        /// <summary>
        /// True to return immediately, False to run syncronously. (Default = True)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("run_in_background")]
        public bool? Run_in_background { get; set; }

        /// <summary>
        /// The name of the index to use - for debugging and A/B testing (Normally should be omitted)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

        /// <summary>
        /// When to generate document summaries - ifNewer | Off | force (Default = ifNewer)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("generate_summaries_mode")]
        public string Generate_summaries_mode { get; set; }

        /// <summary>
        /// When to generate document indexes - ifNewer | Off | force (Default = ifNewer)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("generate_index_mode")]
        public string Generate_index_mode { get; set; }

        /// <summary>
        /// Number of thread pool threads to use to index files in parallel
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("num_threads")]
        public object Num_threads { get; set; }

        /// <summary>
        /// Size of document chunk in characters
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("chunk_size")]
        public object Chunk_size { get; set; }

        /// <summary>
        /// Size of document chunk overlap in characters
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("chunk_overlap")]
        public object Chunk_overlap { get; set; }

        /// <summary>
        /// Include doc chunks even if metadata indicates file is no copilot-enabled. wholeDoc and summary documents will always be created if specified.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("include_chunkdocs_for_copilot_disabled_files")]
        public bool? Include_chunkdocs_for_copilot_disabled_files { get; set; }

        /// <summary>
        /// The optional strategy used to index the document 'overlap' | 'page-overlap'
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("indexing_strategy")]
        public string Indexing_strategy { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndexRebuildResponse
    {
        /// <summary>
        /// Status (Started | AlreadyInProgress) of the indexing request
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The job id of the idexing job
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("job_id")]
        public string Job_id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndexDocumentRequest
    {
        /// <summary>
        /// The blob file uri to index
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("blob_file")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Blob_file { get; set; }

        /// <summary>
        /// When to generate document summaries - ifNewer | Off | force (Default = ifNewer)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("generate_summaries_mode")]
        public string Generate_summaries_mode { get; set; }

        /// <summary>
        /// When to generate document indexes - ifNewer | Off | force (Default = ifNewer)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("generate_index_mode")]
        public string Generate_index_mode { get; set; }

        /// <summary>
        /// True to return immediately, False to run syncronously. (Default = True)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("run_in_background")]
        public bool? Run_in_background { get; set; }

        /// <summary>
        /// The name of the index to use - for debugging and A/B testing (Normally should be omitted)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

        /// <summary>
        /// Include doc chunks even if metadata indicates file is no copilot-enabled. wholeDoc and summary documents will always be created if specified.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("include_chunkdocs_for_copilot_disabled_files")]
        public bool? Include_chunkdocs_for_copilot_disabled_files { get; set; }

        /// <summary>
        /// The optional strategy used to index the document. 'overlap' | 'page-overlap' Should be omitted except by internal code.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("indexing_strategy")]
        public string Indexing_strategy { get; set; }

        /// <summary>
        /// Size of document chunk in characters. Should be omitted except by internal code.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("chunk_size")]
        public object Chunk_size { get; set; }

        /// <summary>
        /// Size of document chunk in characters. Should be omitted except by internal code.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("chunk_overlap")]
        public object Chunk_overlap { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndexDocumentResponse
    {
        /// <summary>
        /// Status (OK) of the indexing request (TODO partial response list?)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The job id of the background indexing job
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("job_id")]
        public string Job_id { get; set; }

        /// <summary>
        /// null when run in background
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("num_index_chunks_added")]
        public double? Num_index_chunks_added { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetIndexDocumentInfoDocInfo
    {
        /// <summary>
        /// The storage location of the file
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("uri")]
        public string Uri { get; set; }

        /// <summary>
        /// The name of the file
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("file")]
        public string File { get; set; }

        /// <summary>
        /// ISO time string when document was indexed
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("indexed_time")]
        public System.DateTimeOffset? Indexed_time { get; set; }

        /// <summary>
        /// LLM-generated summary for document, if any
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("summary")]
        public string Summary { get; set; }

        /// <summary>
        /// ISO time string when summary was created/updated
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("summary_updated_time")]
        public System.DateTimeOffset? Summary_updated_time { get; set; }

        /// <summary>
        /// The size in bytes of the source document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("document_size")]
        public double? Document_size { get; set; }

        /// <summary>
        /// The number of docChunk index documents
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("num_chunk_docs")]
        public double? Num_chunk_docs { get; set; }

        /// <summary>
        /// True if the document is copilot-enabled and searched by default
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("copilot_enabled")]
        public bool? Copilot_enabled { get; set; }

        /// <summary>
        /// Escaped JSON string containing metadata sync from Document twin
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("metadata_json")]
        public string Metadata_json { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetIndexDocumentInfoRequest
    {
        /// <summary>
        /// The files to retreive information for
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("blob_files")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Blob_files { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// The name of the index to use - for debugging and A/B testing (Normally should be omitted)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetIndexDocumentInfoResponse : System.Collections.ObjectModel.Collection<GetIndexDocumentInfoDocInfo>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FindIndexDocumentsDocument
    {
        /// <summary>
        /// The URI of the target document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("uri")]
        public string Uri { get; set; }

        /// <summary>
        /// The ID of the index document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The type of the index document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("doc_type")]
        public string Doc_type { get; set; }

        /// <summary>
        /// The textual content of the index document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// The time the index document was last updated
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("indexed_time")]
        public System.DateTimeOffset? Indexed_time { get; set; }

        /// <summary>
        /// The size of the index document in bytes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("document_size")]
        public object Document_size { get; set; }

        /// <summary>
        /// The metadata attched to the index document
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("metadata_json")]
        public string Metadata_json { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FindIndexDocumentsRequest
    {
        /// <summary>
        /// The optional type of index document (docSummary|docWhole|docChunk)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("document_type")]
        public string Document_type { get; set; }

        /// <summary>
        /// The optional ISO time to find documents with update times newer-than
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("last_updated_time")]
        public System.DateTimeOffset? Last_updated_time { get; set; }

        /// <summary>
        /// The name of the index to use - for debugging and A/B testing (Normally should be omitted)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("page_size")]
        public double? Page_size { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("page_number")]
        public double? Page_number { get; set; }

        /// <summary>
        /// Whether to include metadata_json
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("include_metadata")]
        public bool? Include_metadata { get; set; }

        /// <summary>
        /// Whether to include content
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("include_content")]
        public bool? Include_content { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FindIndexDocumentResponse
    {
        /// <summary>
        /// The total number of index documents found
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("total_count")]
        public double? Total_count { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("index_documents")]
        public System.Collections.Generic.ICollection<FindIndexDocumentsDocument> Index_documents { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeleteDocumentRequest
    {
        /// <summary>
        /// The file to be deleted from the index
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("blob_file")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Blob_file { get; set; }

        /// <summary>
        /// The name of the index to use - for debugging and A/B testing (Normally should be omitted)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeleteDocumentResponse
    {
        /// <summary>
        /// Status (OK | NotFound) of the indexing request
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The number of document chunks deleted from the index
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("num_index_docs_deleted")]
        public double? Num_index_docs_deleted { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Entries
    {

        [System.Text.Json.Serialization.JsonPropertyName("azure-search")]
        public HealthResponse AzureSearch { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("azure-openai")]
        public HealthResponse AzureOpenai { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Context
    {
        /// <summary>
        /// ID of the session used to attach to  cached resources such as conversation memory.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("session_id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Session_id { get; set; }

        /// <summary>
        /// The name of the user.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

        /// <summary>
        /// The email of the user.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_email")]
        public string User_email { get; set; }

        /// <summary>
        /// The ID (must unique between callers) of the user. Should not be PII.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_id")]
        public string User_id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Debug_info
    {
        /// <summary>
        /// The number of LLM tokens used during processing
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("num_tokens_used")]
        public double? Num_tokens_used { get; set; }

        /// <summary>
        /// The number of LLM tokens currently used for chat history
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("history_tokens_used")]
        public double? History_tokens_used { get; set; }

        /// <summary>
        /// The max number of LLM tokens allowed in chat history
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("history_max_tokens")]
        public double? History_max_tokens { get; set; }

        /// <summary>
        /// The number of dialog turns currently in history
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("history_turns")]
        public double? History_turns { get; set; }

        /// <summary>
        /// The index used for document search
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("index_name")]
        public string Index_name { get; set; }

        /// <summary>
        /// The user's input question
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_question")]
        public string User_question { get; set; }

        /// <summary>
        /// The user's question rephrased by the llm (if applicable)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("generated_question")]
        public string Generated_question { get; set; }

        /// <summary>
        /// The contents of the chat history buffer
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("history_summary_buffer")]
        public string History_summary_buffer { get; set; }

        /// <summary>
        /// The main LLM prompt used
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("prompt")]
        public string Prompt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("citations")]
        public System.Collections.Generic.ICollection<ChatResponseCitation> Citations { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("documents")]
        public System.Collections.Generic.ICollection<ChatResponseDebugInfoDocument> Documents { get; set; }

        /// <summary>
        /// The response from the main LLM call before any pre-processing
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("llm_response")]
        public string Llm_response { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("request_options")]
        public ChatRequestOptions Request_options { get; set; }

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625